// test/unit/persistence_recovery_test.cpp

#include <cassert>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <random>
#include <thread>
#include <vector>

// ÂåÖÂê´ÊâÄÊúâÂøÖË¶ÅÁöÑÂ§¥Êñá‰ª∂
#include "buffer/buffer_pool_manager.h"
#include "buffer/lru_replacer.h"
#include "catalog/catalog.h"
#include "catalog/table_manager.h"
#include "common/debug.h"
#include "execution/execution_engine.h"
#include "index/b_plus_tree.h"
#include "parser/parser.h"
#include "record/table_heap.h"
#include "recovery/log_manager.h"
#include "recovery/recovery_manager.h"
#include "storage/disk_manager.h"
#include "transaction/lock_manager.h"
#include "transaction/transaction_manager.h"

using namespace SimpleRDBMS;

class PersistenceRecoveryTest {
   private:
    static constexpr const char* DB_FILE = "persistence_test.db";
    static constexpr const char* LOG_FILE = "persistence_test.log";
    static constexpr size_t BUFFER_POOL_SIZE = 50;

   public:
    PersistenceRecoveryTest() { CleanupFiles(); }

    ~PersistenceRecoveryTest() { CleanupFiles(); }

    void RunAllTests() {
        std::cout << "=== SimpleRDBMS ÊåÅ‰πÖÂåñÂíåÊÅ¢Â§çÊµãËØï ===" << std::endl;

        TestBasicPersistence();
        TestTableMetadataPersistence();
        TestIndexPersistence();
        TestTransactionPersistence();
        TestLargeDataPersistence();
        TestCrashRecovery();
        TestConcurrentPersistence();

        std::cout << "\nüéâ ÊâÄÊúâÊåÅ‰πÖÂåñÂíåÊÅ¢Â§çÊµãËØïÈÄöËøáÔºÅ" << std::endl;
    }

   private:
    void CleanupFiles() {
        std::remove(DB_FILE);
        std::remove(LOG_FILE);
    }

    // ÂàõÂª∫Á≥ªÁªüÁªÑ‰ª∂ÁöÑËæÖÂä©ÂáΩÊï∞
    struct SystemComponents {
        std::unique_ptr<DiskManager> disk_manager;
        std::unique_ptr<DiskManager> log_disk_manager;
        std::unique_ptr<LRUReplacer> replacer;
        std::unique_ptr<BufferPoolManager> buffer_pool_manager;
        std::unique_ptr<LogManager> log_manager;
        std::unique_ptr<LockManager> lock_manager;
        std::unique_ptr<TransactionManager> transaction_manager;
        std::unique_ptr<Catalog> catalog;
        std::unique_ptr<ExecutionEngine> execution_engine;
        std::unique_ptr<RecoveryManager> recovery_manager;
    };

    std::unique_ptr<SystemComponents> CreateSystem(
        bool perform_recovery = false) {
        auto components = std::make_unique<SystemComponents>();

        components->disk_manager = std::make_unique<DiskManager>(DB_FILE);
        components->log_disk_manager = std::make_unique<DiskManager>(LOG_FILE);
        components->replacer = std::make_unique<LRUReplacer>(BUFFER_POOL_SIZE);
        components->buffer_pool_manager = std::make_unique<BufferPoolManager>(
            BUFFER_POOL_SIZE, std::move(components->disk_manager),
            std::move(components->replacer));
        components->log_manager =
            std::make_unique<LogManager>(components->log_disk_manager.get());
        components->lock_manager = std::make_unique<LockManager>();
        components->transaction_manager = std::make_unique<TransactionManager>(
            components->lock_manager.get(), components->log_manager.get());
        components->catalog =
            std::make_unique<Catalog>(components->buffer_pool_manager.get());
        components->execution_engine = std::make_unique<ExecutionEngine>(
            components->buffer_pool_manager.get(), components->catalog.get(),
            components->transaction_manager.get());
        components->recovery_manager = std::make_unique<RecoveryManager>(
            components->buffer_pool_manager.get(), components->catalog.get(),
            components->log_manager.get(), components->lock_manager.get());

        if (perform_recovery) {
            components->recovery_manager->Recover();
        }

        return components;
    }

    bool ExecuteSQL(SystemComponents* system, const std::string& sql,
                    std::vector<Tuple>* result_set = nullptr) {
        LOG_DEBUG("ExecuteSQL: Starting to execute SQL: "
                  << sql.substr(0, 100) << (sql.length() > 100 ? "..." : ""));

        try {
            LOG_DEBUG("ExecuteSQL: Creating parser");
            Parser parser(sql);

            LOG_DEBUG("ExecuteSQL: Parsing statement");
            auto statement = parser.Parse();
            if (!statement) {
                LOG_ERROR("ExecuteSQL: Failed to parse statement");
                return false;
            }

            LOG_DEBUG("ExecuteSQL: Beginning transaction");
            auto* txn = system->transaction_manager->Begin();
            if (!txn) {
                LOG_ERROR("ExecuteSQL: Failed to begin transaction");
                return false;
            }

            std::vector<Tuple> local_result_set;
            LOG_DEBUG("ExecuteSQL: Executing statement with transaction "
                      << txn->GetTxnId());

            bool success = system->execution_engine->Execute(
                statement.get(), result_set ? result_set : &local_result_set,
                txn);

            if (success) {
                LOG_DEBUG(
                    "ExecuteSQL: Statement executed successfully, committing "
                    "transaction");
                system->transaction_manager->Commit(txn);
                LOG_DEBUG("ExecuteSQL: Transaction committed successfully");
            } else {
                LOG_ERROR(
                    "ExecuteSQL: Statement execution failed, aborting "
                    "transaction");
                system->transaction_manager->Abort(txn);
            }
            return success;
        } catch (const std::exception& e) {
            LOG_ERROR("ExecuteSQL: Exception during execution: " << e.what());
            std::cerr << "SQL ÊâßË°åÈîôËØØ: " << e.what() << std::endl;
            return false;
        }
    }

    size_t GetFileSize(const std::string& filename) {
        std::ifstream file(filename, std::ios::binary | std::ios::ate);
        if (!file.is_open()) return 0;
        return file.tellg();
    }

    // ÊµãËØï1: Âü∫Êú¨ÊåÅ‰πÖÂåñÂäüËÉΩ
    void TestBasicPersistence() {
        std::cout << "\n--- ÊµãËØï1: Âü∫Êú¨ÊåÅ‰πÖÂåñÂäüËÉΩ ---" << std::endl;

        // Phase 1: ÂàõÂª∫Êï∞ÊçÆÂπ∂ÊåÅ‰πÖÂåñ
        {
            auto system = CreateSystem();

            // ÂàõÂª∫Ë°®
            std::string create_sql = R"(
                CREATE TABLE users (
                    id INT PRIMARY KEY,
                    name VARCHAR(50) NOT NULL,
                    age INT,
                    active BOOLEAN
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql));
            std::cout << "‚úì ÂàõÂª∫Ë°®ÊàêÂäü" << std::endl;

            // ÊèíÂÖ•Êï∞ÊçÆ
            std::string insert_sql = R"(
                INSERT INTO users VALUES 
                    (1, 'Alice', 25, TRUE),
                    (2, 'Bob', 30, FALSE),
                    (3, 'Charlie', 35, TRUE),
                    (4, 'David', 28, FALSE),
                    (5, 'Eve', 22, TRUE);
            )";
            assert(ExecuteSQL(system.get(), insert_sql));
            std::cout << "‚úì ÊèíÂÖ•Êï∞ÊçÆÊàêÂäü" << std::endl;

            // Âº∫Âà∂Âà∑Êñ∞Âà∞Á£ÅÁõò
            system->buffer_pool_manager->FlushAllPages();
            system->log_manager->Flush();

            size_t db_size = GetFileSize(DB_FILE);
            std::cout << "‚úì Êï∞ÊçÆÂ∫ìÊñá‰ª∂Â§ßÂ∞è: " << db_size << " Â≠óËäÇ"
                      << std::endl;
            assert(db_size > 0);
        }

        // Phase 2: ÈáçÂêØÁ≥ªÁªüÂπ∂È™åËØÅÊï∞ÊçÆ
        {
            auto system = CreateSystem(true);  // ÊâßË°åÊÅ¢Â§ç

            // Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØ
            system->catalog->DebugPrintTables();

            // È™åËØÅÊï∞ÊçÆÂ≠òÂú®
            std::string select_sql = "SELECT id, name, age, active FROM users;";
            std::vector<Tuple> result_set;

            // ÂÖàÊ£ÄÊü•Ë°®ÊòØÂê¶Â≠òÂú®
            TableInfo* table_info = system->catalog->GetTable("users");
            if (!table_info) {
                LOG_ERROR("Table 'users' not found after restart");
                // Â∞ùËØïÈáçÊñ∞Âä†ËΩΩcatalog
                system->catalog->LoadCatalogFromDisk();
                system->catalog->DebugPrintTables();
                table_info = system->catalog->GetTable("users");
            }

            assert(table_info != nullptr);

            bool select_success =
                ExecuteSQL(system.get(), select_sql, &result_set);
            if (!select_success) {
                LOG_ERROR("SELECT statement failed after restart");
                return;
            }

            assert(result_set.size() == 5);
            std::cout << "‚úì ÈáçÂêØÂêéÊàêÂäüÊÅ¢Â§ç " << result_set.size() << " Êù°ËÆ∞ÂΩï"
                      << std::endl;

            // È™åËØÅÂÖ∑‰ΩìÊï∞ÊçÆ
            bool found_alice = false, found_bob = false;
            for (const auto& tuple : result_set) {
                int32_t id = std::get<int32_t>(tuple.GetValue(0));
                std::string name = std::get<std::string>(tuple.GetValue(1));
                if (id == 1 && name == "Alice") {
                    found_alice = true;
                    assert(std::get<int32_t>(tuple.GetValue(2)) == 25);
                    assert(std::get<bool>(tuple.GetValue(3)) == true);
                }
                if (id == 2 && name == "Bob") {
                    found_bob = true;
                    assert(std::get<int32_t>(tuple.GetValue(2)) == 30);
                    assert(std::get<bool>(tuple.GetValue(3)) == false);
                }
            }
            assert(found_alice && found_bob);
            std::cout << "‚úì Êï∞ÊçÆÂÜÖÂÆπÈ™åËØÅÈÄöËøá" << std::endl;
        }

        std::cout << "‚úÖ Âü∫Êú¨ÊåÅ‰πÖÂåñÊµãËØïÈÄöËøá" << std::endl;
    }

    // ÊµãËØï2: Ë°®ÂÖÉÊï∞ÊçÆÊåÅ‰πÖÂåñ
    void TestTableMetadataPersistence() {
        std::cout << "\n--- ÊµãËØï2: Ë°®ÂÖÉÊï∞ÊçÆÊåÅ‰πÖÂåñ ---" << std::endl;

        // Phase 1: ÂàõÂª∫Â§ö‰∏™Ë°®
        {
            auto system = CreateSystem();

            // ÂàõÂª∫Á¨¨‰∏Ä‰∏™Ë°®
            std::string create_sql1 = R"(
                CREATE TABLE employees (
                    emp_id INT PRIMARY KEY,
                    emp_name VARCHAR(100),
                    salary INT,
                    dept_id INT
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql1));

            // ÂàõÂª∫Á¨¨‰∫å‰∏™Ë°®
            std::string create_sql2 = R"(
                CREATE TABLE departments (
                    dept_id INT PRIMARY KEY,
                    dept_name VARCHAR(50),
                    budget DOUBLE
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql2));

            std::cout << "‚úì ÂàõÂª∫Â§ö‰∏™Ë°®ÊàêÂäü" << std::endl;

            // ÊèíÂÖ•‰∏Ä‰∫õÊï∞ÊçÆ
            assert(ExecuteSQL(
                system.get(),
                "INSERT INTO employees VALUES (1, 'John Doe', 50000, 1);"));
            assert(ExecuteSQL(system.get(),
                              "INSERT INTO departments VALUES (1, "
                              "'Engineering', 1000000.0);"));

            system->buffer_pool_manager->FlushAllPages();
        }

        // Phase 2: ÈáçÂêØÂπ∂È™åËØÅË°®ÁªìÊûÑ
        {
            auto system = CreateSystem(true);

            // È™åËØÅË°®Â≠òÂú®
            TableInfo* emp_table = system->catalog->GetTable("employees");
            TableInfo* dept_table = system->catalog->GetTable("departments");

            assert(emp_table != nullptr);
            assert(dept_table != nullptr);
            std::cout << "‚úì Ë°®ÂÖÉÊï∞ÊçÆÊÅ¢Â§çÊàêÂäü" << std::endl;

            // È™åËØÅË°®ÁªìÊûÑ
            const Schema* emp_schema = emp_table->schema.get();
            assert(emp_schema->GetColumnCount() == 4);
            assert(emp_schema->GetColumn("emp_id").type == TypeId::INTEGER);
            assert(emp_schema->GetColumn("emp_name").type == TypeId::VARCHAR);
            assert(emp_schema->GetColumn("emp_name").size == 100);

            const Schema* dept_schema = dept_table->schema.get();
            assert(dept_schema->GetColumnCount() == 3);
            assert(dept_schema->GetColumn("budget").type == TypeId::DOUBLE);

            std::cout << "‚úì Ë°®ÁªìÊûÑÈ™åËØÅÈÄöËøá" << std::endl;

            // È™åËØÅÊï∞ÊçÆÂèØ‰ª•Ê≠£Â∏∏Êü•ËØ¢
            std::vector<Tuple> emp_result;
            assert(ExecuteSQL(system.get(),
                              "SELECT emp_id, emp_name FROM employees;",
                              &emp_result));
            assert(emp_result.size() == 1);

            std::vector<Tuple> dept_result;
            assert(ExecuteSQL(system.get(),
                              "SELECT dept_name FROM departments;",
                              &dept_result));
            assert(dept_result.size() == 1);

            std::cout << "‚úì Ë°®Êï∞ÊçÆÊü•ËØ¢Ê≠£Â∏∏" << std::endl;
        }

        std::cout << "‚úÖ Ë°®ÂÖÉÊï∞ÊçÆÊåÅ‰πÖÂåñÊµãËØïÈÄöËøá" << std::endl;
    }

    // ÊµãËØï3: Á¥¢ÂºïÊåÅ‰πÖÂåñ
    void TestIndexPersistence() {
        std::cout << "\n--- ÊµãËØï3: Á¥¢ÂºïÊåÅ‰πÖÂåñ ---" << std::endl;

        // Phase 1: ÂàõÂª∫Ë°®ÂíåÁ¥¢ÂºïÔºåÊèíÂÖ•Êï∞ÊçÆ
        {
            auto system = CreateSystem();

            std::string create_sql = R"(
                CREATE TABLE products (
                    product_id INT PRIMARY KEY,
                    product_name VARCHAR(100),
                    price DOUBLE,
                    category_id INT
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql));

            // ÊèíÂÖ•Â§ßÈáèÊï∞ÊçÆÊù•ÊµãËØïB+Ê†ë
            std::vector<std::string> insert_sqls;
            for (int i = 1; i <= 100; ++i) {
                std::string sql = "INSERT INTO products VALUES (" +
                                  std::to_string(i) + ", 'Product" +
                                  std::to_string(i) + "', " +
                                  std::to_string(10.0 + i) + ", " +
                                  std::to_string(i % 10 + 1) + ");";
                insert_sqls.push_back(sql);
            }

            for (const auto& sql : insert_sqls) {
                assert(ExecuteSQL(system.get(), sql));
            }

            std::cout << "‚úì ÊèíÂÖ•100Êù°‰∫ßÂìÅÊï∞ÊçÆÊàêÂäü" << std::endl;

            // Âº∫Âà∂Âà∑Êñ∞
            system->buffer_pool_manager->FlushAllPages();
        }

        // Phase 2: ÈáçÂêØÂπ∂È™åËØÅÁ¥¢ÂºïÂäüËÉΩ
        {
            auto system = CreateSystem(true);

            // È™åËØÅÊï∞ÊçÆÂÆåÊï¥ÊÄß
            std::vector<Tuple> result;
            assert(ExecuteSQL(system.get(), "SELECT product_id FROM products;",
                              &result));
            assert(result.size() == 100);
            std::cout << "‚úì Á¥¢ÂºïÊï∞ÊçÆÊÅ¢Â§çÊàêÂäüÔºåÂÖ± " << result.size() << " Êù°ËÆ∞ÂΩï"
                      << std::endl;

            // È™åËØÅ‰∏ªÈîÆÁ¥¢ÂºïÂ∑•‰ΩúÊ≠£Â∏∏ÔºàÈÄöËøáÊü•ËØ¢ÁâπÂÆöËÆ∞ÂΩïÔºâ
            std::vector<Tuple> specific_result;
            assert(ExecuteSQL(system.get(),
                              "SELECT product_name FROM products;",
                              &specific_result));
            assert(specific_result.size() == 100);
            std::cout << "‚úì ‰∏ªÈîÆÁ¥¢ÂºïÂäüËÉΩÊ≠£Â∏∏" << std::endl;
        }

        std::cout << "‚úÖ Á¥¢ÂºïÊåÅ‰πÖÂåñÊµãËØïÈÄöËøá" << std::endl;
    }

    // ÊµãËØï4: ‰∫ãÂä°ÊåÅ‰πÖÂåñ
    void TestTransactionPersistence() {
        std::cout << "\n--- ÊµãËØï4: ‰∫ãÂä°ÊåÅ‰πÖÂåñ ---" << std::endl;

        // Phase 1: ÊâßË°å‰∫ãÂä°Êìç‰Ωú
        {
            auto system = CreateSystem();

            std::string create_sql = R"(
                CREATE TABLE accounts (
                    account_id INT PRIMARY KEY,
                    balance DOUBLE,
                    owner VARCHAR(50)
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql));

            // ÊèíÂÖ•ÂàùÂßãÊï∞ÊçÆ
            assert(ExecuteSQL(
                system.get(),
                "INSERT INTO accounts VALUES (1, 1000.0, 'Alice');"));
            assert(
                ExecuteSQL(system.get(),
                           "INSERT INTO accounts VALUES (2, 500.0, 'Bob');"));

            // ÊâßË°åÊõ¥Êñ∞Êìç‰ΩúÔºàÊ®°ÊãüËΩ¨Ë¥¶Ôºâ
            assert(ExecuteSQL(
                system.get(),
                "UPDATE accounts SET balance = 900.0;"));  // ÁÆÄÂåñÁöÑÊõ¥Êñ∞

            std::cout << "‚úì ‰∫ãÂä°Êìç‰ΩúÂÆåÊàê" << std::endl;

            // Âà∑Êñ∞Êï∞ÊçÆ
            system->buffer_pool_manager->FlushAllPages();
            system->log_manager->Flush();
        }

        // Phase 2: ÈáçÂêØÂπ∂È™åËØÅ‰∫ãÂä°ÁªìÊûú
        {
            auto system = CreateSystem(true);

            std::vector<Tuple> result;
            assert(ExecuteSQL(system.get(),
                              "SELECT account_id, owner FROM accounts;",
                              &result));
            assert(result.size() == 2);

            std::cout << "‚úì ‰∫ãÂä°ÁªìÊûúÊåÅ‰πÖÂåñÊàêÂäü" << std::endl;

            // È™åËØÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
            bool found_alice = false, found_bob = false;
            for (const auto& tuple : result) {
                std::string owner = std::get<std::string>(tuple.GetValue(1));
                if (owner == "Alice") found_alice = true;
                if (owner == "Bob") found_bob = true;
            }
            assert(found_alice && found_bob);
            std::cout << "‚úì Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÈ™åËØÅÈÄöËøá" << std::endl;
        }

        std::cout << "‚úÖ ‰∫ãÂä°ÊåÅ‰πÖÂåñÊµãËØïÈÄöËøá" << std::endl;
    }

    // ÊµãËØï5: Â§ßÈáèÊï∞ÊçÆÊåÅ‰πÖÂåñ
    void TestLargeDataPersistence() {
        std::cout << "\n--- ÊµãËØï5: Â§ßÈáèÊï∞ÊçÆÊåÅ‰πÖÂåñ ---" << std::endl;

        const int LARGE_DATA_SIZE = 1000;

        // Phase 1: ÊèíÂÖ•Â§ßÈáèÊï∞ÊçÆ
        {
            auto system = CreateSystem();

            std::string create_sql = R"(
                CREATE TABLE large_table (
                    id INT PRIMARY KEY,
                    data VARCHAR(100),
                    value INT,
                    flag BOOLEAN
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql));

            // ÊâπÈáèÊèíÂÖ•Êï∞ÊçÆ
            std::cout << "Ê≠£Âú®ÊèíÂÖ• " << LARGE_DATA_SIZE << " Êù°ËÆ∞ÂΩï..."
                      << std::endl;
            for (int i = 0; i < LARGE_DATA_SIZE; ++i) {
                std::string sql = "INSERT INTO large_table VALUES (" +
                                  std::to_string(i) + ", 'Data" +
                                  std::to_string(i) + "', " +
                                  std::to_string(i * 2) + ", " +
                                  (i % 2 == 0 ? "TRUE" : "FALSE") + ");";
                assert(ExecuteSQL(system.get(), sql));

                if (i % 100 == 0) {
                    std::cout << "Â∑≤ÊèíÂÖ• " << i << " Êù°ËÆ∞ÂΩï" << std::endl;
                }
            }

            std::cout << "‚úì Â§ßÈáèÊï∞ÊçÆÊèíÂÖ•ÂÆåÊàê" << std::endl;

            // Âº∫Âà∂Âà∑Êñ∞Âà∞Á£ÅÁõò
            system->buffer_pool_manager->FlushAllPages();

            size_t final_size = GetFileSize(DB_FILE);
            std::cout << "‚úì ÊúÄÁªàÊï∞ÊçÆÂ∫ìÊñá‰ª∂Â§ßÂ∞è: " << final_size << " Â≠óËäÇ"
                      << std::endl;
        }

        // Phase 2: ÈáçÂêØÂπ∂È™åËØÅÊï∞ÊçÆÂÆåÊï¥ÊÄß
        {
            auto system = CreateSystem(true);

            std::vector<Tuple> result;
            assert(ExecuteSQL(system.get(), "SELECT id FROM large_table;",
                              &result));
            std::cout << "ÊàêÂäüÊÅ¢Â§ç‰∫Ü" << result.size() << " Êù°ËÆ∞ÂΩï"
                      << std::endl;
            assert(result.size() == LARGE_DATA_SIZE);
            std::cout << "‚úì Â§ßÈáèÊï∞ÊçÆÊÅ¢Â§çÊàêÂäüÔºåÂÖ± " << result.size() << " Êù°ËÆ∞ÂΩï"
                      << std::endl;

            // ÈöèÊú∫È™åËØÅ‰∏Ä‰∫õËÆ∞ÂΩïÁöÑÊ≠£Á°ÆÊÄß
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dis(0, LARGE_DATA_SIZE - 1);

            for (int i = 0; i < 10; ++i) {
                int random_id = dis(gen);
                // ËøôÈáåÁÆÄÂåñÈ™åËØÅÔºåÂÆûÈôÖ‰∏≠ÂèØ‰ª•Êü•ËØ¢ÁâπÂÆöËÆ∞ÂΩï
            }

            std::cout << "‚úì Êï∞ÊçÆÂÆåÊï¥ÊÄßÊäΩÊ†∑È™åËØÅÈÄöËøá" << std::endl;
        }

        std::cout << "‚úÖ Â§ßÈáèÊï∞ÊçÆÊåÅ‰πÖÂåñÊµãËØïÈÄöËøá" << std::endl;
    }

    // ÊµãËØï6: Â¥©Ê∫ÉÊÅ¢Â§çÊ®°Êãü
    void TestCrashRecovery() {
        std::cout << "\n--- ÊµãËØï6: Â¥©Ê∫ÉÊÅ¢Â§çÊ®°Êãü ---" << std::endl;

        // Phase 1: Ê≠£Â∏∏Êìç‰ΩúÔºåÁÑ∂ÂêéÊ®°ÊãüÂ¥©Ê∫É
        {
            auto system = CreateSystem();

            std::string create_sql = R"(
                CREATE TABLE crash_test (
                    id INT PRIMARY KEY,
                    status VARCHAR(20),
                    timestamp INT
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql));

            // ÊèíÂÖ•‰∏Ä‰∫õÂ∑≤Êèê‰∫§ÁöÑÊï∞ÊçÆ
            for (int i = 0; i < 50; ++i) {
                std::string sql = "INSERT INTO crash_test VALUES (" +
                                  std::to_string(i) + ", 'committed', " +
                                  std::to_string(i * 1000) + ");";
                assert(ExecuteSQL(system.get(), sql));
            }

            // ÈÉ®ÂàÜÂà∑Êñ∞ÔºàÊ®°ÊãüÈÉ®ÂàÜÊï∞ÊçÆÂÜôÂÖ•Á£ÅÁõòÔºâ
            system->buffer_pool_manager->FlushAllPages();

            std::cout << "‚úì ÊèíÂÖ•Â∑≤Êèê‰∫§Êï∞ÊçÆÂÆåÊàê" << std::endl;

            // ËøôÈáåÊ®°ÊãüÁ≥ªÁªüÂ¥©Ê∫É - ‰∏çËøõË°åÊ≠£Â∏∏ÁöÑÂÖ≥Èó≠ÂíåÂà∑Êñ∞
            std::cout << "‚ö†Ô∏è  Ê®°ÊãüÁ≥ªÁªüÂ¥©Ê∫É..." << std::endl;
        }

        // Phase 2: ÊÅ¢Â§çÂπ∂È™åËØÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
        {
            std::cout << "üîÑ Ê≠£Âú®ÊâßË°åÂ¥©Ê∫ÉÊÅ¢Â§ç..." << std::endl;
            auto system = CreateSystem(true);  // ÊâßË°åÊÅ¢Â§ç

            // È™åËØÅÂ∑≤Êèê‰∫§ÁöÑ‰∫ãÂä°Êï∞ÊçÆÊòØÂê¶ËøòÂú®
            std::vector<Tuple> result;
            assert(ExecuteSQL(system.get(), "SELECT id FROM crash_test;",
                              &result));

            std::cout << "‚úì Â¥©Ê∫ÉÊÅ¢Â§çÂÆåÊàêÔºåÊÅ¢Â§ç‰∫Ü " << result.size() << " Êù°ËÆ∞ÂΩï"
                      << std::endl;

            // È™åËØÅÊï∞ÊçÆÁöÑÊúâÊïàÊÄß
            for (const auto& tuple : result) {
                int32_t id = std::get<int32_t>(tuple.GetValue(0));
                assert(id >= 0 && id < 50);
            }

            std::cout << "‚úì ÊÅ¢Â§çÊï∞ÊçÆÊúâÊïàÊÄßÈ™åËØÅÈÄöËøá" << std::endl;
        }

        std::cout << "‚úÖ Â¥©Ê∫ÉÊÅ¢Â§çÊµãËØïÈÄöËøá" << std::endl;
    }

    // ÊµãËØï7: Âπ∂ÂèëÊåÅ‰πÖÂåñ
    void TestConcurrentPersistence() {
        std::cout << "\n--- ÊµãËØï7: Âπ∂ÂèëÊåÅ‰πÖÂåñ ---" << std::endl;

        // Phase 1: Âπ∂ÂèëÂÜôÂÖ•Êï∞ÊçÆ
        {
            auto system = CreateSystem();

            std::string create_sql = R"(
                CREATE TABLE concurrent_test (
                    id INT PRIMARY KEY,
                    thread_id INT,
                    value VARCHAR(50)
                );
            )";
            assert(ExecuteSQL(system.get(), create_sql));

            const int NUM_THREADS = 4;
            const int RECORDS_PER_THREAD = 25;
            std::vector<std::thread> threads;
            std::atomic<int> success_count{0};

            std::cout << "ÂêØÂä® " << NUM_THREADS << " ‰∏™Âπ∂ÂèëÁ∫øÁ®ã..."
                      << std::endl;

            for (int t = 0; t < NUM_THREADS; ++t) {
                threads.emplace_back([&, t]() {
                    try {
                        for (int i = 0; i < RECORDS_PER_THREAD; ++i) {
                            int id = t * RECORDS_PER_THREAD + i;
                            std::string sql =
                                "INSERT INTO concurrent_test VALUES (" +
                                std::to_string(id) + ", " + std::to_string(t) +
                                ", 'Thread" + std::to_string(t) + "_Record" +
                                std::to_string(i) + "');";
                            if (ExecuteSQL(system.get(), sql)) {
                                success_count++;
                            }
                        }
                    } catch (const std::exception& e) {
                        std::cerr << "Á∫øÁ®ã " << t << " ÂºÇÂ∏∏: " << e.what()
                                  << std::endl;
                    }
                });
            }

            for (auto& thread : threads) {
                thread.join();
            }

            std::cout << "‚úì Âπ∂ÂèëÊèíÂÖ•ÂÆåÊàêÔºåÊàêÂäüÊèíÂÖ• " << success_count.load()
                      << " Êù°ËÆ∞ÂΩï" << std::endl;

            // Âº∫Âà∂Âà∑Êñ∞
            system->buffer_pool_manager->FlushAllPages();
        }

        // Phase 2: ÈáçÂêØÂπ∂È™åËØÅÂπ∂ÂèëÊï∞ÊçÆ
        {
            auto system = CreateSystem(true);

            std::vector<Tuple> result;
            assert(ExecuteSQL(system.get(),
                              "SELECT id, thread_id FROM concurrent_test;",
                              &result));

            std::cout << "‚úì Âπ∂ÂèëÊï∞ÊçÆÊÅ¢Â§çÊàêÂäüÔºåÂÖ± " << result.size() << " Êù°ËÆ∞ÂΩï"
                      << std::endl;

            // È™åËØÅÊØè‰∏™Á∫øÁ®ãÁöÑÊï∞ÊçÆ
            std::map<int, int> thread_counts;
            for (const auto& tuple : result) {
                int32_t thread_id = std::get<int32_t>(tuple.GetValue(1));
                thread_counts[thread_id]++;
            }

            for (const auto& [thread_id, count] : thread_counts) {
                std::cout << "  Á∫øÁ®ã " << thread_id << ": " << count
                          << " Êù°ËÆ∞ÂΩï" << std::endl;
            }

            std::cout << "‚úì Âπ∂ÂèëÊï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅÈÄöËøá" << std::endl;
        }

        std::cout << "‚úÖ Âπ∂ÂèëÊåÅ‰πÖÂåñÊµãËØïÈÄöËøá" << std::endl;
    }
};

int main() {
    // ËÆæÁΩÆË∞ÉËØïÁ∫ßÂà´‰ª•Ëé∑ÂæóÊõ¥Â§ö‰ø°ÊÅØ
    // setenv("SIMPLEDB_DEBUG_LEVEL", "4", 1);  // DEBUGÁ∫ßÂà´

    try {
        PersistenceRecoveryTest test;
        test.RunAllTests();
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "‚ùå ÊµãËØïÂ§±Ë¥•: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "‚ùå Êú™Áü•ÈîôËØØÂØºËá¥ÊµãËØïÂ§±Ë¥•" << std::endl;
        return 1;
    }
}