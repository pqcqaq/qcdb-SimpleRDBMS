
========== ./src/buffer/buffer_pool_manager.cpp ==========
namespace SimpleRDBMS {
BufferPoolManager::BufferPoolManager(size_t pool_size,
                                     std::unique_ptr<DiskManager> disk_manager,
                                     std::unique_ptr<Replacer> replacer)
    : pool_size_(pool_size),
      disk_manager_(std::move(disk_manager)),
      replacer_(std::move(replacer)) {
    LOG_INFO("Creating BufferPoolManager with pool_size=" << pool_size);
    LOG_DEBUG("About to allocate buffer pool array...");
    try {
        pages_ = new Page[pool_size_];
        LOG_DEBUG("Buffer pool array allocated successfully");
    } catch (const std::exception& e) {
        LOG_ERROR("Failed to allocate buffer pool: " << e.what());
        throw;
    }
    LOG_DEBUG("Initializing free list...");
    for (size_t i = 0; i < pool_size_; i++) {
        free_list_.push_back(i);
        if (i % 10 == 0) {
            LOG_TRACE("Initialized frame " << i << "/" << pool_size_);
        }
    }
    LOG_DEBUG("Free list initialized with " << free_list_.size() << " frames");
    LOG_DEBUG("BufferPoolManager created successfully");
}
BufferPoolManager::~BufferPoolManager() {
    LOG_INFO("Destroying BufferPoolManager");
    FlushAllPages();
    delete[] pages_;
}
Page* BufferPoolManager::FetchPage(page_id_t page_id) {
    std::unique_lock<std::mutex> lock(latch_);
    LOG_TRACE("FetchPage called with page_id=" << page_id);
    if (page_id == INVALID_PAGE_ID) {
        LOG_ERROR("Attempting to fetch INVALID_PAGE_ID");
        return nullptr;
    }
    auto it = page_table_.find(page_id);
    if (it != page_table_.end()) {
        size_t frame_id = it->second;
        Page* page = &pages_[frame_id];
        page->IncreasePinCount();
        replacer_->Pin(frame_id);
        LOG_TRACE("Page " << page_id << " found in buffer pool at frame "
                          << frame_id);
        return page;
    }
    size_t frame_id;
    Page* page = nullptr;
    if (!free_list_.empty()) {
        frame_id = free_list_.front();
        free_list_.pop_front();
        page = &pages_[frame_id];
        LOG_TRACE("Using free frame " << frame_id << " for page " << page_id);
    } else {
        frame_id = FindVictimPage();
        if (frame_id == static_cast<size_t>(-1)) {
            LOG_ERROR("No page can be evicted, all pages are pinned");
            return nullptr;
        }
        page = &pages_[frame_id];
        LOG_TRACE("Evicting page " << page->GetPageId() << " from frame "
                                   << frame_id);
        if (page->IsDirty() && page->GetPageId() != INVALID_PAGE_ID) {
            LOG_DEBUG("Writing dirty page " << page->GetPageId() << " to disk");
            disk_manager_->WritePage(page->GetPageId(), page->GetData());
            page->SetDirty(false);
        }
        if (page->GetPageId() != INVALID_PAGE_ID) {
            page_table_.erase(page->GetPageId());
        }
    }
    LOG_TRACE("Reading page " << page_id << " from disk (num_pages="
                              << disk_manager_->GetNumPages() << ")");
    try {
        page->SetPageId(page_id);
        page->SetDirty(false);
        page->SetLSN(INVALID_LSN);
        while (page->GetPinCount() > 0) {
            page->DecreasePinCount();
        }
        disk_manager_->ReadPage(page_id, page->GetData());
        page_table_[page_id] = frame_id;
        page->IncreasePinCount();
        replacer_->Pin(frame_id);
        return page;
    } catch (const StorageException& e) {
        LOG_DEBUG("Page " << page_id << " does not exist on disk: " << e.what()
                          << " (num_pages=" << disk_manager_->GetNumPages()
                          << ")");
        free_list_.push_back(frame_id);
        return nullptr;
    } catch (const std::exception& e) {
        LOG_ERROR("Unexpected exception when reading page "
                  << page_id << ": " << e.what()
                  << " (num_pages=" << disk_manager_->GetNumPages() << ")");
        free_list_.push_back(frame_id);
        return nullptr;
    }
}
Page* BufferPoolManager::NewPage(page_id_t* page_id) {
    std::unique_lock<std::mutex> lock(latch_);
    LOG_TRACE("NewPage called");
    if (page_id == nullptr) {
        LOG_ERROR("NewPage called with nullptr page_id");
        return nullptr;
    }
    size_t frame_id;
    Page* page = nullptr;
    if (!free_list_.empty()) {
        frame_id = free_list_.front();
        free_list_.pop_front();
        page = &pages_[frame_id];
        LOG_TRACE("Using free frame " << frame_id << " for new page");
    } else {
        frame_id = FindVictimPage();
        if (frame_id == static_cast<size_t>(-1)) {
            LOG_ERROR(
                "No page can be evicted for new page, all pages are pinned");
            *page_id = INVALID_PAGE_ID;
            return nullptr;
        }
        page = &pages_[frame_id];
        LOG_TRACE("Evicting page " << page->GetPageId() << " from frame "
                                   << frame_id << " for new page");
        if (page->IsDirty() && page->GetPageId() != INVALID_PAGE_ID) {
            LOG_DEBUG("Writing dirty page " << page->GetPageId()
                                            << " to disk before eviction");
            disk_manager_->WritePage(page->GetPageId(), page->GetData());
            page->SetDirty(false);
        }
        if (page->GetPageId() != INVALID_PAGE_ID) {
            page_table_.erase(page->GetPageId());
        }
    }
    *page_id = disk_manager_->AllocatePage();
    LOG_DEBUG("Allocated new page with id=" << *page_id);
    std::memset(page->GetData(), 0, PAGE_SIZE);
    page->SetPageId(*page_id);
    page->SetDirty(true);
    page->SetLSN(INVALID_LSN);
    while (page->GetPinCount() > 0) {
        page->DecreasePinCount();
    }
    page_table_[*page_id] = frame_id;
    page->IncreasePinCount();
    replacer_->Pin(frame_id);
    LOG_TRACE("NewPage returning page " << *page_id << " in frame "
                                        << frame_id);
    return page;
}
bool BufferPoolManager::DeletePage(page_id_t page_id) {
    std::unique_lock<std::mutex> lock(latch_);
    LOG_TRACE("DeletePage called with page_id=" << page_id);
    auto it = page_table_.find(page_id);
    if (it == page_table_.end()) {
        disk_manager_->DeallocatePage(page_id);
        return true;
    }
    size_t frame_id = it->second;
    Page* page = &pages_[frame_id];
    if (page->GetPinCount() > 0) {
        LOG_DEBUG("Force unpinning page " << page_id
                                          << " before deletion (pin_count="
                                          << page->GetPinCount() << ")");
        while (page->GetPinCount() > 0) {
            page->DecreasePinCount();
        }
    }
    page_table_.erase(page_id);
    replacer_->Pin(frame_id);
    free_list_.push_back(frame_id);
    page->SetPageId(INVALID_PAGE_ID);
    page->SetDirty(false);
    page->SetLSN(INVALID_LSN);
    disk_manager_->DeallocatePage(page_id);
    LOG_TRACE("Successfully deleted page " << page_id);
    return true;
}
bool BufferPoolManager::UnpinPage(page_id_t page_id, bool is_dirty) {
    std::unique_lock<std::mutex> lock(latch_);
    LOG_TRACE("UnpinPage called with page_id=" << page_id
                                               << ", is_dirty=" << is_dirty);
    auto it = page_table_.find(page_id);
    if (it == page_table_.end()) {
        LOG_DEBUG("UnpinPage: page " << page_id << " not in buffer pool");
        return false;
    }
    size_t frame_id = it->second;
    Page* page = &pages_[frame_id];
    if (page->GetPinCount() <= 0) {
        LOG_DEBUG("UnpinPage: page " << page_id
                                     << " already unpinned (pin_count="
                                     << page->GetPinCount() << ")");
        return true;
    }
    page->DecreasePinCount();
    if (is_dirty) {
        page->SetDirty(true);
    }
    if (page->GetPinCount() == 0) {
        replacer_->Unpin(frame_id);
        LOG_TRACE("UnpinPage: page " << page_id
                                     << " unpinned and added to replacer");
    }
    LOG_TRACE("UnpinPage: page " << page_id
                                 << " pin_count=" << page->GetPinCount());
    return true;
}
bool BufferPoolManager::FlushPage(page_id_t page_id) {
    std::unique_lock<std::mutex> lock(latch_);
    LOG_DEBUG("FlushPage called with page_id=" << page_id);
    auto it = page_table_.find(page_id);
    if (it == page_table_.end()) {
        LOG_DEBUG("FlushPage: page " << page_id << " not in buffer pool");
        try {
            char temp_buffer[PAGE_SIZE];
            disk_manager_->ReadPage(page_id, temp_buffer);
            LOG_DEBUG("FlushPage: page "
                      << page_id << " exists on disk but not in buffer pool");
            return true;
        } catch (const StorageException&) {
            LOG_DEBUG("FlushPage: page "
                      << page_id
                      << " does not exist on disk or in buffer pool");
            return false;
        }
    }
    size_t frame_id = it->second;
    Page* page = &pages_[frame_id];
    LOG_DEBUG("Force flushing page " << page_id << " to disk");
    try {
        disk_manager_->WritePage(page_id, page->GetData());
        page->SetDirty(false);
        LOG_DEBUG("Page " << page_id << " successfully written to disk");
        return true;
    } catch (const std::exception& e) {
        LOG_ERROR("Failed to flush page " << page_id
                                          << " to disk: " << e.what());
        return false;
    }
}
void BufferPoolManager::FlushAllPages() {
    std::unique_lock<std::mutex> lock(latch_);
    LOG_INFO("Flushing all pages");
    int flushed_count = 0;
    int error_count = 0;
    for (size_t i = 0; i < pool_size_; i++) {
        Page* page = &pages_[i];
        if (page->GetPageId() != INVALID_PAGE_ID && page->IsDirty()) {
            try {
                LOG_DEBUG("Flushing page " << page->GetPageId());
                disk_manager_->WritePage(page->GetPageId(), page->GetData());
                page->SetDirty(false);
                flushed_count++;
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to flush page " << page->GetPageId() << ": "
                                                  << e.what());
                error_count++;
            }
        }
    }
    LOG_INFO("FlushAllPages completed: flushed " << flushed_count << " pages, "
                                                 << error_count << " errors");
}
size_t BufferPoolManager::FindVictimPage() {
    size_t victim_frame_id;
    if (!replacer_->Victim(&victim_frame_id)) {
        return static_cast<size_t>(-1);
    }
    return victim_frame_id;
}
void BufferPoolManager::UpdatePage(Page* page, page_id_t page_id) {
    page->SetPageId(page_id);
    page->SetDirty(false);
    page->SetLSN(INVALID_LSN);
    while (page->GetPinCount() > 0) {
        page->DecreasePinCount();
    }
}
Page* BufferPoolManager::GetSpecificPage(page_id_t page_id) {
    std::unique_lock<std::mutex> lock(latch_);
    auto it = page_table_.find(page_id);
    if (it != page_table_.end()) {
        size_t frame_id = it->second;
        Page* page = &pages_[frame_id];
        page->IncreasePinCount();
        replacer_->Pin(frame_id);
        return page;
    }
    size_t frame_id;
    Page* page = nullptr;
    if (!free_list_.empty()) {
        frame_id = free_list_.front();
        free_list_.pop_front();
        page = &pages_[frame_id];
    } else {
        frame_id = FindVictimPage();
        if (frame_id == static_cast<size_t>(-1)) {
            return nullptr;
        }
        page = &pages_[frame_id];
        if (page->IsDirty() && page->GetPageId() != INVALID_PAGE_ID) {
            disk_manager_->WritePage(page->GetPageId(), page->GetData());
            page->SetDirty(false);
        }
        if (page->GetPageId() != INVALID_PAGE_ID) {
            page_table_.erase(page->GetPageId());
        }
    }
    try {
        page->SetPageId(page_id);
        page->SetDirty(false);
        page->SetLSN(INVALID_LSN);
        while (page->GetPinCount() > 0) {
            page->DecreasePinCount();
        }
        if (page_id < disk_manager_->GetNumPages()) {
            disk_manager_->ReadPage(page_id, page->GetData());
        } else {
            std::memset(page->GetData(), 0, PAGE_SIZE);
            page->SetDirty(true);
        }
        page_table_[page_id] = frame_id;
        page->IncreasePinCount();
        replacer_->Pin(frame_id);
        return page;
    } catch (const std::exception& e) {
        LOG_ERROR("Failed to get specific page " << page_id << ": "
                                                 << e.what());
        free_list_.push_back(frame_id);
        return nullptr;
    }
}
}


========== ./src/buffer/lru_replacer.cpp ==========
namespace SimpleRDBMS {
LRUReplacer::LRUReplacer(size_t num_pages) : num_pages_(num_pages) {
}
LRUReplacer::~LRUReplacer() {
}
void LRUReplacer::Pin(size_t frame_id) {
    std::unique_lock<std::mutex> lock(latch_);
    auto it = lru_map_.find(frame_id);
    if (it == lru_map_.end()) {
        return;
    }
    lru_list_.erase(it->second);
    lru_map_.erase(frame_id);
}
void LRUReplacer::Unpin(size_t frame_id) {
    std::unique_lock<std::mutex> lock(latch_);
    auto it = lru_map_.find(frame_id);
    if (it != lru_map_.end()) {
        return;
    }
    if (lru_list_.size() >= num_pages_) {
        return;
    }
    lru_list_.push_back(frame_id);
    auto list_it = lru_list_.end();
    --list_it;
    lru_map_[frame_id] = list_it;
}
bool LRUReplacer::Victim(size_t* frame_id) {
    std::unique_lock<std::mutex> lock(latch_);
    if (lru_list_.empty()) {
        return false;
    }
    *frame_id = lru_list_.front();
    lru_list_.pop_front();
    lru_map_.erase(*frame_id);
    return true;
}
size_t LRUReplacer::Size() const {
    std::unique_lock<std::mutex> lock(latch_);
    return lru_list_.size();
}
}


========== ./src/catalog/catalog.cpp ==========
namespace SimpleRDBMS {
Catalog::Catalog(BufferPoolManager* buffer_pool_manager,
                 LogManager* log_manager)
    : buffer_pool_manager_(buffer_pool_manager),
      log_manager_(log_manager),
      next_table_oid_(1),
      next_index_oid_(1),
      save_in_progress_(false) {
    LOG_DEBUG("Catalog: Initializing catalog");
    try {
        LoadCatalogFromDisk();
        LOG_DEBUG("Catalog: Successfully loaded catalog from disk");
    } catch (const std::exception& e) {
        LOG_WARN("Catalog: Failed to load catalog from disk: " << e.what());
        LOG_DEBUG("Catalog: Starting with empty catalog");
    }
    LOG_DEBUG("Catalog: Catalog initialization completed");
}
Catalog::~Catalog() {
    if (buffer_pool_manager_) {
        try {
            SaveCatalogToDisk();
        } catch (const std::exception& e) {
            LOG_WARN(
                "Catalog::~Catalog: Failed to save catalog during destruction: "
                << e.what());
        } catch (...) {
            LOG_WARN(
                "Catalog::~Catalog: Unknown error saving catalog during "
                "destruction");
        }
    }
    LOG_DEBUG("Catalog destructor completed");
}
bool Catalog::CreateTable(const std::string& table_name, const Schema& schema) {
    LOG_DEBUG("CreateTable: Starting to create table " << table_name);
    if (tables_.find(table_name) != tables_.end()) {
        LOG_WARN("CreateTable: Table " << table_name << " already exists");
        return false;
    }
    LOG_DEBUG("CreateTable: Creating table info for " << table_name);
    auto table_info = std::make_unique<TableInfo>();
    table_info->table_name = table_name;
    table_info->schema = std::make_unique<Schema>(schema);
    table_info->table_oid = next_table_oid_++;
    LOG_DEBUG("CreateTable: Allocating first page for table " << table_name);
    page_id_t first_page_id;
    Page* first_page = buffer_pool_manager_->NewPage(&first_page_id);
    if (first_page == nullptr) {
        LOG_ERROR("CreateTable: Failed to allocate first page for table "
                  << table_name);
        return false;
    }
    LOG_DEBUG("CreateTable: Allocated first page "
              << first_page_id << " for table " << table_name);
    first_page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(first_page);
    table_page->Init(first_page_id, INVALID_PAGE_ID);
    first_page->WUnlatch();
    table_info->first_page_id = first_page_id;
    LOG_DEBUG("CreateTable: Creating TableHeap for table " << table_name);
    table_info->table_heap = std::make_unique<TableHeap>(
        buffer_pool_manager_, table_info->schema.get(), first_page_id);
    if (log_manager_) {
        table_info->table_heap->SetLogManager(log_manager_);
    }
    buffer_pool_manager_->UnpinPage(first_page_id, true);
    LOG_DEBUG("CreateTable: Adding table to catalog maps");
    oid_t table_oid = table_info->table_oid;
    tables_[table_name] = std::move(table_info);
    table_oid_map_[table_oid] = table_name;
    LOG_DEBUG("CreateTable: Saving catalog to disk");
    try {
        SaveCatalogToDisk();
        LOG_DEBUG("CreateTable: Successfully saved catalog to disk");
    } catch (const std::exception& e) {
        LOG_ERROR("CreateTable: Failed to save catalog to disk: " << e.what());
        tables_.erase(table_name);
        table_oid_map_.erase(table_oid);
        return false;
    }
    LOG_DEBUG("CreateTable: Table " << table_name << " created successfully");
    return true;
}
bool Catalog::DropTable(const std::string& table_name) {
    auto it = tables_.find(table_name);
    if (it == tables_.end()) {
        return false;
    }
    oid_t table_oid = it->second->table_oid;
    table_oid_map_.erase(table_oid);
    tables_.erase(it);
    SaveCatalogToDisk();
    return true;
}
TableInfo* Catalog::GetTable(const std::string& table_name) {
    auto it = tables_.find(table_name);
    if (it == tables_.end()) {
        return nullptr;
    }
    return it->second.get();
}
TableInfo* Catalog::GetTable(oid_t table_oid) {
    auto it = table_oid_map_.find(table_oid);
    if (it == table_oid_map_.end()) {
        return nullptr;
    }
    return GetTable(it->second);
}
bool Catalog::CreateIndex(const std::string& index_name,
                          const std::string& table_name,
                          const std::vector<std::string>& key_columns) {
    if (indexes_.find(index_name) != indexes_.end()) {
        return false;
    }
    if (tables_.find(table_name) == tables_.end()) {
        return false;
    }
    auto index_info = std::make_unique<IndexInfo>();
    index_info->index_name = index_name;
    index_info->table_name = table_name;
    index_info->key_columns = key_columns;
    index_info->index_oid = next_index_oid_++;
    oid_t index_oid = index_info->index_oid;
    indexes_[index_name] = std::move(index_info);
    index_oid_map_[index_oid] = index_name;
    LOG_DEBUG("CreateIndex: Index " << index_name << " created in memory");
    return true;
}
bool Catalog::DropIndex(const std::string& index_name) {
    auto it = indexes_.find(index_name);
    if (it == indexes_.end()) {
        return false;
    }
    oid_t index_oid = it->second->index_oid;
    index_oid_map_.erase(index_oid);
    indexes_.erase(it);
    SaveCatalogToDisk();
    return true;
}
IndexInfo* Catalog::GetIndex(const std::string& index_name) {
    auto it = indexes_.find(index_name);
    if (it == indexes_.end()) {
        return nullptr;
    }
    return it->second.get();
}
IndexInfo* Catalog::GetIndex(oid_t index_oid) {
    auto it = index_oid_map_.find(index_oid);
    if (it == index_oid_map_.end()) {
        return nullptr;
    }
    return GetIndex(it->second);
}
std::vector<IndexInfo*> Catalog::GetTableIndexes(
    const std::string& table_name) {
    std::vector<IndexInfo*> result;
    for (const auto& [index_name, index_info] : indexes_) {
        if (index_info->table_name == table_name) {
            result.push_back(index_info.get());
        }
    }
    return result;
}
void Catalog::LoadCatalogFromDisk() {
    LOG_DEBUG("LoadCatalogFromDisk: Starting catalog load");
    if (buffer_pool_manager_ == nullptr) {
        LOG_ERROR("LoadCatalogFromDisk: BufferPoolManager is null");
        return;
    }
    LOG_DEBUG("LoadCatalogFromDisk: Attempting to fetch catalog page 0");
    Page* catalog_page = nullptr;
    try {
        catalog_page = buffer_pool_manager_->GetSpecificPage(0);
    } catch (const std::exception& e) {
        LOG_WARN(
            "LoadCatalogFromDisk: Exception when getting page 0: " << e.what());
        return;
    }
    if (catalog_page == nullptr) {
        LOG_DEBUG(
            "LoadCatalogFromDisk: Page 0 does not exist, assuming new "
            "database");
        return;
    }
    LOG_DEBUG("LoadCatalogFromDisk: Successfully got catalog page 0");
    const char* data = catalog_page->GetData();
    size_t offset = 0;
    uint32_t magic_number;
    std::memcpy(&magic_number, data + offset, sizeof(uint32_t));
    offset += sizeof(uint32_t);
    LOG_DEBUG("LoadCatalogFromDisk: Read magic number: 0x"
              << std::hex << magic_number << std::dec
              << " (expected: 0x12345678)");
    if (magic_number != 0x12345678) {
        LOG_WARN(
            "LoadCatalogFromDisk: Invalid magic number, not a valid catalog "
            "page");
        buffer_pool_manager_->UnpinPage(0, false);
        return;
    }
    LOG_DEBUG(
        "LoadCatalogFromDisk: Valid catalog page found, loading metadata");
    std::memcpy(&next_table_oid_, data + offset, sizeof(oid_t));
    offset += sizeof(oid_t);
    std::memcpy(&next_index_oid_, data + offset, sizeof(oid_t));
    offset += sizeof(oid_t);
    LOG_DEBUG("LoadCatalogFromDisk: Next table OID: "
              << next_table_oid_ << ", Next index OID: " << next_index_oid_);
    uint32_t table_count;
    std::memcpy(&table_count, data + offset, sizeof(uint32_t));
    offset += sizeof(uint32_t);
    LOG_DEBUG("LoadCatalogFromDisk: Loading " << table_count << " tables");
    for (uint32_t i = 0; i < table_count; ++i) {
        LOG_DEBUG("LoadCatalogFromDisk: Loading table " << i);
        auto table_info = std::make_unique<TableInfo>();
        if (offset + sizeof(oid_t) + sizeof(page_id_t) + sizeof(uint32_t) >
            PAGE_SIZE) {
            LOG_ERROR("LoadCatalogFromDisk: Not enough data to read table "
                      << i);
            break;
        }
        std::memcpy(&table_info->table_oid, data + offset, sizeof(oid_t));
        offset += sizeof(oid_t);
        std::memcpy(&table_info->first_page_id, data + offset,
                    sizeof(page_id_t));
        offset += sizeof(page_id_t);
        uint32_t name_len;
        std::memcpy(&name_len, data + offset, sizeof(uint32_t));
        offset += sizeof(uint32_t);
        if (name_len > 256 || offset + name_len > PAGE_SIZE) {
            LOG_ERROR(
                "LoadCatalogFromDisk: Invalid table name length: " << name_len);
            break;
        }
        table_info->table_name = std::string(data + offset, name_len);
        offset += name_len;
        LOG_DEBUG("LoadCatalogFromDisk: Loading table '"
                  << table_info->table_name << "' with OID "
                  << table_info->table_oid << " and first page "
                  << table_info->first_page_id);
        try {
            table_info->schema = DeserializeSchema(data, offset);
        } catch (const std::exception& e) {
            LOG_ERROR(
                "LoadCatalogFromDisk: Failed to deserialize schema for table "
                << table_info->table_name << ": " << e.what());
            break;
        }
        try {
            table_info->table_heap = std::make_unique<TableHeap>(
                buffer_pool_manager_, table_info->schema.get(),
                table_info->first_page_id);
            if (log_manager_) {
                table_info->table_heap->SetLogManager(log_manager_);
            }
        } catch (const std::exception& e) {
            LOG_ERROR(
                "LoadCatalogFromDisk: Failed to create TableHeap for table "
                << table_info->table_name << ": " << e.what());
            break;
        }
        std::string table_name = table_info->table_name;
        oid_t table_oid = table_info->table_oid;
        tables_[table_name] = std::move(table_info);
        table_oid_map_[table_oid] = table_name;
        LOG_DEBUG("LoadCatalogFromDisk: Successfully loaded table "
                  << table_name);
    }
    if (offset + sizeof(uint32_t) <= PAGE_SIZE) {
        uint32_t index_count;
        std::memcpy(&index_count, data + offset, sizeof(uint32_t));
        offset += sizeof(uint32_t);
        LOG_DEBUG("LoadCatalogFromDisk: Loading " << index_count << " indexes");
        for (uint32_t i = 0; i < index_count; ++i) {
            LOG_DEBUG("LoadCatalogFromDisk: Loading index " << i);
            auto index_info = std::make_unique<IndexInfo>();
            if (offset + sizeof(oid_t) + sizeof(uint32_t) > PAGE_SIZE) {
                LOG_ERROR("LoadCatalogFromDisk: Not enough data to read index "
                          << i);
                break;
            }
            std::memcpy(&index_info->index_oid, data + offset, sizeof(oid_t));
            offset += sizeof(oid_t);
            uint32_t index_name_len;
            std::memcpy(&index_name_len, data + offset, sizeof(uint32_t));
            offset += sizeof(uint32_t);
            if (index_name_len > 256 || offset + index_name_len > PAGE_SIZE) {
                LOG_ERROR("LoadCatalogFromDisk: Invalid index name length: "
                          << index_name_len);
                break;
            }
            index_info->index_name = std::string(data + offset, index_name_len);
            offset += index_name_len;
            uint32_t table_name_len;
            std::memcpy(&table_name_len, data + offset, sizeof(uint32_t));
            offset += sizeof(uint32_t);
            if (table_name_len > 256 || offset + table_name_len > PAGE_SIZE) {
                LOG_ERROR("LoadCatalogFromDisk: Invalid table name length: "
                          << table_name_len);
                break;
            }
            index_info->table_name = std::string(data + offset, table_name_len);
            offset += table_name_len;
            uint32_t key_column_count;
            std::memcpy(&key_column_count, data + offset, sizeof(uint32_t));
            offset += sizeof(uint32_t);
            for (uint32_t j = 0; j < key_column_count; ++j) {
                uint32_t column_len;
                std::memcpy(&column_len, data + offset, sizeof(uint32_t));
                offset += sizeof(uint32_t);
                if (column_len > 256 || offset + column_len > PAGE_SIZE) {
                    LOG_ERROR(
                        "LoadCatalogFromDisk: Invalid column name length: "
                        << column_len);
                    break;
                }
                std::string column_name =
                    std::string(data + offset, column_len);
                offset += column_len;
                index_info->key_columns.push_back(column_name);
            }
            std::string index_name = index_info->index_name;
            oid_t index_oid = index_info->index_oid;
            indexes_[index_name] = std::move(index_info);
            index_oid_map_[index_oid] = index_name;
            LOG_DEBUG("LoadCatalogFromDisk: Successfully loaded index "
                      << index_name);
        }
    } else {
        LOG_DEBUG("LoadCatalogFromDisk: No space left to read indexes");
    }
    buffer_pool_manager_->UnpinPage(0, false);
    LOG_DEBUG(
        "LoadCatalogFromDisk: Catalog load completed successfully, loaded "
        << tables_.size() << " tables and " << indexes_.size() << " indexes");
}
void Catalog::SaveCatalogToDisk() {
    std::lock_guard<std::mutex> save_lock(save_mutex_);
    if (save_in_progress_.load()) {
        LOG_DEBUG("SaveCatalogToDisk: Save already in progress, skipping");
        return;
    }
    if (!buffer_pool_manager_) {
        LOG_DEBUG(
            "SaveCatalogToDisk: BufferPoolManager is null, skipping save");
        return;
    }
    save_in_progress_.store(true);
    try {
        LOG_DEBUG("SaveCatalogToDisk: Starting catalog save");
        const page_id_t CATALOG_PAGE_ID = 0;
        Page* catalog_page =
            buffer_pool_manager_->GetSpecificPage(CATALOG_PAGE_ID);
        if (catalog_page == nullptr) {
            LOG_ERROR("SaveCatalogToDisk: Failed to get catalog page 0");
            save_in_progress_.store(false);
            return;
        }
        if (catalog_page->GetPageId() != CATALOG_PAGE_ID) {
            LOG_ERROR("SaveCatalogToDisk: Page ID mismatch, expected 0 but got "
                      << catalog_page->GetPageId());
            buffer_pool_manager_->UnpinPage(catalog_page->GetPageId(), false);
            save_in_progress_.store(false);
            return;
        }
        char* data = catalog_page->GetData();
        std::memset(data, 0, PAGE_SIZE);
        size_t offset = 0;
        LOG_DEBUG("SaveCatalogToDisk: Writing catalog data");
        uint32_t magic_number = 0x12345678;
        std::memcpy(data + offset, &magic_number, sizeof(uint32_t));
        offset += sizeof(uint32_t);
        LOG_DEBUG("SaveCatalogToDisk: Written magic number 0x"
                  << std::hex << magic_number << std::dec);
        std::memcpy(data + offset, &next_table_oid_, sizeof(oid_t));
        offset += sizeof(oid_t);
        std::memcpy(data + offset, &next_index_oid_, sizeof(oid_t));
        offset += sizeof(oid_t);
        uint32_t table_count = static_cast<uint32_t>(tables_.size());
        std::memcpy(data + offset, &table_count, sizeof(uint32_t));
        offset += sizeof(uint32_t);
        LOG_DEBUG("SaveCatalogToDisk: Writing " << table_count << " tables");
        for (const auto& [table_name, table_info] : tables_) {
            LOG_DEBUG("SaveCatalogToDisk: Writing table " << table_name);
            size_t required_space = sizeof(oid_t) + sizeof(page_id_t) +
                                    sizeof(uint32_t) + table_name.length() +
                                    200;
            if (offset + required_space > PAGE_SIZE) {
                LOG_ERROR(
                    "SaveCatalogToDisk: Not enough space in catalog page for "
                    "table "
                    << table_name);
                break;
            }
            std::memcpy(data + offset, &table_info->table_oid, sizeof(oid_t));
            offset += sizeof(oid_t);
            std::memcpy(data + offset, &table_info->first_page_id,
                        sizeof(page_id_t));
            offset += sizeof(page_id_t);
            uint32_t name_len = static_cast<uint32_t>(table_name.length());
            std::memcpy(data + offset, &name_len, sizeof(uint32_t));
            offset += sizeof(uint32_t);
            std::memcpy(data + offset, table_name.c_str(), name_len);
            offset += name_len;
            try {
                SerializeSchema(*table_info->schema, data, offset);
                LOG_DEBUG(
                    "SaveCatalogToDisk: Successfully serialized schema for "
                    "table "
                    << table_name);
            } catch (const std::exception& e) {
                LOG_ERROR(
                    "SaveCatalogToDisk: Failed to serialize schema for table "
                    << table_name << ": " << e.what());
                break;
            }
        }
        uint32_t index_count = static_cast<uint32_t>(indexes_.size());
        if (offset + sizeof(uint32_t) <= PAGE_SIZE) {
            std::memcpy(data + offset, &index_count, sizeof(uint32_t));
            offset += sizeof(uint32_t);
            LOG_DEBUG("SaveCatalogToDisk: Writing " << index_count
                                                    << " indexes");
            for (const auto& [index_name, index_info] : indexes_) {
                LOG_DEBUG("SaveCatalogToDisk: Writing index " << index_name);
                size_t required_space = sizeof(oid_t) + sizeof(uint32_t) +
                                        index_name.length() + sizeof(uint32_t) +
                                        index_info->table_name.length() +
                                        sizeof(uint32_t);
                for (const auto& column : index_info->key_columns) {
                    required_space += sizeof(uint32_t) + column.length();
                }
                if (offset + required_space > PAGE_SIZE) {
                    LOG_ERROR("SaveCatalogToDisk: Not enough space for index "
                              << index_name);
                    break;
                }
                std::memcpy(data + offset, &index_info->index_oid,
                            sizeof(oid_t));
                offset += sizeof(oid_t);
                uint32_t index_name_len =
                    static_cast<uint32_t>(index_name.length());
                std::memcpy(data + offset, &index_name_len, sizeof(uint32_t));
                offset += sizeof(uint32_t);
                std::memcpy(data + offset, index_name.c_str(), index_name_len);
                offset += index_name_len;
                uint32_t table_name_len =
                    static_cast<uint32_t>(index_info->table_name.length());
                std::memcpy(data + offset, &table_name_len, sizeof(uint32_t));
                offset += sizeof(uint32_t);
                std::memcpy(data + offset, index_info->table_name.c_str(),
                            table_name_len);
                offset += table_name_len;
                uint32_t key_column_count =
                    static_cast<uint32_t>(index_info->key_columns.size());
                std::memcpy(data + offset, &key_column_count, sizeof(uint32_t));
                offset += sizeof(uint32_t);
                for (const auto& column : index_info->key_columns) {
                    uint32_t column_len =
                        static_cast<uint32_t>(column.length());
                    std::memcpy(data + offset, &column_len, sizeof(uint32_t));
                    offset += sizeof(uint32_t);
                    std::memcpy(data + offset, column.c_str(), column_len);
                    offset += column_len;
                }
                LOG_DEBUG("SaveCatalogToDisk: Successfully wrote index "
                          << index_name);
            }
        } else {
            LOG_WARN("SaveCatalogToDisk: No space left for indexes");
            uint32_t zero_count = 0;
            if (offset + sizeof(uint32_t) <= PAGE_SIZE) {
                std::memcpy(data + offset, &zero_count, sizeof(uint32_t));
                offset += sizeof(uint32_t);
            }
        }
        LOG_DEBUG("SaveCatalogToDisk: Final offset: " << offset << " bytes");
        catalog_page->SetDirty(true);
        buffer_pool_manager_->UnpinPage(CATALOG_PAGE_ID, true);
        bool flush_success = buffer_pool_manager_->FlushPage(CATALOG_PAGE_ID);
        LOG_DEBUG("SaveCatalogToDisk: Force flush result: "
                  << (flush_success ? "success" : "failed"));
        LOG_DEBUG("SaveCatalogToDisk: Catalog save completed successfully");
    } catch (const std::exception& e) {
        LOG_ERROR("SaveCatalogToDisk: Exception during save: " << e.what());
    }
    save_in_progress_.store(false);
}
void Catalog::SerializeSchema(const Schema& schema, char* buffer,
                              size_t& offset) {
    LOG_DEBUG("SerializeSchema: Starting schema serialization at offset "
              << offset);
    size_t estimated_size = sizeof(uint32_t);
    for (size_t i = 0; i < schema.GetColumnCount(); ++i) {
        const Column& column = schema.GetColumn(i);
        estimated_size += sizeof(uint32_t) + column.name.length();
        estimated_size += sizeof(TypeId) + sizeof(size_t) + sizeof(bool) +
                          sizeof(bool);
    }
    if (offset + estimated_size > PAGE_SIZE) {
        throw Exception("Not enough space to serialize schema");
    }
    uint32_t column_count = static_cast<uint32_t>(schema.GetColumnCount());
    std::memcpy(buffer + offset, &column_count, sizeof(uint32_t));
    offset += sizeof(uint32_t);
    LOG_DEBUG("SerializeSchema: Serializing " << column_count << " columns");
    for (size_t i = 0; i < schema.GetColumnCount(); ++i) {
        const Column& column = schema.GetColumn(i);
        LOG_DEBUG("SerializeSchema: Serializing column " << i << ": "
                                                         << column.name);
        size_t required_space = sizeof(uint32_t) + column.name.length() +
                                sizeof(TypeId) + sizeof(size_t) + sizeof(bool) +
                                sizeof(bool);
        if (offset + required_space > PAGE_SIZE) {
            throw Exception("Not enough space to serialize column " +
                            column.name);
        }
        uint32_t name_len = static_cast<uint32_t>(column.name.length());
        std::memcpy(buffer + offset, &name_len, sizeof(uint32_t));
        offset += sizeof(uint32_t);
        std::memcpy(buffer + offset, column.name.c_str(), name_len);
        offset += name_len;
        std::memcpy(buffer + offset, &column.type, sizeof(TypeId));
        offset += sizeof(TypeId);
        std::memcpy(buffer + offset, &column.size, sizeof(size_t));
        offset += sizeof(size_t);
        std::memcpy(buffer + offset, &column.nullable, sizeof(bool));
        offset += sizeof(bool);
        std::memcpy(buffer + offset, &column.is_primary_key, sizeof(bool));
        offset += sizeof(bool);
    }
    LOG_DEBUG("SerializeSchema: Schema serialization completed, final offset: "
              << offset);
}
std::unique_ptr<Schema> Catalog::DeserializeSchema(const char* buffer,
                                                   size_t& offset) {
    uint32_t column_count;
    std::memcpy(&column_count, buffer + offset, sizeof(uint32_t));
    offset += sizeof(uint32_t);
    std::vector<Column> columns;
    columns.reserve(column_count);
    for (uint32_t i = 0; i < column_count; ++i) {
        Column column;
        uint32_t name_len;
        std::memcpy(&name_len, buffer + offset, sizeof(uint32_t));
        offset += sizeof(uint32_t);
        column.name = std::string(buffer + offset, name_len);
        offset += name_len;
        std::memcpy(&column.type, buffer + offset, sizeof(TypeId));
        offset += sizeof(TypeId);
        std::memcpy(&column.size, buffer + offset, sizeof(size_t));
        offset += sizeof(size_t);
        std::memcpy(&column.nullable, buffer + offset, sizeof(bool));
        offset += sizeof(bool);
        std::memcpy(&column.is_primary_key, buffer + offset, sizeof(bool));
        offset += sizeof(bool);
        columns.push_back(column);
    }
    return std::make_unique<Schema>(columns);
}
void Catalog::DebugPrintTables() const {
    LOG_DEBUG("=== Catalog Debug: All Tables ===");
    LOG_DEBUG("Total tables: " << tables_.size());
    for (const auto& [table_name, table_info] : tables_) {
        LOG_DEBUG("Table: " << table_name << ", OID: " << table_info->table_oid
                            << ", FirstPage: " << table_info->first_page_id
                            << ", Columns: "
                            << table_info->schema->GetColumnCount());
    }
    LOG_DEBUG("=== End Catalog Debug ===");
}
std::vector<std::string> Catalog::GetAllTableNames() const {
    std::vector<std::string> table_names;
    table_names.reserve(tables_.size());
    for (const auto& [name, info] : tables_) {
        table_names.push_back(name);
    }
    std::sort(table_names.begin(), table_names.end());
    return table_names;
}
}


========== ./src/catalog/schema.cpp ==========
namespace SimpleRDBMS {
Schema::Schema(const std::vector<Column>& columns) : columns_(columns) {
    for (size_t i = 0; i < columns_.size(); i++) {
        column_indices_[columns_[i].name] = i;
    }
}
const Column& Schema::GetColumn(const std::string& name) const {
    auto it = column_indices_.find(name);
    if (it == column_indices_.end()) {
        throw Exception("Column not found: " + name);
    }
    return columns_[it->second];
}
size_t Schema::GetColumnIdx(const std::string& name) const {
    auto it = column_indices_.find(name);
    if (it == column_indices_.end()) {
        throw Exception("Column not found: " + name);
    }
    return it->second;
}
size_t Schema::GetTupleSize() const {
    size_t size = 0;
    for (const auto& column : columns_) {
        switch (column.type) {
            case TypeId::BOOLEAN:
                size += sizeof(bool);
                break;
            case TypeId::TINYINT:
                size += sizeof(int8_t);
                break;
            case TypeId::SMALLINT:
                size += sizeof(int16_t);
                break;
            case TypeId::INTEGER:
                size += sizeof(int32_t);
                break;
            case TypeId::BIGINT:
                size += sizeof(int64_t);
                break;
            case TypeId::FLOAT:
                size += sizeof(float);
                break;
            case TypeId::DOUBLE:
                size += sizeof(double);
                break;
            case TypeId::VARCHAR:
                size += column.size;
                break;
            default:
                LOG_WARN(
                    "Unknown column type: " << static_cast<int>(column.type));
                break;
        }
    }
    return size;
}
bool Schema::HasColumn(const std::string& name) const {
    return column_indices_.find(name) != column_indices_.end();
}
}


========== ./src/catalog/table_manager.cpp ==========
namespace SimpleRDBMS {
TableManager::TableManager(BufferPoolManager* buffer_pool_manager,
                           Catalog* catalog)
    : buffer_pool_manager_(buffer_pool_manager), catalog_(catalog) {
    index_manager_ =
        std::make_unique<IndexManager>(buffer_pool_manager, catalog);
    RebuildAllIndexes();
}
TableManager::~TableManager() {
    if (index_manager_) {
        LOG_DEBUG("TableManager::~TableManager: Destroying IndexManager");
        index_manager_.reset();
    }
    LOG_DEBUG("TableManager::~TableManager: TableManager destroyed");
}
void TableManager::RebuildAllIndexes() {
    LOG_DEBUG("TableManager::RebuildAllIndexes: Starting index rebuild");
    std::vector<std::string> table_names = catalog_->GetAllTableNames();
    for (const auto& table_name : table_names) {
        std::vector<IndexInfo*> indexes = catalog_->GetTableIndexes(table_name);
        for (auto* index_info : indexes) {
            LOG_DEBUG("TableManager::RebuildAllIndexes: Rebuilding index "
                      << index_info->index_name);
            TableInfo* table_info = catalog_->GetTable(table_name);
            if (!table_info) {
                LOG_ERROR("TableManager::RebuildAllIndexes: Table "
                          << table_name << " not found");
                continue;
            }
            bool success = index_manager_->CreateIndex(
                index_info->index_name, table_name, index_info->key_columns,
                table_info->schema.get());
            if (!success) {
                LOG_ERROR(
                    "TableManager::RebuildAllIndexes: Failed to rebuild index "
                    << index_info->index_name);
                continue;
            }
            PopulateIndexWithExistingData(index_info->index_name, table_info,
                                          index_info->key_columns);
        }
    }
    LOG_DEBUG("TableManager::RebuildAllIndexes: Index rebuild completed");
}
bool TableManager::CreateIndex(const std::string& index_name,
                               const std::string& table_name,
                               const std::vector<std::string>& key_columns) {
    LOG_DEBUG("TableManager::CreateIndex: Creating index "
              << index_name << " on table " << table_name);
    if (catalog_->GetIndex(index_name) != nullptr) {
        LOG_WARN("TableManager::CreateIndex: Index " << index_name
                                                     << " already exists");
        return false;
    }
    TableInfo* table_info = catalog_->GetTable(table_name);
    if (table_info == nullptr) {
        LOG_ERROR("TableManager::CreateIndex: Table " << table_name
                                                      << " not found");
        return false;
    }
    if (key_columns.empty()) {
        LOG_ERROR("TableManager::CreateIndex: Key columns cannot be empty");
        return false;
    }
    const Schema* schema = table_info->schema.get();
    for (const auto& key_column : key_columns) {
        if (!schema->HasColumn(key_column)) {
            LOG_ERROR("TableManager::CreateIndex: Column "
                      << key_column << " not found in table " << table_name);
            return false;
        }
    }
    std::unordered_set<std::string> key_column_set(key_columns.begin(),
                                                   key_columns.end());
    if (key_column_set.size() != key_columns.size()) {
        LOG_ERROR("TableManager::CreateIndex: Duplicate columns in key");
        return false;
    }
    bool catalog_success =
        catalog_->CreateIndex(index_name, table_name, key_columns);
    if (!catalog_success) {
        LOG_ERROR(
            "TableManager::CreateIndex: Failed to create index in catalog");
        return false;
    }
    bool index_success = index_manager_->CreateIndex(index_name, table_name,
                                                     key_columns, schema);
    if (!index_success) {
        LOG_ERROR("TableManager::CreateIndex: Failed to create physical index");
        catalog_->DropIndex(index_name);
        return false;
    }
    LOG_DEBUG(
        "TableManager::CreateIndex: Physical index created, now populating "
        "with existing data");
    bool populate_success =
        PopulateIndexWithExistingData(index_name, table_info, key_columns);
    if (!populate_success) {
        LOG_WARN(
            "TableManager::CreateIndex: Failed to populate index with existing "
            "data");
    }
    LOG_DEBUG("TableManager::CreateIndex: Index " << index_name
                                                  << " created successfully");
    try {
        catalog_->SaveCatalogToDisk();
        LOG_DEBUG(
            "TableManager::CreateIndex: Catalog saved after index creation");
    } catch (const std::exception& e) {
        LOG_WARN(
            "TableManager::CreateIndex: Failed to save catalog after index "
            "creation: "
            << e.what());
    }
    return true;
}
bool TableManager::PopulateIndexWithExistingData(
    const std::string& index_name, TableInfo* table_info,
    const std::vector<std::string>& key_columns) {
    LOG_DEBUG("TableManager::PopulateIndexWithExistingData: Populating index "
              << index_name);
    if (!table_info || !table_info->table_heap || !table_info->schema) {
        LOG_ERROR(
            "TableManager::PopulateIndexWithExistingData: Invalid table info");
        return false;
    }
    if (key_columns.size() != 1) {
        LOG_ERROR(
            "TableManager::PopulateIndexWithExistingData: Multi-column indexes "
            "not supported");
        return false;
    }
    const std::string& column_name = key_columns[0];
    const Schema* schema = table_info->schema.get();
    try {
        size_t column_idx = schema->GetColumnIdx(column_name);
        const Column& column = schema->GetColumn(column_idx);
        LOG_DEBUG(
            "TableManager::PopulateIndexWithExistingData: Processing column "
            << column_name << " of type " << static_cast<int>(column.type));
        auto iter = table_info->table_heap->Begin();
        auto end_iter = table_info->table_heap->End();
        int processed_count = 0;
        int success_count = 0;
        int error_count = 0;
        while (!iter.IsEnd()) {
            try {
                Tuple tuple = *iter;
                RID rid = tuple.GetRID();
                Value key_value = tuple.GetValue(column_idx);
                bool insert_success =
                    index_manager_->InsertEntry(index_name, key_value, rid);
                if (insert_success) {
                    success_count++;
                } else {
                    error_count++;
                    LOG_WARN(
                        "TableManager::PopulateIndexWithExistingData: Failed "
                        "to insert key into index");
                }
                processed_count++;
                if (processed_count % 1000 == 0) {
                    LOG_DEBUG(
                        "TableManager::PopulateIndexWithExistingData: "
                        "Processed "
                        << processed_count << " records");
                }
                ++iter;
            } catch (const std::exception& e) {
                LOG_ERROR(
                    "TableManager::PopulateIndexWithExistingData: Exception "
                    "processing record: "
                    << e.what());
                error_count++;
                ++iter;
            }
        }
        LOG_INFO(
            "TableManager::PopulateIndexWithExistingData: Finished populating "
            "index "
            << index_name << ". Processed: " << processed_count
            << ", Success: " << success_count << ", Errors: " << error_count);
        return error_count == 0;
    } catch (const std::exception& e) {
        LOG_ERROR("TableManager::PopulateIndexWithExistingData: Exception: "
                  << e.what());
        return false;
    }
}
bool TableManager::DropIndex(const std::string& index_name) {
    LOG_DEBUG("TableManager::DropIndex: Dropping index " << index_name);
    IndexInfo* index_info = catalog_->GetIndex(index_name);
    if (index_info == nullptr) {
        LOG_WARN("TableManager::DropIndex: Index " << index_name
                                                   << " not found");
        return false;
    }
    bool index_success = index_manager_->DropIndex(index_name);
    if (!index_success) {
        LOG_WARN("TableManager::DropIndex: Failed to drop physical index "
                 << index_name);
    }
    bool catalog_success = catalog_->DropIndex(index_name);
    if (!catalog_success) {
        LOG_ERROR("TableManager::DropIndex: Failed to drop index from catalog");
        return false;
    }
    LOG_DEBUG("TableManager::DropIndex: Index " << index_name
                                                << " dropped successfully");
    return true;
}
bool TableManager::UpdateIndexesOnInsert(const std::string& table_name,
                                         const Tuple& tuple, const RID& rid) {
    LOG_TRACE("TableManager::UpdateIndexesOnInsert: Updating indexes for table "
              << table_name);
    if (!index_manager_) {
        LOG_WARN("TableManager::UpdateIndexesOnInsert: IndexManager is null");
        return true;
    }
    std::vector<std::string> table_indexes;
    try {
        table_indexes = index_manager_->GetTableIndexes(table_name);
    } catch (const std::exception& e) {
        LOG_ERROR(
            "TableManager::UpdateIndexesOnInsert: Failed to get table indexes: "
            << e.what());
        return false;
    }
    bool all_success = true;
    for (const auto& index_name : table_indexes) {
        IndexInfo* index_info = catalog_->GetIndex(index_name);
        if (!index_info) {
            LOG_WARN(
                "TableManager::UpdateIndexesOnInsert: Index info not found for "
                << index_name);
            continue;
        }
        if (index_info->key_columns.size() != 1) {
            LOG_WARN(
                "TableManager::UpdateIndexesOnInsert: Multi-column index not "
                "supported: "
                << index_name);
            continue;
        }
        try {
            TableInfo* table_info = catalog_->GetTable(table_name);
            if (!table_info) {
                LOG_ERROR(
                    "TableManager::UpdateIndexesOnInsert: Table info not "
                    "found");
                all_success = false;
                continue;
            }
            const std::string& column_name = index_info->key_columns[0];
            size_t column_idx = table_info->schema->GetColumnIdx(column_name);
            Value key_value = tuple.GetValue(column_idx);
            auto start_time = std::chrono::steady_clock::now();
            const auto TIMEOUT_DURATION = std::chrono::seconds(5);
            bool success = false;
            try {
                success =
                    index_manager_->InsertEntry(index_name, key_value, rid);
                auto current_time = std::chrono::steady_clock::now();
                if (current_time - start_time > TIMEOUT_DURATION) {
                    LOG_ERROR(
                        "TableManager::UpdateIndexesOnInsert: Index insert "
                        "timed out for "
                        << index_name);
                    success = false;
                }
            } catch (const std::exception& e) {
                LOG_ERROR(
                    "TableManager::UpdateIndexesOnInsert: Exception during "
                    "index insert: "
                    << e.what());
                success = false;
            }
            if (!success) {
                LOG_WARN(
                    "TableManager::UpdateIndexesOnInsert: Failed to insert "
                    "into index "
                    << index_name);
                all_success = false;
            } else {
                LOG_TRACE(
                    "TableManager::UpdateIndexesOnInsert: Successfully "
                    "inserted "
                    << "into index " << index_name);
            }
        } catch (const std::exception& e) {
            LOG_ERROR(
                "TableManager::UpdateIndexesOnInsert: Exception updating index "
                << index_name << ": " << e.what());
            all_success = false;
        }
    }
    return all_success;
}
bool TableManager::UpdateIndexesOnDelete(const std::string& table_name,
                                         const Tuple& tuple) {
    LOG_TRACE("TableManager::UpdateIndexesOnDelete: Updating indexes for table "
              << table_name);
    std::vector<std::string> table_indexes =
        index_manager_->GetTableIndexes(table_name);
    bool all_success = true;
    for (const auto& index_name : table_indexes) {
        IndexInfo* index_info = catalog_->GetIndex(index_name);
        if (!index_info) {
            LOG_WARN(
                "TableManager::UpdateIndexesOnDelete: Index info not found for "
                << index_name);
            continue;
        }
        if (index_info->key_columns.size() != 1) {
            LOG_WARN(
                "TableManager::UpdateIndexesOnDelete: Multi-column index not "
                "supported: "
                << index_name);
            continue;
        }
        try {
            TableInfo* table_info = catalog_->GetTable(table_name);
            if (!table_info) {
                LOG_ERROR(
                    "TableManager::UpdateIndexesOnDelete: Table info not "
                    "found");
                all_success = false;
                continue;
            }
            const std::string& column_name = index_info->key_columns[0];
            size_t column_idx = table_info->schema->GetColumnIdx(column_name);
            Value key_value = tuple.GetValue(column_idx);
            bool success = index_manager_->DeleteEntry(index_name, key_value);
            if (!success) {
                LOG_WARN(
                    "TableManager::UpdateIndexesOnDelete: Failed to delete "
                    "from index "
                    << index_name);
                all_success = false;
            } else {
                LOG_TRACE(
                    "TableManager::UpdateIndexesOnDelete: Successfully deleted "
                    << "from index " << index_name);
            }
        } catch (const std::exception& e) {
            LOG_ERROR(
                "TableManager::UpdateIndexesOnDelete: Exception updating index "
                << index_name << ": " << e.what());
            all_success = false;
        }
    }
    return all_success;
}
bool TableManager::UpdateIndexesOnUpdate(const std::string& table_name,
                                         const Tuple& old_tuple,
                                         const Tuple& new_tuple,
                                         const RID& rid) {
    LOG_TRACE("TableManager::UpdateIndexesOnUpdate: Updating indexes for table "
              << table_name);
    std::vector<std::string> table_indexes =
        index_manager_->GetTableIndexes(table_name);
    bool all_success = true;
    for (const auto& index_name : table_indexes) {
        IndexInfo* index_info = catalog_->GetIndex(index_name);
        if (!index_info) {
            LOG_WARN(
                "TableManager::UpdateIndexesOnUpdate: Index info not found for "
                << index_name);
            continue;
        }
        if (index_info->key_columns.size() != 1) {
            LOG_WARN(
                "TableManager::UpdateIndexesOnUpdate: Multi-column index not "
                "supported: "
                << index_name);
            continue;
        }
        try {
            TableInfo* table_info = catalog_->GetTable(table_name);
            if (!table_info) {
                LOG_ERROR(
                    "TableManager::UpdateIndexesOnUpdate: Table info not "
                    "found");
                all_success = false;
                continue;
            }
            const std::string& column_name = index_info->key_columns[0];
            size_t column_idx = table_info->schema->GetColumnIdx(column_name);
            Value old_key_value = old_tuple.GetValue(column_idx);
            Value new_key_value = new_tuple.GetValue(column_idx);
            if (old_key_value.index() == new_key_value.index()) {
                bool keys_equal = false;
                std::visit(
                    [&](const auto& old_val) {
                        using T = std::decay_t<decltype(old_val)>;
                        if (std::holds_alternative<T>(new_key_value)) {
                            keys_equal =
                                (old_val == std::get<T>(new_key_value));
                        }
                    },
                    old_key_value);
                if (keys_equal) {
                    continue;
                }
            }
            bool delete_success =
                index_manager_->DeleteEntry(index_name, old_key_value);
            if (!delete_success) {
                LOG_WARN(
                    "TableManager::UpdateIndexesOnUpdate: Failed to delete old "
                    "key from index "
                    << index_name);
                all_success = false;
            }
            bool insert_success =
                index_manager_->InsertEntry(index_name, new_key_value, rid);
            if (!insert_success) {
                LOG_WARN(
                    "TableManager::UpdateIndexesOnUpdate: Failed to insert new "
                    "key into index "
                    << index_name);
                all_success = false;
                index_manager_->InsertEntry(index_name, old_key_value, rid);
            }
        } catch (const std::exception& e) {
            LOG_ERROR(
                "TableManager::UpdateIndexesOnUpdate: Exception updating index "
                << index_name << ": " << e.what());
            all_success = false;
        }
    }
    return all_success;
}
IndexManager* TableManager::GetIndexManager() { return index_manager_.get(); }
bool TableManager::CreateTable(const CreateTableStatement* stmt) {
    if (!stmt) {
        LOG_ERROR("TableManager::CreateTable: CreateTableStatement is null");
        return false;
    }
    LOG_DEBUG("TableManager::CreateTable: Creating table "
              << stmt->GetTableName());
    const std::string& table_name = stmt->GetTableName();
    const std::vector<Column>& columns = stmt->GetColumns();
    if (columns.empty()) {
        LOG_ERROR("TableManager::CreateTable: No columns defined for table "
                  << table_name);
        return false;
    }
    Schema schema(columns);
    bool success = catalog_->CreateTable(table_name, schema);
    if (!success) {
        LOG_ERROR("TableManager::CreateTable: Failed to create table "
                  << table_name);
        return false;
    }
    LOG_DEBUG("TableManager::CreateTable: Table " << table_name
                                                  << " created successfully");
    std::string primary_key_column;
    for (const auto& column : columns) {
        if (column.is_primary_key) {
            primary_key_column = column.name;
            LOG_DEBUG("TableManager::CreateTable: Found primary key column: "
                      << primary_key_column);
            break;
        }
    }
    if (!primary_key_column.empty()) {
        std::string primary_key_index_name = table_name + "_pk";
        std::vector<std::string> key_columns = {primary_key_column};
        LOG_DEBUG("TableManager::CreateTable: Creating primary key index "
                  << primary_key_index_name << " on column "
                  << primary_key_column);
        bool catalog_success = catalog_->CreateIndex(primary_key_index_name,
                                                     table_name, key_columns);
        if (!catalog_success) {
            LOG_ERROR(
                "TableManager::CreateTable: Failed to create primary key index "
                "in catalog");
            catalog_->DropTable(table_name);
            return false;
        }
        TableInfo* table_info = catalog_->GetTable(table_name);
        if (!table_info) {
            LOG_ERROR(
                "TableManager::CreateTable: Table info not found after "
                "creation");
            catalog_->DropTable(table_name);
            return false;
        }
        bool index_success =
            index_manager_->CreateIndex(primary_key_index_name, table_name,
                                        key_columns, table_info->schema.get());
        if (!index_success) {
            LOG_ERROR(
                "TableManager::CreateTable: Failed to create physical primary "
                "key index");
            catalog_->DropIndex(primary_key_index_name);
            catalog_->DropTable(table_name);
            return false;
        }
        LOG_DEBUG("TableManager::CreateTable: Primary key index "
                  << primary_key_index_name << " created successfully");
        auto all_indexes = index_manager_->GetAllIndexNames();
        bool found_pk_index = false;
        for (const auto& idx_name : all_indexes) {
            if (idx_name == primary_key_index_name) {
                found_pk_index = true;
                break;
            }
        }
        if (!found_pk_index) {
            LOG_ERROR(
                "TableManager::CreateTable: Primary key index not found after "
                "creation");
            catalog_->DropTable(table_name);
            return false;
        }
        LOG_DEBUG(
            "TableManager::CreateTable: Verified primary key index exists");
    } else {
        LOG_DEBUG(
            "TableManager::CreateTable: No primary key column found for table "
            << table_name);
    }
    LOG_DEBUG(
        "TableManager::CreateTable: Successfully completed table creation for "
        << table_name);
    return true;
}
bool TableManager::DropTable(const std::string& table_name) {
    LOG_DEBUG("TableManager::DropTable: Dropping table " << table_name);
    TableInfo* table_info = catalog_->GetTable(table_name);
    if (table_info == nullptr) {
        LOG_WARN("TableManager::DropTable: Table " << table_name
                                                   << " not found");
        return false;
    }
    std::vector<IndexInfo*> indexes = catalog_->GetTableIndexes(table_name);
    for (auto* index_info : indexes) {
        LOG_DEBUG("TableManager::DropTable: Dropping index "
                  << index_info->index_name);
        bool index_dropped = DropIndex(index_info->index_name);
        if (!index_dropped) {
            LOG_WARN("TableManager::DropTable: Failed to drop index "
                     << index_info->index_name);
        }
    }
    bool success = catalog_->DropTable(table_name);
    if (success) {
        LOG_DEBUG("TableManager::DropTable: Successfully dropped table "
                  << table_name);
    } else {
        LOG_ERROR("TableManager::DropTable: Failed to drop table "
                  << table_name);
    }
    return success;
}
}


========== ./src/execution/execution_engine.cpp ==========
namespace SimpleRDBMS {
ExecutionEngine::ExecutionEngine(BufferPoolManager* buffer_pool_manager,
                                 Catalog* catalog,
                                 TransactionManager* txn_manager,
                                 LogManager* log_manager)
    : buffer_pool_manager_(buffer_pool_manager),
      catalog_(catalog),
      txn_manager_(txn_manager),
      log_manager_(log_manager),
      table_manager_(
          std::make_unique<TableManager>(buffer_pool_manager, catalog)) {
    if (log_manager_ && catalog_) {
        catalog_->SetLogManager(log_manager_);
    }
}
bool ExecutionEngine::Execute(Statement* statement,
                              std::vector<Tuple>* result_set,
                              Transaction* txn) {
    LOG_DEBUG("ExecutionEngine::Execute: Starting execution");
    if (!statement || !result_set || !txn) {
        LOG_ERROR("ExecutionEngine::Execute: Invalid parameters");
        if (!statement) {
            LOG_ERROR("ExecutionEngine::Execute: Statement is null");
        }
        if (!result_set) {
            LOG_ERROR("ExecutionEngine::Execute: Result set is null");
        }
        if (!txn) {
            LOG_ERROR("ExecutionEngine::Execute: Transaction is null");
        }
        return false;
    }
    LOG_DEBUG("ExecutionEngine::Execute: Statement type: "
              << static_cast<int>(statement->GetType()));
    switch (statement->GetType()) {
        case Statement::StmtType::CREATE_TABLE: {
            LOG_DEBUG("ExecutionEngine::Execute: Handling CREATE_TABLE");
            auto* create_stmt = static_cast<CreateTableStatement*>(statement);
            return table_manager_->CreateTable(create_stmt);
        }
        case Statement::StmtType::DROP_TABLE: {
            LOG_DEBUG("ExecutionEngine::Execute: Handling DROP_TABLE");
            auto* drop_stmt = static_cast<DropTableStatement*>(statement);
            return table_manager_->DropTable(drop_stmt->GetTableName());
        }
        case Statement::StmtType::CREATE_INDEX: {
            LOG_DEBUG("ExecutionEngine::Execute: Handling CREATE_INDEX");
            auto* create_idx_stmt =
                static_cast<CreateIndexStatement*>(statement);
            return table_manager_->CreateIndex(
                create_idx_stmt->GetIndexName(),
                create_idx_stmt->GetTableName(),
                create_idx_stmt->GetKeyColumns());
        }
        case Statement::StmtType::DROP_INDEX: {
            LOG_DEBUG("ExecutionEngine::Execute: Handling DROP_INDEX");
            auto* drop_idx_stmt = static_cast<DropIndexStatement*>(statement);
            return table_manager_->DropIndex(drop_idx_stmt->GetIndexName());
        }
        case Statement::StmtType::SHOW_TABLES: {
            return HandleShowTables(result_set);
        }
        case Statement::StmtType::BEGIN_TXN: {
            return HandleBegin(txn);
        }
        case Statement::StmtType::COMMIT_TXN: {
            return HandleCommit(txn);
        }
        case Statement::StmtType::ROLLBACK_TXN: {
            return HandleRollback(txn);
        }
        case Statement::StmtType::EXPLAIN: {
            LOG_DEBUG("ExecutionEngine::Execute: Handling EXPLAIN");
            auto* explain_stmt = static_cast<ExplainStatement*>(statement);
            return HandleExplain(explain_stmt, result_set);
        }
        default:
            LOG_DEBUG(
                "ExecutionEngine::Execute: Handling DML statement, creating "
                "plan");
            break;
    }
    LOG_DEBUG("ExecutionEngine::Execute: Creating execution plan");
    auto plan = CreatePlan(statement);
    if (!plan) {
        LOG_ERROR("ExecutionEngine::Execute: Failed to create plan");
        return false;
    }
    LOG_DEBUG("ExecutionEngine::Execute: Creating executor context");
    ExecutorContext exec_ctx(txn, catalog_, buffer_pool_manager_,
                             table_manager_.get());
    LOG_DEBUG("ExecutionEngine::Execute: Creating executor");
    auto executor = CreateExecutor(&exec_ctx, std::move(plan));
    if (!executor) {
        LOG_ERROR("ExecutionEngine::Execute: Failed to create executor");
        return false;
    }
    LOG_DEBUG("ExecutionEngine::Execute: Initializing executor");
    executor->Init();
    LOG_DEBUG("ExecutionEngine::Execute: Executing tuples");
    Tuple tuple;
    RID rid;
    int tuple_count = 0;
    const int MAX_TUPLES = 1000000;
    auto start_time = std::chrono::steady_clock::now();
    const auto TIMEOUT_DURATION = std::chrono::seconds(10);
    while (tuple_count < MAX_TUPLES) {
        auto current_time = std::chrono::steady_clock::now();
        if (current_time - start_time > TIMEOUT_DURATION) {
            LOG_ERROR("ExecutionEngine::Execute: Operation timed out after "
                      << std::chrono::duration_cast<std::chrono::seconds>(
                             TIMEOUT_DURATION)
                             .count()
                      << " seconds");
            return false;
        }
        bool has_next = false;
        try {
            has_next = executor->Next(&tuple, &rid);
        } catch (const std::exception& e) {
            LOG_ERROR(
                "ExecutionEngine::Execute: Exception during tuple execution: "
                << e.what());
            return false;
        }
        if (!has_next) {
            break;
        }
        result_set->push_back(tuple);
        tuple_count++;
        if (tuple_count % 100 == 0) {
            LOG_DEBUG("ExecutionEngine::Execute: Processed " << tuple_count
                                                             << " tuples");
        }
    }
    if (tuple_count >= MAX_TUPLES) {
        LOG_ERROR("ExecutionEngine::Execute: Reached maximum tuple limit ("
                  << MAX_TUPLES << "), possible infinite loop detected");
        return false;
    }
    LOG_DEBUG("ExecutionEngine::Execute: Execution completed, processed "
              << tuple_count << " tuples");
    return true;
}
std::unique_ptr<PlanNode> ExecutionEngine::CreatePlan(Statement* statement) {
    if (!statement) {
        return nullptr;
    }
    switch (statement->GetType()) {
        case Statement::StmtType::SELECT:
            return CreateSelectPlan(static_cast<SelectStatement*>(statement));
        case Statement::StmtType::INSERT:
            return CreateInsertPlan(static_cast<InsertStatement*>(statement));
        case Statement::StmtType::UPDATE:
            return CreateUpdatePlan(static_cast<UpdateStatement*>(statement));
        case Statement::StmtType::DELETE:
            return CreateDeletePlan(static_cast<DeleteStatement*>(statement));
        default:
            return nullptr;
    }
}
std::unique_ptr<PlanNode> ExecutionEngine::CreateUpdatePlan(
    UpdateStatement* stmt) {
    if (!stmt) {
        return nullptr;
    }
    TableInfo* table_info = catalog_->GetTable(stmt->GetTableName());
    if (!table_info) {
        return nullptr;
    }
    std::vector<Column> result_columns = {
        {"affected_rows", TypeId::INTEGER, 0, false, false}};
    auto result_schema = std::make_unique<Schema>(result_columns);
    std::vector<std::pair<std::string, std::unique_ptr<Expression>>> updates;
    for (const auto& clause : stmt->GetUpdateClauses()) {
        auto cloned_expr = ExpressionCloner::Clone(clause.value.get());
        if (!cloned_expr) {
            throw ExecutionException("Failed to clone update expression");
        }
        updates.emplace_back(clause.column_name, std::move(cloned_expr));
    }
    auto where_copy = ExpressionCloner::Clone(stmt->GetWhereClause());
    return std::make_unique<UpdatePlanNode>(
        std::move(result_schema), stmt->GetTableName(), std::move(updates),
        std::move(where_copy));
}
std::unique_ptr<PlanNode> ExecutionEngine::CreateDeletePlan(
    DeleteStatement* stmt) {
    if (!stmt) {
        return nullptr;
    }
    TableInfo* table_info = catalog_->GetTable(stmt->GetTableName());
    if (!table_info) {
        return nullptr;
    }
    std::vector<Column> result_columns = {
        {"affected_rows", TypeId::INTEGER, 0, false, false}};
    auto result_schema = std::make_unique<Schema>(result_columns);
    auto where_copy = ExpressionCloner::Clone(stmt->GetWhereClause());
    return std::make_unique<DeletePlanNode>(
        std::move(result_schema), stmt->GetTableName(), std::move(where_copy));
}
std::unique_ptr<Executor> ExecutionEngine::CreateExecutor(
    ExecutorContext* exec_ctx, std::unique_ptr<PlanNode> plan) {
    if (!plan) {
        return nullptr;
    }
    switch (plan->GetType()) {
        case PlanNodeType::SEQUENTIAL_SCAN: {
            auto seq_scan_plan = static_cast<SeqScanPlanNode*>(plan.release());
            return std::make_unique<SeqScanExecutor>(
                exec_ctx, std::unique_ptr<SeqScanPlanNode>(seq_scan_plan));
        }
        case PlanNodeType::INDEX_SCAN: {
            auto index_scan_plan =
                static_cast<IndexScanPlanNode*>(plan.release());
            return std::make_unique<IndexScanExecutor>(
                exec_ctx, std::unique_ptr<IndexScanPlanNode>(index_scan_plan));
        }
        case PlanNodeType::PROJECTION: {
            auto projection_plan =
                static_cast<ProjectionPlanNode*>(plan.release());
            return std::make_unique<ProjectionExecutor>(
                exec_ctx, std::unique_ptr<ProjectionPlanNode>(projection_plan));
        }
        case PlanNodeType::INSERT: {
            auto insert_plan = static_cast<InsertPlanNode*>(plan.release());
            return std::make_unique<InsertExecutor>(
                exec_ctx, std::unique_ptr<InsertPlanNode>(insert_plan));
        }
        case PlanNodeType::UPDATE: {
            auto update_plan = static_cast<UpdatePlanNode*>(plan.release());
            return std::make_unique<UpdateExecutor>(
                exec_ctx, std::unique_ptr<UpdatePlanNode>(update_plan));
        }
        case PlanNodeType::DELETE: {
            auto delete_plan = static_cast<DeletePlanNode*>(plan.release());
            return std::make_unique<DeleteExecutor>(
                exec_ctx, std::unique_ptr<DeletePlanNode>(delete_plan));
        }
        default:
            return nullptr;
    }
}
std::unique_ptr<PlanNode> ExecutionEngine::CreateSelectPlan(
    SelectStatement* stmt) {
    if (!stmt) {
        LOG_ERROR("CreateSelectPlan: SelectStatement is null");
        return nullptr;
    }
    LOG_DEBUG("CreateSelectPlan: Creating plan for table "
              << stmt->GetTableName());
    TableInfo* table_info = catalog_->GetTable(stmt->GetTableName());
    if (!table_info) {
        LOG_ERROR("CreateSelectPlan: Table '" << stmt->GetTableName()
                                              << "' not found in catalog");
        return nullptr;
    }
    const auto& select_list = stmt->GetSelectList();
    bool is_select_all = false;
    if (select_list.size() == 1) {
        auto* col_ref =
            dynamic_cast<ColumnRefExpression*>(select_list[0].get());
        if (col_ref && col_ref->GetColumnName() == "*") {
            is_select_all = true;
        }
    }
    LOG_DEBUG("CreateSelectPlan: Found table "
              << stmt->GetTableName() << " with schema containing "
              << table_info->schema->GetColumnCount() << " columns");
    std::unique_ptr<PlanNode> scan_plan;
    if (stmt->GetWhereClause()) {
        std::string selected_index =
            SelectBestIndex(stmt->GetTableName(), stmt->GetWhereClause());
        if (!selected_index.empty()) {
            LOG_DEBUG("Using index scan with index: " << selected_index);
            auto where_copy = ExpressionCloner::Clone(stmt->GetWhereClause());
            scan_plan = std::make_unique<IndexScanPlanNode>(
                table_info->schema.get(), stmt->GetTableName(), selected_index,
                std::move(where_copy));
        }
    }
    if (!scan_plan) {
        LOG_DEBUG("Using sequential scan");
        auto where_copy = ExpressionCloner::Clone(stmt->GetWhereClause());
        scan_plan = std::make_unique<SeqScanPlanNode>(table_info->schema.get(),
                                                      stmt->GetTableName(),
                                                      std::move(where_copy));
    }
    if (is_select_all) {
        return std::move(scan_plan);
    } else {
        std::vector<Column> selected_columns;
        for (const auto& expr : select_list) {
            auto* col_ref = dynamic_cast<ColumnRefExpression*>(expr.get());
            if (col_ref) {
                const std::string& col_name = col_ref->GetColumnName();
                if (table_info->schema->HasColumn(col_name)) {
                    selected_columns.push_back(
                        table_info->schema->GetColumn(col_name));
                } else {
                    LOG_ERROR("CreateSelectPlan: Column '"
                              << col_name << "' not found in table");
                    return nullptr;
                }
            }
        }
        auto projection_schema = std::make_unique<Schema>(selected_columns);
        const Schema* output_schema = projection_schema.get();
        std::vector<std::unique_ptr<Expression>> expressions;
        for (const auto& expr : select_list) {
            expressions.push_back(ExpressionCloner::Clone(expr.get()));
        }
        auto projection_plan = std::make_unique<ProjectionPlanNode>(
            output_schema, std::move(expressions), std::move(scan_plan));
        projection_plan->SetOwnedSchema(std::move(projection_schema));
        return std::move(projection_plan);
    }
}
std::unique_ptr<PlanNode> ExecutionEngine::CreateInsertPlan(
    InsertStatement* stmt) {
    if (!stmt) {
        return nullptr;
    }
    TableInfo* table_info = catalog_->GetTable(stmt->GetTableName());
    if (!table_info) {
        return nullptr;
    }
    return std::make_unique<InsertPlanNode>(
        table_info->schema.get(), stmt->GetTableName(), stmt->GetValues());
}
std::string ExecutionEngine::SelectBestIndex(const std::string& table_name,
                                             Expression* where_clause) {
    if (!where_clause) {
        return "";
    }
    LOG_DEBUG("SelectBestIndex: Analyzing WHERE clause for table "
              << table_name);
    if (auto* binary_expr = dynamic_cast<BinaryOpExpression*>(where_clause)) {
        if (binary_expr->GetOperator() == BinaryOpExpression::OpType::EQUALS) {
            std::string column_name;
            if (auto* col_ref = dynamic_cast<ColumnRefExpression*>(
                    binary_expr->GetLeft())) {
                column_name = col_ref->GetColumnName();
            }
            else if (auto* col_ref = dynamic_cast<ColumnRefExpression*>(
                         binary_expr->GetRight())) {
                column_name = col_ref->GetColumnName();
            }
            if (!column_name.empty()) {
                bool has_constant = false;
                if (dynamic_cast<ConstantExpression*>(binary_expr->GetLeft()) ||
                    dynamic_cast<ConstantExpression*>(
                        binary_expr->GetRight())) {
                    has_constant = true;
                }
                if (has_constant) {
                    LOG_DEBUG(
                        "SelectBestIndex: Found equality condition on column: "
                        << column_name);
                    std::vector<IndexInfo*> indexes =
                        catalog_->GetTableIndexes(table_name);
                    for (auto* index_info : indexes) {
                        if (index_info->key_columns.size() == 1 &&
                            index_info->key_columns[0] == column_name) {
                            LOG_DEBUG("SelectBestIndex: Found suitable index: "
                                      << index_info->index_name);
                            return index_info->index_name;
                        }
                    }
                    LOG_DEBUG("SelectBestIndex: No index found for column: "
                              << column_name);
                }
            }
        }
        else {
            LOG_DEBUG("SelectBestIndex: Unsupported operator for index usage");
        }
    }
    else if (auto* and_expr = dynamic_cast<BinaryOpExpression*>(where_clause)) {
        if (and_expr->GetOperator() == BinaryOpExpression::OpType::AND) {
            std::string left_index =
                SelectBestIndex(table_name, and_expr->GetLeft());
            if (!left_index.empty()) {
                return left_index;
            }
            std::string right_index =
                SelectBestIndex(table_name, and_expr->GetRight());
            if (!right_index.empty()) {
                return right_index;
            }
        }
    }
    LOG_DEBUG("SelectBestIndex: No suitable index found for the WHERE clause");
    return "";
}
bool ExecutionEngine::HandleShowTables(std::vector<Tuple>* result_set) {
    std::vector<Column> columns = {
        {"table_name", TypeId::VARCHAR, 100, false, false},
        {"column_name", TypeId::VARCHAR, 100, false, false},
        {"data_type", TypeId::VARCHAR, 50, false, false},
        {"is_nullable", TypeId::VARCHAR, 10, false, false},
        {"is_primary_key", TypeId::VARCHAR, 10, false, false},
        {"column_size", TypeId::INTEGER, 0, false, false}};
    Schema result_schema(columns);
    result_set->clear();
    try {
        std::vector<std::string> table_names = catalog_->GetAllTableNames();
        for (const std::string& table_name : table_names) {
            TableInfo* table_info = catalog_->GetTable(table_name);
            if (!table_info || !table_info->schema) {
                continue;
            }
            const Schema* table_schema = table_info->schema.get();
            for (size_t i = 0; i < table_schema->GetColumnCount(); ++i) {
                const Column& col = table_schema->GetColumn(i);
                std::vector<Value> values;
                values.push_back(Value(table_name));
                values.push_back(Value(col.name));
                values.push_back(Value(TypeIdToString(col.type)));
                values.push_back(Value(col.nullable ? "YES" : "NO"));
                values.push_back(Value(col.is_primary_key ? "YES" : "NO"));
                values.push_back(Value(static_cast<int32_t>(col.size)));
                Tuple tuple(values, &result_schema);
                result_set->push_back(tuple);
            }
        }
        LOG_DEBUG("SHOW TABLES returned " << result_set->size()
                                          << " columns from "
                                          << table_names.size() << " tables");
        return true;
    } catch (const std::exception& e) {
        LOG_ERROR("Error in HandleShowTables: " << e.what());
        return false;
    }
}
bool ExecutionEngine::HandleBegin(Transaction* txn) {
    LOG_DEBUG("BEGIN transaction executed");
    return true;
}
bool ExecutionEngine::HandleCommit(Transaction* txn) {
    LOG_DEBUG("COMMIT transaction executed");
    return true;
}
bool ExecutionEngine::HandleRollback(Transaction* txn) {
    LOG_DEBUG("ROLLBACK transaction executed");
    return true;
}
bool ExecutionEngine::HandleExplain(ExplainStatement* stmt,
                                    std::vector<Tuple>* result_set) {
    Statement* inner_stmt = stmt->GetStatement();
    auto plan = CreatePlan(inner_stmt);
    if (!plan) {
        LOG_ERROR("HandleExplain: Failed to create plan");
        return false;
    }
    std::string plan_text = FormatExecutionPlan(plan.get());
    std::vector<Column> columns = {
        {"QUERY PLAN", TypeId::VARCHAR, 1000, false, false}};
    Schema result_schema(columns);
    std::istringstream iss(plan_text);
    std::string line;
    while (std::getline(iss, line)) {
        std::vector<Value> values = {Value(line)};
        Tuple tuple(values, &result_schema);
        result_set->push_back(tuple);
    }
    return true;
}
std::string ExecutionEngine::FormatExecutionPlan(PlanNode* plan, int indent) {
    std::ostringstream oss;
    for (int i = 0; i < indent; i++) {
        oss << "  ";
    }
    oss << "-> " << GetPlanNodeTypeString(plan->GetType());
    switch (plan->GetType()) {
        case PlanNodeType::SEQUENTIAL_SCAN: {
            auto* seq_scan = static_cast<SeqScanPlanNode*>(plan);
            oss << " on " << seq_scan->GetTableName();
            if (seq_scan->GetPredicate()) {
                oss << " (Filter: WHERE clause)";
            }
            break;
        }
        case PlanNodeType::INDEX_SCAN: {
            auto* index_scan = static_cast<IndexScanPlanNode*>(plan);
            oss << " using " << index_scan->GetIndexName() << " on "
                << index_scan->GetTableName();
            if (index_scan->GetPredicate()) {
                oss << " (Index Cond: WHERE clause)";
            }
            break;
        }
        case PlanNodeType::INSERT: {
            auto* insert_plan = static_cast<InsertPlanNode*>(plan);
            oss << " into " << insert_plan->GetTableName();
            oss << " (" << insert_plan->GetValues().size() << " rows)";
            break;
        }
        case PlanNodeType::UPDATE: {
            auto* update_plan = static_cast<UpdatePlanNode*>(plan);
            oss << " on " << update_plan->GetTableName();
            if (update_plan->GetPredicate()) {
                oss << " (Filter: WHERE clause)";
            }
            break;
        }
        case PlanNodeType::DELETE: {
            auto* delete_plan = static_cast<DeletePlanNode*>(plan);
            oss << " from " << delete_plan->GetTableName();
            if (delete_plan->GetPredicate()) {
                oss << " (Filter: WHERE clause)";
            }
            break;
        }
        case PlanNodeType::PROJECTION: {
            auto* proj_plan = static_cast<ProjectionPlanNode*>(plan);
            oss << " (" << proj_plan->GetExpressions().size() << " columns)";
            break;
        }
        default:
            break;
    }
    oss << "\n";
    const auto& children = plan->GetChildren();
    for (const auto& child : children) {
        oss << FormatExecutionPlan(child.get(), indent + 1);
    }
    return oss.str();
}
std::string ExecutionEngine::GetPlanNodeTypeString(PlanNodeType type) {
    switch (type) {
        case PlanNodeType::SEQUENTIAL_SCAN:
            return "Seq Scan";
        case PlanNodeType::INDEX_SCAN:
            return "Index Scan";
        case PlanNodeType::INSERT:
            return "Insert";
        case PlanNodeType::UPDATE:
            return "Update";
        case PlanNodeType::DELETE:
            return "Delete";
        case PlanNodeType::PROJECTION:
            return "Projection";
        case PlanNodeType::FILTER:
            return "Filter";
        case PlanNodeType::NESTED_LOOP_JOIN:
            return "Nested Loop Join";
        case PlanNodeType::HASH_JOIN:
            return "Hash Join";
        case PlanNodeType::AGGREGATION:
            return "Aggregation";
        case PlanNodeType::SORT:
            return "Sort";
        case PlanNodeType::LIMIT:
            return "Limit";
        default:
            return "Unknown";
    }
}
}


========== ./src/execution/executor.cpp ==========
namespace SimpleRDBMS {
SeqScanExecutor::SeqScanExecutor(ExecutorContext* exec_ctx,
                                 std::unique_ptr<SeqScanPlanNode> plan)
    : Executor(exec_ctx, std::move(plan)), table_info_(nullptr) {}
void SeqScanExecutor::Init() {
    auto* seq_scan_plan = GetSeqScanPlan();
    table_info_ =
        exec_ctx_->GetCatalog()->GetTable(seq_scan_plan->GetTableName());
    if (table_info_ == nullptr) {
        throw ExecutionException("Table not found: " +
                                 seq_scan_plan->GetTableName());
    }
    LOG_DEBUG("SeqScanExecutor::Init: table "
              << seq_scan_plan->GetTableName() << " first_page_id="
              << table_info_->table_heap->GetFirstPageId());
    table_iterator_ = table_info_->table_heap->Begin();
    LOG_DEBUG("SeqScanExecutor::Init: iterator initialized, IsEnd="
              << table_iterator_.IsEnd());
}
bool SeqScanExecutor::Next(Tuple* tuple, RID* rid) {
    auto* seq_scan_plan = GetSeqScanPlan();
    if (!evaluator_ && seq_scan_plan->GetPredicate()) {
        evaluator_ =
            std::make_unique<ExpressionEvaluator>(table_info_->schema.get());
    }
    while (!table_iterator_.IsEnd()) {
        try {
            LOG_DEBUG("SeqScanExecutor::Next: getting current tuple");
            *tuple = *table_iterator_;
            *rid = tuple->GetRID();
            LOG_DEBUG("SeqScanExecutor::Next: got tuple with RID "
                      << rid->page_id << ":" << rid->slot_num);
            ++table_iterator_;
            LOG_DEBUG("SeqScanExecutor::Next: moved to next, IsEnd="
                      << table_iterator_.IsEnd());
            Expression* predicate = seq_scan_plan->GetPredicate();
            if (predicate == nullptr) {
                return true;
            }
            if (evaluator_->EvaluateAsBoolean(predicate, *tuple)) {
                return true;
            }
        } catch (const std::exception& e) {
            LOG_ERROR(
                "SeqScanExecutor::Next: Exception during scan: " << e.what());
            return false;
        }
    }
    LOG_DEBUG("SeqScanExecutor::Next: iterator is at end");
    return false;
}
IndexScanExecutor::IndexScanExecutor(ExecutorContext* exec_ctx,
                                     std::unique_ptr<IndexScanPlanNode> plan)
    : Executor(exec_ctx, std::move(plan)),
      table_info_(nullptr),
      index_info_(nullptr),
      has_found_tuple_(false) {}
void IndexScanExecutor::Init() {
    auto* index_scan_plan = GetIndexScanPlan();
    table_info_ =
        exec_ctx_->GetCatalog()->GetTable(index_scan_plan->GetTableName());
    if (table_info_ == nullptr) {
        throw ExecutionException("Table not found: " +
                                 index_scan_plan->GetTableName());
    }
    index_info_ =
        exec_ctx_->GetCatalog()->GetIndex(index_scan_plan->GetIndexName());
    if (index_info_ == nullptr) {
        throw ExecutionException("Index not found: " +
                                 index_scan_plan->GetIndexName());
    }
    evaluator_ =
        std::make_unique<ExpressionEvaluator>(table_info_->schema.get());
    has_found_tuple_ = false;
    ExtractSearchKey(index_scan_plan->GetPredicate());
}
bool IndexScanExecutor::Next(Tuple* tuple, RID* rid) {
    if (has_found_tuple_) {
        return false;
    }
    auto* index_scan_plan = GetIndexScanPlan();
    TableManager* table_manager = exec_ctx_->GetTableManager();
    IndexManager* index_manager = table_manager->GetIndexManager();
    RID found_rid;
    bool found = index_manager->FindEntry(index_scan_plan->GetIndexName(),
                                          search_key_, &found_rid);
    if (found) {
        bool success = table_info_->table_heap->GetTuple(
            found_rid, tuple, exec_ctx_->GetTransaction()->GetTxnId());
        if (success) {
            *rid = found_rid;
            has_found_tuple_ = true;
            return true;
        }
    }
    return false;
}
void IndexScanExecutor::ExtractSearchKey(Expression* predicate) {
    if (auto* binary_expr = dynamic_cast<BinaryOpExpression*>(predicate)) {
        if (binary_expr->GetOperator() == BinaryOpExpression::OpType::EQUALS) {
            if (auto* const_expr = dynamic_cast<ConstantExpression*>(
                    binary_expr->GetRight())) {
                search_key_ = const_expr->GetValue();
            }
        }
    }
}
InsertExecutor::InsertExecutor(ExecutorContext* exec_ctx,
                               std::unique_ptr<InsertPlanNode> plan)
    : Executor(exec_ctx, std::move(plan)),
      table_info_(nullptr),
      current_index_(0) {}
void InsertExecutor::Init() {
    auto* insert_plan = GetInsertPlan();
    table_info_ =
        exec_ctx_->GetCatalog()->GetTable(insert_plan->GetTableName());
    if (table_info_ == nullptr) {
        throw ExecutionException("Table not found: " +
                                 insert_plan->GetTableName());
    }
    current_index_ = 0;
}
bool InsertExecutor::Next(Tuple* tuple, RID* rid) {
    auto* insert_plan = GetInsertPlan();
    const auto& values_list = insert_plan->GetValues();
    if (current_index_ >= values_list.size()) {
        return false;
    }
    const auto& values = values_list[current_index_];
    Tuple insert_tuple(values, table_info_->schema.get());
    bool success = table_info_->table_heap->InsertTuple(
        insert_tuple, rid, exec_ctx_->GetTransaction()->GetTxnId());
    if (!success) {
        throw ExecutionException("Failed to insert tuple");
    }
    TableManager* table_manager = exec_ctx_->GetTableManager();
    if (table_manager) {
        bool index_success = table_manager->UpdateIndexesOnInsert(
            table_info_->table_name, insert_tuple, *rid);
        if (!index_success) {
            LOG_WARN("Failed to update indexes for insert operation");
        }
    }
    current_index_++;
    *tuple = Tuple();
    return true;
}
UpdateExecutor::UpdateExecutor(ExecutorContext* exec_ctx,
                               std::unique_ptr<UpdatePlanNode> plan)
    : Executor(exec_ctx, std::move(plan)),
      table_info_(nullptr),
      current_index_(0),
      is_executed_(false) {}
void UpdateExecutor::Init() {
    auto* update_plan = GetUpdatePlan();
    table_info_ =
        exec_ctx_->GetCatalog()->GetTable(update_plan->GetTableName());
    if (table_info_ == nullptr) {
        throw ExecutionException("Table not found: " +
                                 update_plan->GetTableName());
    }
    evaluator_ =
        std::make_unique<ExpressionEvaluator>(table_info_->schema.get());
    target_rids_.clear();
    current_index_ = 0;
    is_executed_ = false;
    auto iter = table_info_->table_heap->Begin();
    while (!iter.IsEnd()) {
        Tuple tuple = *iter;
        Expression* predicate = update_plan->GetPredicate();
        if (predicate == nullptr ||
            evaluator_->EvaluateAsBoolean(predicate, tuple)) {
            target_rids_.push_back(tuple.GetRID());
        }
        ++iter;
    }
}
bool UpdateExecutor::Next(Tuple* tuple, RID* rid) {
    if (is_executed_) {
        return false;
    }
    auto* update_plan = GetUpdatePlan();
    int updated_count = 0;
    TableManager* table_manager = exec_ctx_->GetTableManager();
    for (const RID& target_rid : target_rids_) {
        Tuple old_tuple;
        if (!table_info_->table_heap->GetTuple(
                target_rid, &old_tuple,
                exec_ctx_->GetTransaction()->GetTxnId())) {
            continue;
        }
        std::vector<Value> new_values;
        const auto& columns = table_info_->schema->GetColumns();
        for (size_t i = 0; i < columns.size(); ++i) {
            const std::string& column_name = columns[i].name;
            bool found_update = false;
            for (const auto& update_pair : update_plan->GetUpdates()) {
                if (update_pair.first == column_name) {
                    Value new_value = evaluator_->Evaluate(
                        update_pair.second.get(), old_tuple);
                    new_values.push_back(new_value);
                    found_update = true;
                    break;
                }
            }
            if (!found_update) {
                new_values.push_back(old_tuple.GetValue(i));
            }
        }
        Tuple new_tuple(new_values, table_info_->schema.get());
        if (table_info_->table_heap->UpdateTuple(
                new_tuple, target_rid,
                exec_ctx_->GetTransaction()->GetTxnId())) {
            if (table_manager) {
                bool index_success = table_manager->UpdateIndexesOnUpdate(
                    table_info_->table_name, old_tuple, new_tuple, target_rid);
                if (!index_success) {
                    LOG_WARN("Failed to update indexes for update operation");
                }
            }
            updated_count++;
        }
    }
    is_executed_ = true;
    std::vector<Value> result_values = {Value(updated_count)};
    *tuple = Tuple(result_values, GetOutputSchema());
    *rid = RID{INVALID_PAGE_ID, -1};
    return true;
}
DeleteExecutor::DeleteExecutor(ExecutorContext* exec_ctx,
                               std::unique_ptr<DeletePlanNode> plan)
    : Executor(exec_ctx, std::move(plan)),
      table_info_(nullptr),
      current_index_(0),
      is_executed_(false) {}
void DeleteExecutor::Init() {
    auto* delete_plan = GetDeletePlan();
    table_info_ =
        exec_ctx_->GetCatalog()->GetTable(delete_plan->GetTableName());
    if (table_info_ == nullptr) {
        throw ExecutionException("Table not found: " +
                                 delete_plan->GetTableName());
    }
    evaluator_ =
        std::make_unique<ExpressionEvaluator>(table_info_->schema.get());
    target_rids_.clear();
    current_index_ = 0;
    is_executed_ = false;
    auto iter = table_info_->table_heap->Begin();
    while (!iter.IsEnd()) {
        Tuple tuple = *iter;
        Expression* predicate = delete_plan->GetPredicate();
        if (predicate == nullptr ||
            evaluator_->EvaluateAsBoolean(predicate, tuple)) {
            target_rids_.push_back(tuple.GetRID());
        }
        ++iter;
    }
}
bool DeleteExecutor::Next(Tuple* tuple, RID* rid) {
    if (is_executed_) {
        return false;
    }
    int deleted_count = 0;
    TableManager* table_manager = exec_ctx_->GetTableManager();
    for (const RID& target_rid : target_rids_) {
        Tuple tuple_to_delete;
        bool got_tuple = table_info_->table_heap->GetTuple(
            target_rid, &tuple_to_delete,
            exec_ctx_->GetTransaction()->GetTxnId());
        if (table_info_->table_heap->DeleteTuple(
                target_rid, exec_ctx_->GetTransaction()->GetTxnId())) {
            if (got_tuple && table_manager) {
                bool index_success = table_manager->UpdateIndexesOnDelete(
                    table_info_->table_name, tuple_to_delete);
                if (!index_success) {
                    LOG_WARN("Failed to update indexes for delete operation");
                }
            }
            deleted_count++;
        }
    }
    is_executed_ = true;
    std::vector<Value> result_values = {Value(deleted_count)};
    *tuple = Tuple(result_values, GetOutputSchema());
    *rid = RID{INVALID_PAGE_ID, -1};
    return true;
}
ProjectionExecutor::ProjectionExecutor(ExecutorContext* exec_ctx,
                                       std::unique_ptr<ProjectionPlanNode> plan)
    : Executor(exec_ctx, std::move(plan)) {}
void ProjectionExecutor::Init() {
    auto* projection_plan = GetProjectionPlan();
    const auto* child_plan = projection_plan->GetChild(0);
    if (!child_plan) {
        throw ExecutionException("ProjectionExecutor: No child plan");
    }
    if (child_plan->GetType() == PlanNodeType::SEQUENTIAL_SCAN) {
        auto* seq_scan_plan = static_cast<const SeqScanPlanNode*>(child_plan);
        auto new_seq_scan_plan = std::make_unique<SeqScanPlanNode>(
            seq_scan_plan->GetOutputSchema(), seq_scan_plan->GetTableName(),
            nullptr
        );
        child_executor_ = std::make_unique<SeqScanExecutor>(
            exec_ctx_, std::move(new_seq_scan_plan));
    } else {
        throw ExecutionException(
            "ProjectionExecutor: Unsupported child plan type");
    }
    child_executor_->Init();
    evaluator_ = std::make_unique<ExpressionEvaluator>(
        child_executor_->GetOutputSchema());
}
bool ProjectionExecutor::Next(Tuple* tuple, RID* rid) {
    auto* projection_plan = GetProjectionPlan();
    Tuple child_tuple;
    RID child_rid;
    if (!child_executor_->Next(&child_tuple, &child_rid)) {
        return false;
    }
    std::vector<Value> projected_values;
    const auto& expressions = projection_plan->GetExpressions();
    for (const auto& expr : expressions) {
        Value value = evaluator_->Evaluate(expr.get(), child_tuple);
        projected_values.push_back(value);
    }
    *tuple = Tuple(projected_values, GetOutputSchema());
    *rid = child_rid;
    return true;
}
}


========== ./src/execution/expression_cloner.cpp ==========
namespace SimpleRDBMS {
std::unique_ptr<Expression> ExpressionCloner::Clone(const Expression* expr) {
    if (!expr) {
        return nullptr;
    }
    switch (expr->GetType()) {
        case Expression::ExprType::CONSTANT:
            return CloneConstant(static_cast<const ConstantExpression*>(expr));
        case Expression::ExprType::COLUMN_REF:
            return CloneColumnRef(
                static_cast<const ColumnRefExpression*>(expr));
        case Expression::ExprType::BINARY_OP:
            return CloneBinaryOp(static_cast<const BinaryOpExpression*>(expr));
        case Expression::ExprType::UNARY_OP:
            return CloneUnaryOp(static_cast<const UnaryOpExpression*>(expr));
        default:
            return nullptr;
    }
}
std::unique_ptr<Expression> ExpressionCloner::CloneConstant(
    const ConstantExpression* expr) {
    return std::make_unique<ConstantExpression>(expr->GetValue());
}
std::unique_ptr<Expression> ExpressionCloner::CloneColumnRef(
    const ColumnRefExpression* expr) {
    return std::make_unique<ColumnRefExpression>(expr->GetTableName(),
                                                 expr->GetColumnName());
}
std::unique_ptr<Expression> ExpressionCloner::CloneBinaryOp(
    const BinaryOpExpression* expr) {
    auto left = Clone(expr->GetLeft());
    auto right = Clone(expr->GetRight());
    return std::make_unique<BinaryOpExpression>(
        std::move(left), expr->GetOperator(), std::move(right));
}
std::unique_ptr<Expression> ExpressionCloner::CloneUnaryOp(
    const UnaryOpExpression* expr) {
    auto operand = Clone(expr->GetOperand());
    return std::make_unique<UnaryOpExpression>(expr->GetOperator(),
                                               std::move(operand));
}
}


========== ./src/execution/expression_evaluator.cpp ==========
namespace SimpleRDBMS {
Value ExpressionEvaluator::Evaluate(const Expression* expr,
                                    const Tuple& tuple) {
    if (!expr) {
        throw ExecutionException("Null expression");
    }
    switch (expr->GetType()) {
        case Expression::ExprType::CONSTANT:
            return EvaluateConstant(
                static_cast<const ConstantExpression*>(expr), tuple);
        case Expression::ExprType::COLUMN_REF:
            return EvaluateColumnRef(
                static_cast<const ColumnRefExpression*>(expr), tuple);
        case Expression::ExprType::BINARY_OP:
            return EvaluateBinaryOp(
                static_cast<const BinaryOpExpression*>(expr), tuple);
        case Expression::ExprType::UNARY_OP:
            return EvaluateUnaryOp(static_cast<const UnaryOpExpression*>(expr),
                                   tuple);
        default:
            throw ExecutionException("Unsupported expression type");
    }
}
bool ExpressionEvaluator::EvaluateAsBoolean(const Expression* expr,
                                            const Tuple& tuple) {
    Value result = Evaluate(expr, tuple);
    bool bool_result = IsValueTrue(result);
    LOG_DEBUG("EvaluateAsBoolean: result = " << bool_result);
    return bool_result;
}
Value ExpressionEvaluator::EvaluateConstant(const ConstantExpression* expr,
                                            const Tuple& tuple) {
    (void)tuple;
    return expr->GetValue();
}
Value ExpressionEvaluator::EvaluateColumnRef(const ColumnRefExpression* expr,
                                             const Tuple& tuple) {
    const std::string& column_name = expr->GetColumnName();
    try {
        if (!schema_) {
            throw ExecutionException("Schema is null in expression evaluator");
        }
        size_t column_idx = schema_->GetColumnIdx(column_name);
        const auto& tuple_values = tuple.GetValues();
        if (column_idx >= tuple_values.size()) {
            LOG_ERROR("EvaluateColumnRef: Column index "
                      << column_idx << " out of range, tuple has "
                      << tuple_values.size() << " values");
            throw ExecutionException("Column index out of range: " +
                                     column_name);
        }
        return tuple.GetValue(column_idx);
    } catch (const std::exception& e) {
        throw ExecutionException("Column not found or invalid: " + column_name +
                                 " - " + e.what());
    }
}
Value ExpressionEvaluator::EvaluateBinaryOp(const BinaryOpExpression* expr,
                                            const Tuple& tuple) {
    Value left_val = Evaluate(expr->GetLeft(), tuple);
    BinaryOpExpression::OpType op = expr->GetOperator();
    if (op == BinaryOpExpression::OpType::AND) {
        if (!IsValueTrue(left_val)) {
            return Value(false);
        }
        Value right_val = Evaluate(expr->GetRight(), tuple);
        return Value(IsValueTrue(right_val));
    }
    if (op == BinaryOpExpression::OpType::OR) {
        if (IsValueTrue(left_val)) {
            return Value(true);
        }
        Value right_val = Evaluate(expr->GetRight(), tuple);
        return Value(IsValueTrue(right_val));
    }
    Value right_val = Evaluate(expr->GetRight(), tuple);
    if (op == BinaryOpExpression::OpType::PLUS ||
        op == BinaryOpExpression::OpType::MINUS ||
        op == BinaryOpExpression::OpType::MULTIPLY ||
        op == BinaryOpExpression::OpType::DIVIDE) {
        return EvaluateArithmeticOp(left_val, right_val, op);
    }
    bool result = CompareValues(left_val, right_val, op);
    return Value(result);
}
Value ExpressionEvaluator::EvaluateArithmeticOp(const Value& left,
                                                const Value& right,
                                                BinaryOpExpression::OpType op) {
    auto to_double = [](const Value& val) -> double {
        if (std::holds_alternative<int8_t>(val))
            return static_cast<double>(std::get<int8_t>(val));
        if (std::holds_alternative<int16_t>(val))
            return static_cast<double>(std::get<int16_t>(val));
        if (std::holds_alternative<int32_t>(val))
            return static_cast<double>(std::get<int32_t>(val));
        if (std::holds_alternative<int64_t>(val))
            return static_cast<double>(std::get<int64_t>(val));
        if (std::holds_alternative<float>(val))
            return static_cast<double>(std::get<float>(val));
        if (std::holds_alternative<double>(val)) return std::get<double>(val);
        throw ExecutionException(
            "Cannot convert value to numeric for arithmetic operation");
    };
    try {
        double left_num = to_double(left);
        double right_num = to_double(right);
        double result;
        switch (op) {
            case BinaryOpExpression::OpType::PLUS:
                result = left_num + right_num;
                break;
            case BinaryOpExpression::OpType::MINUS:
                result = left_num - right_num;
                break;
            case BinaryOpExpression::OpType::MULTIPLY:
                result = left_num * right_num;
                break;
            case BinaryOpExpression::OpType::DIVIDE:
                if (right_num == 0) {
                    throw ExecutionException("Division by zero");
                }
                result = left_num / right_num;
                break;
            default:
                throw ExecutionException("Unsupported arithmetic operator");
        }
        if ((std::holds_alternative<int32_t>(left) ||
             std::holds_alternative<int64_t>(left)) &&
            (std::holds_alternative<int32_t>(right) ||
             std::holds_alternative<int64_t>(right)) &&
            op != BinaryOpExpression::OpType::DIVIDE) {
            return Value(static_cast<int32_t>(result));
        } else {
            return Value(result);
        }
    } catch (const std::exception&) {
        throw ExecutionException("Type mismatch in arithmetic operation");
    }
}
Value ExpressionEvaluator::EvaluateUnaryOp(const UnaryOpExpression* expr,
                                           const Tuple& tuple) {
    Value operand_val = Evaluate(expr->GetOperand(), tuple);
    switch (expr->GetOperator()) {
        case UnaryOpExpression::OpType::NOT:
            return Value(!IsValueTrue(operand_val));
        case UnaryOpExpression::OpType::NEGATIVE:
            if (std::holds_alternative<int32_t>(operand_val)) {
                return Value(-std::get<int32_t>(operand_val));
            } else if (std::holds_alternative<int64_t>(operand_val)) {
                return Value(-std::get<int64_t>(operand_val));
            } else if (std::holds_alternative<float>(operand_val)) {
                return Value(-std::get<float>(operand_val));
            } else if (std::holds_alternative<double>(operand_val)) {
                return Value(-std::get<double>(operand_val));
            } else {
                throw ExecutionException(
                    "Cannot apply negative operator to non-numeric value");
            }
        default:
            throw ExecutionException("Unsupported unary operator");
    }
}
bool ExpressionEvaluator::CompareValues(const Value& left, const Value& right,
                                        BinaryOpExpression::OpType op) {
    if (left.index() == right.index()) {
        switch (left.index()) {
            case 0:
                return CompareNumeric(std::get<bool>(left),
                                      std::get<bool>(right), op);
            case 1:
                return CompareNumeric(std::get<int8_t>(left),
                                      std::get<int8_t>(right), op);
            case 2:
                return CompareNumeric(std::get<int16_t>(left),
                                      std::get<int16_t>(right), op);
            case 3:
                return CompareNumeric(std::get<int32_t>(left),
                                      std::get<int32_t>(right), op);
            case 4:
                return CompareNumeric(std::get<int64_t>(left),
                                      std::get<int64_t>(right), op);
            case 5:
                return CompareNumeric(std::get<float>(left),
                                      std::get<float>(right), op);
            case 6:
                return CompareNumeric(std::get<double>(left),
                                      std::get<double>(right), op);
            case 7:
                return CompareNumeric(std::get<std::string>(left),
                                      std::get<std::string>(right), op);
        }
    }
    auto safe_to_double = [](const Value& val) -> std::pair<bool, double> {
        try {
            if (std::holds_alternative<int8_t>(val))
                return {true, static_cast<double>(std::get<int8_t>(val))};
            if (std::holds_alternative<int16_t>(val))
                return {true, static_cast<double>(std::get<int16_t>(val))};
            if (std::holds_alternative<int32_t>(val))
                return {true, static_cast<double>(std::get<int32_t>(val))};
            if (std::holds_alternative<int64_t>(val))
                return {true, static_cast<double>(std::get<int64_t>(val))};
            if (std::holds_alternative<float>(val))
                return {true, static_cast<double>(std::get<float>(val))};
            if (std::holds_alternative<double>(val))
                return {true, std::get<double>(val)};
            return {false, 0.0};
        } catch (const std::bad_variant_access&) {
            return {false, 0.0};
        }
    };
    auto left_result = safe_to_double(left);
    auto right_result = safe_to_double(right);
    if (left_result.first && right_result.first) {
        return CompareNumeric(left_result.second, right_result.second, op);
    }
    throw ExecutionException(
        "Type mismatch in comparison - cannot convert operands to comparable "
        "types");
}
template <typename T>
bool ExpressionEvaluator::CompareNumeric(const T& left, const T& right,
                                         BinaryOpExpression::OpType op) {
    switch (op) {
        case BinaryOpExpression::OpType::EQUALS:
            return left == right;
        case BinaryOpExpression::OpType::NOT_EQUALS:
            return left != right;
        case BinaryOpExpression::OpType::LESS_THAN:
            return left < right;
        case BinaryOpExpression::OpType::LESS_EQUALS:
            return left <= right;
        case BinaryOpExpression::OpType::GREATER_THAN:
            return left > right;
        case BinaryOpExpression::OpType::GREATER_EQUALS:
            return left >= right;
        default:
            throw ExecutionException("Unsupported comparison operator");
    }
}
bool ExpressionEvaluator::IsValueTrue(const Value& value) {
    if (std::holds_alternative<bool>(value)) {
        return std::get<bool>(value);
    }
    if (std::holds_alternative<int32_t>(value)) {
        return std::get<int32_t>(value) != 0;
    }
    if (std::holds_alternative<int64_t>(value)) {
        return std::get<int64_t>(value) != 0;
    }
    if (std::holds_alternative<float>(value)) {
        return std::get<float>(value) != 0.0f;
    }
    if (std::holds_alternative<double>(value)) {
        return std::get<double>(value) != 0.0;
    }
    if (std::holds_alternative<std::string>(value)) {
        return !std::get<std::string>(value).empty();
    }
    return false;
}
}


========== ./src/index/b_plus_tree.cpp ==========
namespace SimpleRDBMS {
template <typename KeyType, typename ValueType>
BPlusTree<KeyType, ValueType>::BPlusTree(const std::string& name,
                                         BufferPoolManager* buffer_pool_manager)
    : index_name_(name),
      buffer_pool_manager_(buffer_pool_manager),
      root_page_id_(INVALID_PAGE_ID) {
    if (!buffer_pool_manager_) {
        throw std::invalid_argument("BufferPoolManager cannot be null");
    }
    if (index_name_.empty()) {
        throw std::invalid_argument("Index name cannot be empty");
    }
    LOG_DEBUG("Creating BPlusTree with name: " << index_name_);
    try {
        LoadRootPageId();
        LOG_DEBUG(
            "BPlusTree constructor completed, root_page_id: " << root_page_id_);
    } catch (const std::exception& e) {
        LOG_ERROR(
            "BPlusTree constructor failed to load root page ID: " << e.what());
        root_page_id_ = INVALID_PAGE_ID;
    }
}
template <typename KeyType, typename ValueType>
BPlusTree<KeyType, ValueType>::~BPlusTree() {
    try {
        std::lock_guard<std::mutex> lock(latch_);
        root_page_id_ = INVALID_PAGE_ID;
        LOG_DEBUG("BPlusTree destroyed: " << index_name_);
    } catch (const std::exception& e) {
        LOG_ERROR("BPlusTree destructor exception: " << e.what());
    } catch (...) {
        LOG_ERROR("BPlusTree destructor unknown exception");
    }
}
template <typename KeyType, typename ValueType>
void BPlusTree<KeyType, ValueType>::LoadRootPageId() {
    LOG_DEBUG("LoadRootPageId called for index: " << index_name_);
    int num_pages = buffer_pool_manager_->GetDiskManager()->GetNumPages();
    LOG_DEBUG("Disk has " << num_pages << " pages");
    if (num_pages <= 1) {
        LOG_DEBUG("Database too small, setting root_page_id to INVALID");
        root_page_id_ = INVALID_PAGE_ID;
        return;
    }
    page_id_t header_page_id = GetHeaderPageId();
    Page* header_page = buffer_pool_manager_->FetchPage(header_page_id);
    if (header_page == nullptr) {
        LOG_DEBUG("Header page " << header_page_id
                                 << " does not exist for index "
                                 << index_name_);
        root_page_id_ = INVALID_PAGE_ID;
        return;
    }
    uint32_t hash = 0;
    for (char c : index_name_) {
        hash = hash * 31 + static_cast<uint32_t>(c);
    }
    size_t slot_size = sizeof(page_id_t) + sizeof(uint32_t);
    size_t max_slots = (PAGE_SIZE - sizeof(uint32_t)) / slot_size;
    size_t slot_index = hash % max_slots;
    size_t offset = sizeof(uint32_t) + slot_index * slot_size;
    char* data = header_page->GetData();
    uint32_t stored_hash = *reinterpret_cast<uint32_t*>(data + offset);
    page_id_t stored_root_page_id =
        *reinterpret_cast<page_id_t*>(data + offset + sizeof(uint32_t));
    buffer_pool_manager_->UnpinPage(header_page_id, false);
    if (stored_hash != hash) {
        LOG_DEBUG("Hash mismatch for index " << index_name_
                                             << ", tree is empty");
        root_page_id_ = INVALID_PAGE_ID;
        return;
    }
    if (stored_root_page_id == INVALID_PAGE_ID ||
        stored_root_page_id >= num_pages) {
        LOG_DEBUG("Invalid stored root page ID "
                  << stored_root_page_id << " for index " << index_name_);
        root_page_id_ = INVALID_PAGE_ID;
        return;
    }
    Page* root_page = buffer_pool_manager_->FetchPage(stored_root_page_id);
    if (root_page == nullptr) {
        LOG_WARN("Root page " << stored_root_page_id
                              << " does not exist, resetting to INVALID");
        root_page_id_ = INVALID_PAGE_ID;
        return;
    }
    auto tree_page = reinterpret_cast<BPlusTreePage*>(root_page->GetData());
    IndexPageType page_type = tree_page->GetPageType();
    if (page_type != IndexPageType::LEAF_PAGE &&
        page_type != IndexPageType::INTERNAL_PAGE) {
        LOG_ERROR("Root page "
                  << stored_root_page_id
                  << " has invalid page type: " << static_cast<int>(page_type));
        buffer_pool_manager_->UnpinPage(stored_root_page_id, false);
        root_page_id_ = INVALID_PAGE_ID;
        return;
    }
    buffer_pool_manager_->UnpinPage(stored_root_page_id, false);
    root_page_id_ = stored_root_page_id;
    LOG_DEBUG("Successfully loaded root page ID: "
              << root_page_id_ << " for index: " << index_name_);
}
template <typename KeyType, typename ValueType>
page_id_t BPlusTree<KeyType, ValueType>::GetHeaderPageId() const {
    return 1;
}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::Insert(const KeyType& key,
                                           const ValueType& value,
                                           txn_id_t txn_id) {
    std::lock_guard<std::mutex> lock(latch_);
    (void)txn_id;
    LOG_TRACE("Inserting key: " << key << " into index: " << index_name_);
    if (root_page_id_ == INVALID_PAGE_ID) {
        LOG_DEBUG(
            "Creating root page for first insertion in index: " << index_name_);
        page_id_t header_page_id = GetHeaderPageId();
        Page* header_page = buffer_pool_manager_->FetchPage(header_page_id);
        if (header_page == nullptr) {
            page_id_t new_page_id;
            Page* root_page = buffer_pool_manager_->NewPage(&new_page_id);
            if (root_page == nullptr) {
                LOG_ERROR("Failed to create root page");
                return false;
            }
            LOG_DEBUG("Allocated root page with ID: " << new_page_id);
            auto root =
                reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
                    root_page->GetData());
            LOG_DEBUG("Initializing root page...");
            root->Init(new_page_id);
            if (root->GetPageId() != new_page_id) {
                LOG_WARN("Root page ID not set correctly, fixing...");
                root->SetPageId(new_page_id);
            }
            LOG_DEBUG("Inserting key " << key << " into root page...");
            if (!root->Insert(key, value)) {
                LOG_ERROR("Failed to insert into empty root");
                buffer_pool_manager_->UnpinPage(new_page_id, false);
                buffer_pool_manager_->DeletePage(new_page_id);
                return false;
            }
            root_page_id_ = new_page_id;
            LOG_DEBUG("Setting root_page_id_ to: " << root_page_id_);
            UpdateRootPageId(root_page_id_);
            root_page->SetDirty(true);
            LOG_DEBUG("Unpinning root page...");
            buffer_pool_manager_->UnpinPage(new_page_id, true);
            buffer_pool_manager_->FlushPage(new_page_id);
            LOG_DEBUG("Created root page and inserted key: "
                      << key << ", root_page_id: " << root_page_id_);
            return true;
        } else {
            buffer_pool_manager_->UnpinPage(header_page_id, false);
        }
        page_id_t new_page_id;
        Page* root_page = buffer_pool_manager_->NewPage(&new_page_id);
        if (root_page == nullptr) {
            LOG_ERROR("Failed to create root page");
            return false;
        }
        LOG_DEBUG("Allocated root page with ID: " << new_page_id);
        auto root = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
            root_page->GetData());
        LOG_DEBUG("Initializing root page...");
        root->Init(new_page_id);
        if (root->GetPageId() != new_page_id) {
            LOG_WARN("Root page ID not set correctly, fixing...");
            root->SetPageId(new_page_id);
        }
        LOG_DEBUG("Inserting key " << key << " into root page...");
        if (!root->Insert(key, value)) {
            LOG_ERROR("Failed to insert into empty root");
            buffer_pool_manager_->UnpinPage(new_page_id, false);
            buffer_pool_manager_->DeletePage(new_page_id);
            return false;
        }
        root_page_id_ = new_page_id;
        LOG_DEBUG("Setting root_page_id_ to: " << root_page_id_);
        UpdateRootPageId(root_page_id_);
        root_page->SetDirty(true);
        LOG_DEBUG("Unpinning root page...");
        buffer_pool_manager_->UnpinPage(new_page_id, true);
        buffer_pool_manager_->FlushPage(new_page_id);
        buffer_pool_manager_->FlushPage(header_page_id);
        LOG_DEBUG("Created root page and inserted key: "
                  << key << ", root_page_id: " << root_page_id_);
        return true;
    }
    Page* leaf_page = FindLeafPage(key, true);
    if (leaf_page == nullptr) {
        LOG_ERROR("Failed to find leaf page for key: " << key);
        return false;
    }
    auto leaf = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
        leaf_page->GetData());
    page_id_t leaf_page_id = leaf_page->GetPageId();
    bool result = InsertIntoLeaf(key, value, leaf);
    if (result) {
        leaf_page->SetDirty(true);
    }
    buffer_pool_manager_->UnpinPage(leaf_page_id, result);
    if (result) {
        LOG_TRACE("Successfully inserted key: " << key);
    } else {
        LOG_ERROR("Failed to insert key: " << key);
    }
    return result;
}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::Remove(const KeyType& key,
                                           txn_id_t txn_id) {
    std::lock_guard<std::mutex> lock(latch_);
    (void)txn_id;
    if (root_page_id_ == INVALID_PAGE_ID) {
        LOG_DEBUG("Tree is empty, cannot remove key: " << key);
        return false;
    }
    LOG_DEBUG("Removing key: " << key);
    Page* leaf_page = FindLeafPage(key, true);
    if (leaf_page == nullptr) {
        LOG_DEBUG("Failed to find leaf page for key: " << key);
        return false;
    }
    auto leaf = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
        leaf_page->GetData());
    page_id_t leaf_page_id = leaf_page->GetPageId();
    bool result = leaf->Delete(key);
    if (result) {
        LOG_DEBUG("Successfully deleted key from leaf: " << key);
        leaf_page->SetDirty(true);
        bool node_deleted = false;
        if (ShouldCoalesceOrRedistribute(leaf)) {
            LOG_DEBUG("Leaf requires coalesce/redistribute after deletion");
            node_deleted = CoalesceOrRedistribute(leaf, txn_id);
        }
        if (!node_deleted) {
            buffer_pool_manager_->UnpinPage(leaf_page_id, true);
        }
    } else {
        LOG_DEBUG("Key not found in leaf: " << key);
        buffer_pool_manager_->UnpinPage(leaf_page_id, false);
    }
    return result;
}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::GetValue(const KeyType& key,
                                             ValueType* value,
                                             txn_id_t txn_id) {
    std::lock_guard<std::mutex> lock(latch_);
    (void)txn_id;
    if (root_page_id_ == INVALID_PAGE_ID) {
        return false;
    }
    Page* leaf_page = FindLeafPage(key, false);
    if (leaf_page == nullptr) {
        return false;
    }
    auto leaf = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
        leaf_page->GetData());
    int index = leaf->KeyIndex(key);
    bool found = (index < leaf->GetSize() && leaf->KeyAt(index) == key);
    if (found) {
        *value = leaf->ValueAt(index);
    }
    buffer_pool_manager_->UnpinPage(leaf_page->GetPageId(), false);
    return found;
}
template <typename KeyType, typename ValueType>
typename BPlusTree<KeyType, ValueType>::Iterator
BPlusTree<KeyType, ValueType>::Begin() {
    std::lock_guard<std::mutex> lock(latch_);
    if (root_page_id_ == INVALID_PAGE_ID) {
        return End();
    }
    page_id_t current_page_id = root_page_id_;
    while (true) {
        Page* page = buffer_pool_manager_->FetchPage(current_page_id);
        if (page == nullptr) {
            return End();
        }
        auto tree_page = reinterpret_cast<BPlusTreePage*>(page->GetData());
        if (tree_page->IsLeafPage()) {
            auto leaf =
                reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
                    page->GetData());
            if (leaf->GetSize() == 0) {
                buffer_pool_manager_->UnpinPage(current_page_id, false);
                return End();
            }
            buffer_pool_manager_->UnpinPage(current_page_id, false);
            return Iterator(this, current_page_id, 0);
        }
        auto internal =
            reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(page->GetData());
        page_id_t next_page_id = internal->ValueAt(0);
        buffer_pool_manager_->UnpinPage(current_page_id, false);
        current_page_id = next_page_id;
    }
}
template <typename KeyType, typename ValueType>
typename BPlusTree<KeyType, ValueType>::Iterator
BPlusTree<KeyType, ValueType>::Begin(const KeyType& key) {
    std::lock_guard<std::mutex> lock(latch_);
    if (root_page_id_ == INVALID_PAGE_ID) {
        return End();
    }
    Page* leaf_page = FindLeafPage(key, false);
    if (leaf_page == nullptr) {
        return End();
    }
    auto leaf = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
        leaf_page->GetData());
    int index = leaf->KeyIndex(key);
    page_id_t page_id = leaf_page->GetPageId();
    buffer_pool_manager_->UnpinPage(page_id, false);
    return Iterator(this, page_id, index);
}
template <typename KeyType, typename ValueType>
typename BPlusTree<KeyType, ValueType>::Iterator
BPlusTree<KeyType, ValueType>::End() {
    return Iterator(this, INVALID_PAGE_ID, 0);
}
template <typename KeyType, typename ValueType>
Page* BPlusTree<KeyType, ValueType>::FindLeafPage(const KeyType& key,
                                                  bool is_write_op) {
    (void)is_write_op;
    if (root_page_id_ == INVALID_PAGE_ID) {
        LOG_DEBUG("Tree is empty, root_page_id is invalid");
        return nullptr;
    }
    LOG_DEBUG("FindLeafPage: starting from root page " << root_page_id_);
    page_id_t current_page_id = root_page_id_;
    Page* current_page = nullptr;
    std::unordered_set<page_id_t> visited_pages;
    const int MAX_TREE_DEPTH = 20;
    int depth = 0;
    while (true) {
        if (visited_pages.count(current_page_id) > 0) {
            LOG_ERROR(
                "FindLeafPage: Detected cycle in B+tree traversal at page "
                << current_page_id);
            if (current_page != nullptr) {
                buffer_pool_manager_->UnpinPage(current_page->GetPageId(),
                                                false);
            }
            return nullptr;
        }
        if (depth >= MAX_TREE_DEPTH) {
            LOG_ERROR("FindLeafPage: Tree depth exceeded maximum limit "
                      << MAX_TREE_DEPTH);
            if (current_page != nullptr) {
                buffer_pool_manager_->UnpinPage(current_page->GetPageId(),
                                                false);
            }
            return nullptr;
        }
        visited_pages.insert(current_page_id);
        depth++;
        if (current_page != nullptr) {
            buffer_pool_manager_->UnpinPage(current_page->GetPageId(), false);
        }
        LOG_TRACE("FindLeafPage: fetching page " << current_page_id
                                                 << " at depth " << depth);
        current_page = buffer_pool_manager_->FetchPage(current_page_id);
        if (current_page == nullptr) {
            LOG_ERROR("Failed to fetch page: "
                      << current_page_id << " (num_pages="
                      << buffer_pool_manager_->GetDiskManager()->GetNumPages()
                      << ")");
            return nullptr;
        }
        auto tree_page =
            reinterpret_cast<BPlusTreePage*>(current_page->GetData());
        if (tree_page->GetPageId() != current_page_id) {
            LOG_ERROR("Page " << current_page_id
                              << " has inconsistent page_id: "
                              << tree_page->GetPageId());
            buffer_pool_manager_->UnpinPage(current_page_id, false);
            return nullptr;
        }
        if (tree_page->IsLeafPage()) {
            LOG_TRACE("Found leaf page: " << current_page_id << " at depth "
                                          << depth);
            return current_page;
        }
        auto internal = reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(
            current_page->GetData());
        if (internal->GetSize() <= 0 ||
            internal->GetSize() > internal->GetMaxSize()) {
            LOG_ERROR("Invalid internal page size: "
                      << internal->GetSize() << " on page " << current_page_id);
            buffer_pool_manager_->UnpinPage(current_page_id, false);
            return nullptr;
        }
        int index = internal->KeyIndex(key);
        if (index < 0) {
            LOG_ERROR("Invalid index returned by KeyIndex: " << index);
            index = 0;
        }
        if (index > internal->GetSize()) {
            LOG_ERROR("Index too large: " << index
                                          << ", size: " << internal->GetSize());
            index = internal->GetSize();
        }
        page_id_t next_page_id = internal->ValueAt(index);
        LOG_TRACE("Traversing from page " << current_page_id << " to page "
                                          << next_page_id << " at index "
                                          << index);
        if (next_page_id == INVALID_PAGE_ID) {
            LOG_ERROR("Invalid next page ID in internal page");
            buffer_pool_manager_->UnpinPage(current_page_id, false);
            return nullptr;
        }
        if (next_page_id >=
            buffer_pool_manager_->GetDiskManager()->GetNumPages()) {
            LOG_ERROR("Next page ID " << next_page_id
                                      << " exceeds database size");
            buffer_pool_manager_->UnpinPage(current_page_id, false);
            return nullptr;
        }
        current_page_id = next_page_id;
    }
}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::InsertIntoLeaf(
    const KeyType& key, const ValueType& value,
    BPlusTreeLeafPage<KeyType, ValueType>* leaf) {
    int index = leaf->KeyIndex(key);
    if (index < leaf->GetSize() && leaf->KeyAt(index) == key) {
        leaf->SetValueAt(index, value);
        return true;
    }
    if (leaf->GetSize() < leaf->GetMaxSize()) {
        return leaf->Insert(key, value);
    }
    LOG_DEBUG("Leaf page is full, need to split. Size: "
              << leaf->GetSize() << ", MaxSize: " << leaf->GetMaxSize());
    page_id_t new_page_id;
    Page* new_page = buffer_pool_manager_->NewPage(&new_page_id);
    if (new_page == nullptr) {
        LOG_ERROR("Failed to allocate new page for split");
        return false;
    }
    auto new_leaf = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
        new_page->GetData());
    new_leaf->Init(new_page_id, leaf->GetParentPageId());
    const int total_entries = leaf->GetSize() + 1;
    std::vector<std::pair<KeyType, ValueType>> temp_entries;
    temp_entries.reserve(total_entries);
    bool inserted = false;
    for (int i = 0; i < leaf->GetSize(); i++) {
        KeyType current_key = leaf->KeyAt(i);
        ValueType current_value = leaf->ValueAt(i);
        if (!inserted && key < current_key) {
            temp_entries.emplace_back(key, value);
            inserted = true;
        }
        temp_entries.emplace_back(current_key, current_value);
    }
    if (!inserted) {
        temp_entries.emplace_back(key, value);
    }
    int split_point = total_entries / 2;
    leaf->SetSize(0);
    for (int i = 0; i < split_point; i++) {
        leaf->SetKeyAt(i, temp_entries[i].first);
        leaf->SetValueAt(i, temp_entries[i].second);
    }
    leaf->SetSize(split_point);
    for (int i = split_point; i < total_entries; i++) {
        new_leaf->SetKeyAt(i - split_point, temp_entries[i].first);
        new_leaf->SetValueAt(i - split_point, temp_entries[i].second);
    }
    new_leaf->SetSize(total_entries - split_point);
    new_leaf->SetNextPageId(leaf->GetNextPageId());
    leaf->SetNextPageId(new_page_id);
    KeyType middle_key;
    if (new_leaf->GetSize() > 0) {
        middle_key = new_leaf->KeyAt(0);
    } else {
        LOG_ERROR("New leaf node has no elements after split");
        buffer_pool_manager_->UnpinPage(new_page_id, false);
        buffer_pool_manager_->DeletePage(new_page_id);
        return false;
    }
    LOG_DEBUG("Split completed, middle key: " << middle_key);
    new_page->SetDirty(true);
    InsertIntoParent(leaf, middle_key, new_leaf);
    buffer_pool_manager_->UnpinPage(new_page_id, true);
    buffer_pool_manager_->FlushPage(new_page_id);
    return true;
}
template <typename KeyType, typename ValueType>
template <typename N>
bool BPlusTree<KeyType, ValueType>::Split(N* node) {
    LOG_ERROR(
        "Split function called - this should be handled by InsertIntoLeaf");
    return false;
}
template <typename KeyType, typename ValueType>
void BPlusTree<KeyType, ValueType>::InsertIntoParent(BPlusTreePage* old_node,
                                                     const KeyType& key,
                                                     BPlusTreePage* new_node) {
    if (old_node->IsRootPage()) {
        page_id_t new_root_id;
        Page* new_root_page = buffer_pool_manager_->NewPage(&new_root_id);
        if (new_root_page == nullptr) {
            LOG_ERROR("Failed to create new root page");
            return;
        }
        auto new_root = reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(
            new_root_page->GetData());
        new_root->Init(new_root_id);
        new_root->SetValueAt(0, old_node->GetPageId());
        new_root->SetKeyAt(1, key);
        new_root->SetValueAt(1, new_node->GetPageId());
        new_root->SetSize(1);
        old_node->SetParentPageId(new_root_id);
        new_node->SetParentPageId(new_root_id);
        root_page_id_ = new_root_id;
        UpdateRootPageId(root_page_id_);
        new_root_page->SetDirty(true);
        buffer_pool_manager_->UnpinPage(new_root_id, true);
        buffer_pool_manager_->FlushPage(new_root_id);
        LOG_DEBUG("Created new root page: " << new_root_id);
        return;
    }
    Page* parent_page =
        buffer_pool_manager_->FetchPage(old_node->GetParentPageId());
    if (parent_page == nullptr) {
        LOG_ERROR("Failed to fetch parent page");
        return;
    }
    auto parent = reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(
        parent_page->GetData());
    page_id_t parent_page_id = parent_page->GetPageId();
    if (parent->GetSize() < parent->GetMaxSize()) {
        parent->InsertNodeAfter(old_node->GetPageId(), key,
                                new_node->GetPageId());
        new_node->SetParentPageId(parent->GetPageId());
        parent_page->SetDirty(true);
        buffer_pool_manager_->UnpinPage(parent_page_id, true);
        buffer_pool_manager_->FlushPage(parent_page_id);
        LOG_DEBUG("Inserted into parent page successfully");
    } else {
        try {
            parent->InsertNodeAfter(old_node->GetPageId(), key,
                                    new_node->GetPageId());
            new_node->SetParentPageId(parent->GetPageId());
            if (parent->GetSize() > parent->GetMaxSize()) {
                LOG_DEBUG("Parent page needs splitting after insertion");
                page_id_t new_parent_page_id;
                Page* new_parent_page =
                    buffer_pool_manager_->NewPage(&new_parent_page_id);
                if (new_parent_page != nullptr) {
                    auto new_parent =
                        reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(
                            new_parent_page->GetData());
                    new_parent->Init(new_parent_page_id,
                                     parent->GetParentPageId());
                    parent->MoveHalfTo(new_parent, buffer_pool_manager_);
                    KeyType middle_key_to_promote;
                    if (new_parent->GetSize() > 0) {
                        middle_key_to_promote = new_parent->KeyAt(1);
                        for (int i = 1; i < new_parent->GetSize(); i++) {
                            new_parent->SetKeyAt(i, new_parent->KeyAt(i + 1));
                        }
                        new_parent->IncreaseSize(-1);
                        InsertIntoParent(parent, middle_key_to_promote,
                                         new_parent);
                    }
                    new_parent_page->SetDirty(true);
                    buffer_pool_manager_->UnpinPage(new_parent_page_id, true);
                    buffer_pool_manager_->FlushPage(new_parent_page_id);
                }
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Exception during parent insertion: " << e.what());
        }
        parent_page->SetDirty(true);
        buffer_pool_manager_->UnpinPage(parent_page_id, true);
        buffer_pool_manager_->FlushPage(parent_page_id);
    }
}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::ShouldCoalesceOrRedistribute(
    BPlusTreePage* node) {
    if (node->IsRootPage()) {
        return node->GetSize() == 0;
    }
    return node->GetSize() < (node->GetMaxSize() + 1) / 2;
}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::CoalesceOrRedistribute(BPlusTreePage* node,
                                                           txn_id_t txn_id) {
    if (node->IsRootPage()) {
        return AdjustRoot(node);
    }
    Page* parent_page =
        buffer_pool_manager_->FetchPage(node->GetParentPageId());
    if (parent_page == nullptr) {
        return false;
    }
    auto parent = reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(
        parent_page->GetData());
    int node_index = parent->ValueIndex(node->GetPageId());
    if (node_index == -1) {
        buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), false);
        return false;
    }
    int sibling_index = (node_index == 0) ? 1 : node_index - 1;
    if (sibling_index > parent->GetSize()) {
        buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), false);
        return false;
    }
    page_id_t sibling_page_id = parent->ValueAt(sibling_index);
    Page* sibling_page = buffer_pool_manager_->FetchPage(sibling_page_id);
    if (sibling_page == nullptr) {
        buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), false);
        return false;
    }
    auto sibling = reinterpret_cast<BPlusTreePage*>(sibling_page->GetData());
    bool node_deleted = false;
    if (node->GetSize() + sibling->GetSize() < node->GetMaxSize()) {
        bool is_predecessor = sibling_index < node_index;
        node_deleted =
            Coalesce(&sibling, &node, &parent,
                     is_predecessor ? sibling_index + 1 : node_index, txn_id);
        parent_page->SetDirty(true);
        sibling_page->SetDirty(true);
        buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), true);
        buffer_pool_manager_->UnpinPage(sibling_page_id, true);
    } else {
        Redistribute(sibling, node, node_index);
        parent_page->SetDirty(true);
        sibling_page->SetDirty(true);
        buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), true);
        buffer_pool_manager_->UnpinPage(sibling_page_id, true);
    }
    return node_deleted;
}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::AdjustRoot(BPlusTreePage* old_root_node) {
    if (old_root_node->GetSize() > 0) {
        return false;
    }
    if (!old_root_node->IsLeafPage()) {
        auto root =
            reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(old_root_node);
        page_id_t new_root_id = root->ValueAt(0);
        if (new_root_id != INVALID_PAGE_ID) {
            Page* new_root_page = buffer_pool_manager_->FetchPage(new_root_id);
            if (new_root_page != nullptr) {
                auto new_root =
                    reinterpret_cast<BPlusTreePage*>(new_root_page->GetData());
                new_root->SetParentPageId(INVALID_PAGE_ID);
                new_root_page->SetDirty(true);
                buffer_pool_manager_->UnpinPage(new_root_id, true);
            }
            root_page_id_ = new_root_id;
        } else {
            root_page_id_ = INVALID_PAGE_ID;
        }
    } else {
        root_page_id_ = INVALID_PAGE_ID;
    }
    UpdateRootPageId(root_page_id_);
    return true;
}
template <typename KeyType, typename ValueType>
template <typename N>
bool BPlusTree<KeyType, ValueType>::Coalesce(
    N** neighbor_node, N** node, BPlusTreeInternalPage<KeyType>** parent,
    int index, txn_id_t txn_id) {
    auto neighbor = *neighbor_node;
    auto n = *node;
    auto p = *parent;
    if (index == 0) {
        std::swap(neighbor, n);
        index = 1;
    }
    page_id_t node_page_id = n->GetPageId();
    KeyType middle_key = p->KeyAt(index);
    LOG_DEBUG("Coalescing: merging page " << node_page_id
                                          << " into its neighbor");
    if (n->IsLeafPage()) {
        auto leaf_neighbor =
            reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(neighbor);
        auto leaf_node =
            reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(n);
        leaf_node->MoveAllTo(leaf_neighbor);
        leaf_neighbor->SetNextPageId(leaf_node->GetNextPageId());
    } else {
        auto internal_neighbor =
            reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(neighbor);
        auto internal_node =
            reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(n);
        internal_node->MoveAllTo(internal_neighbor, middle_key,
                                 buffer_pool_manager_);
    }
    p->Remove(index);
    if (ShouldCoalesceOrRedistribute(p)) {
        CoalesceOrRedistribute(p, txn_id);
    }
    LOG_DEBUG("Deleting merged page " << node_page_id);
    bool delete_success = buffer_pool_manager_->DeletePage(node_page_id);
    if (!delete_success) {
        LOG_ERROR("Failed to delete page " << node_page_id
                                           << " during coalesce operation");
    }
    return true;
}
template <typename KeyType, typename ValueType>
template <typename N>
void BPlusTree<KeyType, ValueType>::Redistribute(N* neighbor_node, N* node,
                                                 int index) {
    auto parent_page = buffer_pool_manager_->FetchPage(node->GetParentPageId());
    if (parent_page == nullptr) {
        return;
    }
    auto parent = reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(
        parent_page->GetData());
    if (node->IsLeafPage()) {
        auto leaf_node =
            reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(node);
        auto leaf_neighbor =
            reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
                neighbor_node);
        if (index == 0) {
            leaf_neighbor->MoveFirstToEndOf(leaf_node);
            parent->SetKeyAt(1, leaf_neighbor->KeyAt(0));
        } else {
            leaf_neighbor->MoveLastToFrontOf(leaf_node);
            parent->SetKeyAt(index, leaf_node->KeyAt(0));
        }
    } else {
        auto internal_node =
            reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(node);
        auto internal_neighbor =
            reinterpret_cast<BPlusTreeInternalPage<KeyType>*>(neighbor_node);
        if (index == 0) {
            KeyType middle_key = parent->KeyAt(1);
            internal_neighbor->MoveFirstToEndOf(internal_node, middle_key,
                                                buffer_pool_manager_);
            parent->SetKeyAt(1, internal_neighbor->KeyAt(1));
        } else {
            KeyType middle_key = parent->KeyAt(index);
            internal_neighbor->MoveLastToFrontOf(internal_node, middle_key,
                                                 buffer_pool_manager_);
            parent->SetKeyAt(index, internal_node->KeyAt(1));
        }
    }
    buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), true);
}
template <typename KeyType, typename ValueType>
void BPlusTree<KeyType, ValueType>::UpdateRootPageId(page_id_t root_page_id) {
    LOG_DEBUG("UpdateRootPageId called with root_page_id: "
              << root_page_id << " for index: " << index_name_);
    page_id_t header_page_id = GetHeaderPageId();
    Page* header_page = buffer_pool_manager_->FetchPage(header_page_id);
    if (header_page == nullptr) {
        LOG_DEBUG("Header page " << header_page_id
                                 << " does not exist, creating it...");
        page_id_t allocated_page_id;
        header_page = buffer_pool_manager_->NewPage(&allocated_page_id);
        if (header_page == nullptr) {
            LOG_ERROR("Failed to create header page");
            return;
        }
        if (allocated_page_id != header_page_id) {
            LOG_WARN("UpdateRootPageId: Expected header page "
                     << header_page_id << " but got " << allocated_page_id);
        }
        LOG_DEBUG("Created header page with ID: " << allocated_page_id);
        std::memset(header_page->GetData(), 0, PAGE_SIZE);
    }
    uint32_t hash = 0;
    for (char c : index_name_) {
        hash = hash * 31 + static_cast<uint32_t>(c);
    }
    size_t slot_size = sizeof(page_id_t) + sizeof(uint32_t);
    size_t max_slots =
        (PAGE_SIZE - sizeof(uint32_t)) / slot_size;
    size_t slot_index = hash % max_slots;
    size_t offset = sizeof(uint32_t) + slot_index * slot_size;
    char* data = header_page->GetData();
    *reinterpret_cast<uint32_t*>(data + offset) = hash;
    *reinterpret_cast<page_id_t*>(data + offset + sizeof(uint32_t)) =
        root_page_id;
    header_page->SetDirty(true);
    buffer_pool_manager_->UnpinPage(header_page->GetPageId(), true);
    buffer_pool_manager_->FlushPage(header_page->GetPageId());
    LOG_DEBUG("Updated header page with root page ID: "
              << root_page_id << " for index: " << index_name_ << " at slot "
              << slot_index);
}
template <typename KeyType, typename ValueType>
BPlusTree<KeyType, ValueType>::Iterator::Iterator(BPlusTree* tree,
                                                  page_id_t page_id, int index)
    : tree_(tree), current_page_id_(page_id), current_index_(index) {}
template <typename KeyType, typename ValueType>
bool BPlusTree<KeyType, ValueType>::Iterator::IsEnd() const {
    return current_page_id_ == INVALID_PAGE_ID;
}
template <typename KeyType, typename ValueType>
std::pair<KeyType, ValueType>
BPlusTree<KeyType, ValueType>::Iterator::operator*() {
    if (IsEnd()) {
        throw std::runtime_error("Iterator is at end");
    }
    Page* page = tree_->buffer_pool_manager_->FetchPage(current_page_id_);
    if (page == nullptr) {
        throw std::runtime_error("Failed to fetch page");
    }
    auto leaf = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
        page->GetData());
    if (current_index_ >= leaf->GetSize() || current_index_ < 0) {
        tree_->buffer_pool_manager_->UnpinPage(current_page_id_, false);
        throw std::runtime_error("Iterator index out of range");
    }
    KeyType key = leaf->KeyAt(current_index_);
    ValueType value = leaf->ValueAt(current_index_);
    tree_->buffer_pool_manager_->UnpinPage(current_page_id_, false);
    return std::make_pair(key, value);
}
template <typename KeyType, typename ValueType>
void BPlusTree<KeyType, ValueType>::Iterator::operator++() {
    if (IsEnd()) {
        return;
    }
    Page* page = tree_->buffer_pool_manager_->FetchPage(current_page_id_);
    if (page == nullptr) {
        current_page_id_ = INVALID_PAGE_ID;
        return;
    }
    auto leaf = reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
        page->GetData());
    current_index_++;
    if (current_index_ >= leaf->GetSize()) {
        page_id_t next_page_id = leaf->GetNextPageId();
        tree_->buffer_pool_manager_->UnpinPage(current_page_id_, false);
        if (next_page_id == INVALID_PAGE_ID) {
            current_page_id_ = INVALID_PAGE_ID;
            current_index_ = 0;
        } else {
            current_page_id_ = next_page_id;
            current_index_ = 0;
            Page* next_page =
                tree_->buffer_pool_manager_->FetchPage(next_page_id);
            if (next_page == nullptr) {
                current_page_id_ = INVALID_PAGE_ID;
            } else {
                auto next_leaf =
                    reinterpret_cast<BPlusTreeLeafPage<KeyType, ValueType>*>(
                        next_page->GetData());
                if (next_leaf->GetSize() == 0) {
                    current_page_id_ = INVALID_PAGE_ID;
                }
                tree_->buffer_pool_manager_->UnpinPage(next_page_id, false);
            }
        }
    } else {
        tree_->buffer_pool_manager_->UnpinPage(current_page_id_, false);
    }
}
template class BPlusTree<int32_t, RID>;
template class BPlusTree<int64_t, RID>;
template class BPlusTree<float, RID>;
template class BPlusTree<double, RID>;
template class BPlusTree<std::string, RID>;
}


========== ./src/index/b_plus_tree_page.cpp ==========
namespace SimpleRDBMS {
template <typename KeyType, typename ValueType>
void BPlusTreeLeafPage<KeyType, ValueType>::Init(page_id_t page_id,
                                                 page_id_t parent_id) {
    SetPageType(IndexPageType::LEAF_PAGE);
    SetPageId(page_id);
    SetParentPageId(parent_id);
    SetSize(0);
    size_t header_size = sizeof(BPlusTreePage) + sizeof(next_page_id_);
    size_t available_space = PAGE_SIZE - header_size;
    size_t pair_size = sizeof(KeyType) + sizeof(ValueType);
    int theoretical_max = static_cast<int>(available_space / pair_size);
    SetMaxSize(std::max(16, theoretical_max - 1));
    next_page_id_ = INVALID_PAGE_ID;
}
void BPlusTreePage::SetSize(int size) {
    if (size < 0) {
        LOG_ERROR("BPlusTreePage::SetSize: Attempting to set negative size "
                  << size);
        size_ = 0;
    } else {
        size_ = size;
    }
}
void BPlusTreePage::IncreaseSize(int amount) {
    int new_size = size_ + amount;
    if (new_size < 0) {
        LOG_ERROR("BPlusTreePage::IncreaseSize: Size would become negative: "
                  << size_ << " + " << amount << " = " << new_size);
        size_ = 0;
    } else {
        size_ = new_size;
    }
}
template <typename KeyType, typename ValueType>
KeyType BPlusTreeLeafPage<KeyType, ValueType>::KeyAt(int index) const {
    if (index < 0 || index >= GetSize()) {
        throw std::out_of_range("Index out of range");
    }
    char* data_ptr = const_cast<char*>(data_);
    size_t offset = index * (sizeof(KeyType) + sizeof(ValueType));
    return *reinterpret_cast<KeyType*>(data_ptr + offset);
}
template <typename KeyType, typename ValueType>
ValueType BPlusTreeLeafPage<KeyType, ValueType>::ValueAt(int index) const {
    if (index < 0 || index >= GetSize()) {
        throw std::out_of_range("Index out of range");
    }
    char* data_ptr = const_cast<char*>(data_);
    size_t offset =
        index * (sizeof(KeyType) + sizeof(ValueType)) + sizeof(KeyType);
    return *reinterpret_cast<ValueType*>(data_ptr + offset);
}
template <typename KeyType, typename ValueType>
void BPlusTreeLeafPage<KeyType, ValueType>::SetKeyAt(int index,
                                                     const KeyType& key) {
    if (index < 0 || index >= GetMaxSize()) {
        throw std::out_of_range("Index out of range");
    }
    size_t offset = index * (sizeof(KeyType) + sizeof(ValueType));
    *reinterpret_cast<KeyType*>(data_ + offset) = key;
}
template <typename KeyType, typename ValueType>
void BPlusTreeLeafPage<KeyType, ValueType>::SetValueAt(int index,
                                                       const ValueType& value) {
    if (index < 0 || index >= GetMaxSize()) {
        throw std::out_of_range("Index out of range");
    }
    size_t offset =
        index * (sizeof(KeyType) + sizeof(ValueType)) + sizeof(KeyType);
    *reinterpret_cast<ValueType*>(data_ + offset) = value;
}
template <typename KeyType, typename ValueType>
int BPlusTreeLeafPage<KeyType, ValueType>::KeyIndex(const KeyType& key) const {
    if (GetSize() == 0) {
        return 0;
    }
    int left = 0, right = GetSize();
    while (left < right) {
        int mid = left + (right - left) / 2;
        KeyType mid_key = KeyAt(mid);
        if (mid_key < key) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
template <typename KeyType>
int BPlusTreeInternalPage<KeyType>::KeyIndex(const KeyType& key) const {
    int size = GetSize();
    if (size <= 0) {
        LOG_WARN("BPlusTreeInternalPage::KeyIndex: Invalid size " << size);
        return 0;
    }
    const int MAX_REASONABLE_SIZE = (PAGE_SIZE - sizeof(BPlusTreePage)) /
                                    (sizeof(KeyType) + sizeof(page_id_t));
    if (size > MAX_REASONABLE_SIZE) {
        LOG_ERROR("BPlusTreeInternalPage::KeyIndex: Size "
                  << size << " exceeds reasonable limit "
                  << MAX_REASONABLE_SIZE);
        return 0;
    }
    try {
        for (int i = 1; i <= size; i++) {
            if (i > GetMaxSize()) {
                LOG_ERROR("BPlusTreeInternalPage::KeyIndex: Index "
                          << i << " exceeds max size " << GetMaxSize());
                return 0;
            }
            if (key < KeyAt(i)) {
                return i - 1;
            }
        }
    } catch (const std::exception& e) {
        LOG_ERROR("BPlusTreeInternalPage::KeyIndex: Exception at size "
                  << size << ": " << e.what());
        return 0;
    }
    return size;
}
template <typename KeyType, typename ValueType>
bool BPlusTreeLeafPage<KeyType, ValueType>::Insert(const KeyType& key,
                                                   const ValueType& value) {
    if (GetSize() >= GetMaxSize()) {
        return false;
    }
    int insert_index = KeyIndex(key);
    if (insert_index < GetSize() && KeyAt(insert_index) == key) {
        SetValueAt(insert_index, value);
        return true;
    }
    size_t pair_size = sizeof(KeyType) + sizeof(ValueType);
    int move_count = GetSize() - insert_index;
    if (move_count > 0) {
        std::memmove(data_ + (insert_index + 1) * pair_size,
                     data_ + insert_index * pair_size, move_count * pair_size);
    }
    SetKeyAt(insert_index, key);
    SetValueAt(insert_index, value);
    IncreaseSize(1);
    return true;
}
template <typename KeyType, typename ValueType>
bool BPlusTreeLeafPage<KeyType, ValueType>::Delete(const KeyType& key) {
    if (GetSize() <= 0) {
        LOG_WARN(
            "BPlusTreeLeafPage::Delete: Attempting to delete from empty page");
        return false;
    }
    int delete_index = KeyIndex(key);
    if (delete_index >= GetSize() || KeyAt(delete_index) != key) {
        return false;
    }
    size_t pair_size = sizeof(KeyType) + sizeof(ValueType);
    int move_count = GetSize() - delete_index - 1;
    if (move_count > 0) {
        std::memmove(data_ + delete_index * pair_size,
                     data_ + (delete_index + 1) * pair_size,
                     move_count * pair_size);
    }
    if (GetSize() > 0) {
        IncreaseSize(-1);
    } else {
        LOG_WARN(
            "BPlusTreeLeafPage::Delete: Page size already 0, cannot decrease");
    }
    return true;
}
template <typename KeyType, typename ValueType>
void BPlusTreeLeafPage<KeyType, ValueType>::MoveHalfTo(
    BPlusTreeLeafPage* recipient) {
    int total_size = GetSize();
    int split_point = (total_size + 1) / 2;
    int move_size = total_size - split_point;
    if (move_size <= 0) {
        return;
    }
    size_t pair_size = sizeof(KeyType) + sizeof(ValueType);
    size_t move_bytes = move_size * pair_size;
    std::memcpy(recipient->data_, data_ + split_point * pair_size, move_bytes);
    recipient->SetSize(move_size);
    SetSize(split_point);
    std::memset(data_ + split_point * pair_size, 0, move_bytes);
}
template <typename KeyType, typename ValueType>
void BPlusTreeLeafPage<KeyType, ValueType>::MoveAllTo(
    BPlusTreeLeafPage* recipient) {
    size_t pair_size = sizeof(KeyType) + sizeof(ValueType);
    size_t move_bytes = GetSize() * pair_size;
    std::memcpy(recipient->data_ + recipient->GetSize() * pair_size, data_,
                move_bytes);
    recipient->IncreaseSize(GetSize());
    SetSize(0);
}
template <typename KeyType, typename ValueType>
void BPlusTreeLeafPage<KeyType, ValueType>::MoveFirstToEndOf(
    BPlusTreeLeafPage* recipient) {
    if (GetSize() == 0) return;
    recipient->Insert(KeyAt(0), ValueAt(0));
    Delete(KeyAt(0));
}
template <typename KeyType, typename ValueType>
void BPlusTreeLeafPage<KeyType, ValueType>::MoveLastToFrontOf(
    BPlusTreeLeafPage* recipient) {
    if (GetSize() == 0) {
        LOG_WARN("BPlusTreeLeafPage::MoveLastToFrontOf: Source page is empty");
        return;
    }
    int last_index = GetSize() - 1;
    KeyType key = KeyAt(last_index);
    ValueType value = ValueAt(last_index);
    IncreaseSize(-1);
    size_t pair_size = sizeof(KeyType) + sizeof(ValueType);
    std::memmove(recipient->data_ + pair_size, recipient->data_,
                 recipient->GetSize() * pair_size);
    recipient->SetKeyAt(0, key);
    recipient->SetValueAt(0, value);
    recipient->IncreaseSize(1);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::Init(page_id_t page_id,
                                          page_id_t parent_id) {
    SetPageType(IndexPageType::INTERNAL_PAGE);
    SetPageId(page_id);
    SetParentPageId(parent_id);
    SetSize(0);
    size_t header_size = sizeof(BPlusTreePage);
    size_t available_space = PAGE_SIZE - header_size;
    size_t entry_size = sizeof(KeyType) + sizeof(page_id_t);
    int theoretical_max =
        static_cast<int>((available_space - sizeof(page_id_t)) / entry_size);
    SetMaxSize(std::max(16, theoretical_max - 1));
}
template <typename KeyType>
KeyType BPlusTreeInternalPage<KeyType>::KeyAt(int index) const {
    if (index <= 0 || index > GetSize()) {
        throw std::out_of_range("Key index out of range");
    }
    size_t offset =
        sizeof(page_id_t) + (index - 1) * (sizeof(KeyType) + sizeof(page_id_t));
    return *reinterpret_cast<const KeyType*>(data_ + offset);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::SetKeyAt(int index, const KeyType& key) {
    if (index <= 0 || index > GetMaxSize()) {
        throw std::out_of_range("Key index out of range");
    }
    size_t offset =
        sizeof(page_id_t) + (index - 1) * (sizeof(KeyType) + sizeof(page_id_t));
    *reinterpret_cast<KeyType*>(data_ + offset) = key;
}
template <typename KeyType>
page_id_t BPlusTreeInternalPage<KeyType>::ValueAt(int index) const {
    if (index < 0 || index > GetSize()) {
        throw std::out_of_range("Value index out of range");
    }
    size_t offset;
    if (index == 0) {
        offset = 0;
    } else {
        offset = sizeof(page_id_t) +
                 (index - 1) * (sizeof(KeyType) + sizeof(page_id_t)) +
                 sizeof(KeyType);
    }
    return *reinterpret_cast<const page_id_t*>(data_ + offset);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::SetValueAt(int index, page_id_t value) {
    if (index < 0 || index > GetMaxSize()) {
        throw std::out_of_range("Value index out of range");
    }
    size_t offset;
    if (index == 0) {
        offset = 0;
    } else {
        offset = sizeof(page_id_t) +
                 (index - 1) * (sizeof(KeyType) + sizeof(page_id_t)) +
                 sizeof(KeyType);
    }
    *reinterpret_cast<page_id_t*>(data_ + offset) = value;
}
template <typename KeyType>
int BPlusTreeInternalPage<KeyType>::ValueIndex(page_id_t value) const {
    for (int i = 0; i <= GetSize(); i++) {
        if (ValueAt(i) == value) {
            return i;
        }
    }
    return -1;
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::InsertNodeAfter(page_id_t old_value,
                                                     const KeyType& new_key,
                                                     page_id_t new_value) {
    if (GetSize() >= GetMaxSize()) {
        throw std::runtime_error("Cannot insert into full internal page");
    }
    int insert_index = ValueIndex(old_value);
    if (insert_index == -1) {
        throw std::runtime_error("Old value not found");
    }
    insert_index++;
    for (int i = GetSize(); i >= insert_index; i--) {
        if (i + 1 <= GetMaxSize()) {
            SetValueAt(i + 1, ValueAt(i));
        }
        if (i > 0 && i + 1 <= GetMaxSize()) {
            SetKeyAt(i + 1, KeyAt(i));
        }
    }
    if (insert_index > 0 && insert_index <= GetMaxSize()) {
        SetKeyAt(insert_index, new_key);
    }
    if (insert_index <= GetMaxSize()) {
        SetValueAt(insert_index, new_value);
    }
    IncreaseSize(1);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::Remove(int index) {
    if (index < 0 || index > GetSize()) {
        throw std::out_of_range("Index out of range");
    }
    if (index == 0) {
        for (int i = 0; i < GetSize(); i++) {
            SetValueAt(i, ValueAt(i + 1));
            if (i + 1 <= GetSize()) {
                SetKeyAt(i + 1, KeyAt(i + 1));
            }
        }
    } else {
        for (int i = index; i < GetSize(); i++) {
            if (i + 1 <= GetSize()) {
                SetKeyAt(i, KeyAt(i + 1));
                SetValueAt(i, ValueAt(i + 1));
            }
        }
    }
    IncreaseSize(-1);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::MoveHalfTo(
    BPlusTreeInternalPage* recipient, BufferPoolManager* buffer_pool_manager) {
    int total_size = GetSize();
    int split_point = (total_size + 1) / 2;
    recipient->SetValueAt(0, ValueAt(split_point));
    int move_count = 0;
    for (int i = split_point + 1; i <= total_size; i++) {
        move_count++;
        recipient->SetKeyAt(move_count, KeyAt(i));
        recipient->SetValueAt(move_count, ValueAt(i));
    }
    recipient->SetSize(move_count);
    for (int i = 0; i <= move_count; i++) {
        page_id_t child_page_id = recipient->ValueAt(i);
        if (child_page_id != INVALID_PAGE_ID) {
            Page* child_page = buffer_pool_manager->FetchPage(child_page_id);
            if (child_page) {
                auto* child_tree_page =
                    reinterpret_cast<BPlusTreePage*>(child_page->GetData());
                child_tree_page->SetParentPageId(recipient->GetPageId());
                buffer_pool_manager->UnpinPage(child_page_id, true);
            }
        }
    }
    SetSize(split_point - 1);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::MoveAllTo(
    BPlusTreeInternalPage* recipient, const KeyType& middle_key,
    BufferPoolManager* buffer_pool_manager) {
    int recipient_size = recipient->GetSize();
    recipient->SetKeyAt(recipient_size + 1, middle_key);
    recipient->SetValueAt(recipient_size + 1, ValueAt(0));
    for (int i = 1; i <= GetSize(); i++) {
        if (recipient_size + i + 1 <= recipient->GetMaxSize()) {
            recipient->SetKeyAt(recipient_size + i + 1, KeyAt(i));
            recipient->SetValueAt(recipient_size + i + 1, ValueAt(i));
        }
    }
    for (int i = 0; i <= GetSize(); i++) {
        page_id_t child_page_id = ValueAt(i);
        if (child_page_id != INVALID_PAGE_ID) {
            Page* child_page = buffer_pool_manager->FetchPage(child_page_id);
            if (child_page) {
                auto* child_tree_page =
                    reinterpret_cast<BPlusTreePage*>(child_page->GetData());
                child_tree_page->SetParentPageId(recipient->GetPageId());
                buffer_pool_manager->UnpinPage(child_page_id, true);
            }
        }
    }
    recipient->IncreaseSize(GetSize() + 1);
    SetSize(0);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::MoveFirstToEndOf(
    BPlusTreeInternalPage* recipient, const KeyType& middle_key,
    BufferPoolManager* buffer_pool_manager) {
    page_id_t first_child = ValueAt(0);
    int recipient_size = recipient->GetSize();
    if (recipient_size + 1 <= recipient->GetMaxSize()) {
        recipient->SetKeyAt(recipient_size + 1, middle_key);
        recipient->SetValueAt(recipient_size + 1, first_child);
        recipient->IncreaseSize(1);
    }
    if (first_child != INVALID_PAGE_ID) {
        Page* child_page = buffer_pool_manager->FetchPage(first_child);
        if (child_page) {
            auto* child_tree_page =
                reinterpret_cast<BPlusTreePage*>(child_page->GetData());
            child_tree_page->SetParentPageId(recipient->GetPageId());
            buffer_pool_manager->UnpinPage(first_child, true);
        }
    }
    Remove(0);
}
template <typename KeyType>
void BPlusTreeInternalPage<KeyType>::MoveLastToFrontOf(
    BPlusTreeInternalPage* recipient, const KeyType& middle_key,
    BufferPoolManager* buffer_pool_manager) {
    int last_index = GetSize();
    page_id_t last_child = ValueAt(last_index);
    for (int i = recipient->GetSize(); i >= 0; i--) {
        if (i > 0 && i + 1 <= recipient->GetMaxSize()) {
            recipient->SetKeyAt(i + 1, recipient->KeyAt(i));
        }
        if (i + 1 <= recipient->GetMaxSize()) {
            recipient->SetValueAt(i + 1, recipient->ValueAt(i));
        }
    }
    recipient->SetValueAt(0, last_child);
    if (recipient->GetMaxSize() > 0) {
        recipient->SetKeyAt(1, middle_key);
    }
    recipient->IncreaseSize(1);
    if (last_child != INVALID_PAGE_ID) {
        Page* child_page = buffer_pool_manager->FetchPage(last_child);
        if (child_page) {
            auto* child_tree_page =
                reinterpret_cast<BPlusTreePage*>(child_page->GetData());
            child_tree_page->SetParentPageId(recipient->GetPageId());
            buffer_pool_manager->UnpinPage(last_child, true);
        }
    }
    IncreaseSize(-1);
}
template class BPlusTreeLeafPage<int32_t, RID>;
template class BPlusTreeLeafPage<int64_t, RID>;
template class BPlusTreeLeafPage<float, RID>;
template class BPlusTreeLeafPage<double, RID>;
template class BPlusTreeLeafPage<std::string, RID>;
template class BPlusTreeInternalPage<int32_t>;
template class BPlusTreeInternalPage<int64_t>;
template class BPlusTreeInternalPage<float>;
template class BPlusTreeInternalPage<double>;
template class BPlusTreeInternalPage<std::string>;
}


========== ./src/index/index_manager.cpp ==========
namespace SimpleRDBMS {
enum class IndexKeyType {
    INVALID = 0,
    INT32,
    INT64,
    FLOAT,
    DOUBLE,
    STRING
};
struct IndexMetadata {
    IndexKeyType key_type;
    std::string index_name;
    std::string table_name;
    std::vector<std::string> key_columns;
    std::unique_ptr<void, std::function<void(void*)>>
        index_instance;
    IndexMetadata(IndexKeyType type, const std::string& idx_name,
                  const std::string& tbl_name,
                  const std::vector<std::string>& columns)
        : key_type(type),
          index_name(idx_name),
          table_name(tbl_name),
          key_columns(columns),
          index_instance(nullptr, [](void*) {}) {}
};
class IndexManagerImpl {
   public:
    explicit IndexManagerImpl(BufferPoolManager* buffer_pool_manager,
                              Catalog* catalog)
        : buffer_pool_manager_(buffer_pool_manager), catalog_(catalog) {
        LOG_DEBUG("IndexManager: Initializing IndexManager");
    }
    ~IndexManagerImpl() {
        LOG_DEBUG("IndexManager: Destroying IndexManager with "
                  << indexes_.size() << " indexes");
        try {
            std::lock_guard<std::mutex> lock(latch_);
            indexes_.clear();
        } catch (const std::exception& e) {
            LOG_ERROR(
                "IndexManagerImpl::~IndexManagerImpl: Exception during "
                "cleanup: "
                << e.what());
        } catch (...) {
            LOG_ERROR(
                "IndexManagerImpl::~IndexManagerImpl: Unknown exception during "
                "cleanup");
        }
        LOG_DEBUG("IndexManager: IndexManager destroyed successfully");
    }
    IndexKeyType DetermineKeyType(const Column& column) {
        switch (column.type) {
            case TypeId::INTEGER:
                return IndexKeyType::INT32;
            case TypeId::BIGINT:
                return IndexKeyType::INT64;
            case TypeId::FLOAT:
                return IndexKeyType::FLOAT;
            case TypeId::DOUBLE:
                return IndexKeyType::DOUBLE;
            case TypeId::VARCHAR:
                return IndexKeyType::STRING;
            default:
                LOG_ERROR("IndexManager: Unsupported column type for index: "
                          << static_cast<int>(column.type));
                return IndexKeyType::INVALID;
        }
    }
    bool CreateIndex(const std::string& index_name,
                     const std::string& table_name,
                     const std::vector<std::string>& key_columns,
                     const Schema* table_schema) {
        std::lock_guard<std::mutex> lock(latch_);
        LOG_DEBUG("IndexManager: Creating index "
                  << index_name << " on table " << table_name
                  << " (currently have " << indexes_.size() << " indexes)");
        if (indexes_.find(index_name) != indexes_.end()) {
            LOG_WARN("IndexManager: Index " << index_name << " already exists");
            return false;
        }
        if (key_columns.size() != 1) {
            LOG_ERROR("IndexManager: Multi-column indexes not supported yet");
            return false;
        }
        if (table_schema == nullptr) {
            LOG_ERROR("IndexManager: Table "
                      << table_name << " does not exist or schema is null");
            return false;
        }
        if (catalog_ != nullptr) {
            TableInfo* table_info = catalog_->GetTable(table_name);
            if (table_info == nullptr) {
                LOG_ERROR("IndexManager: Table "
                          << table_name << " does not exist in catalog");
                return false;
            }
            if (table_info->schema.get() != table_schema) {
                LOG_ERROR("IndexManager: Schema mismatch for table "
                          << table_name);
                return false;
            }
        }
        const std::string& column_name = key_columns[0];
        if (!table_schema->HasColumn(column_name)) {
            LOG_ERROR("IndexManager: Column "
                      << column_name << " not found in table " << table_name);
            return false;
        }
        const Column& column = table_schema->GetColumn(column_name);
        IndexKeyType key_type = DetermineKeyType(column);
        if (key_type == IndexKeyType::INVALID) {
            LOG_ERROR(
                "IndexManager: Cannot create index on column with unsupported "
                "type");
            return false;
        }
        auto metadata = std::make_unique<IndexMetadata>(
            key_type, index_name, table_name, key_columns);
        bool success = false;
        switch (key_type) {
            case IndexKeyType::INT32: {
                auto tree = std::make_unique<BPlusTree<int32_t, RID>>(
                    index_name, buffer_pool_manager_);
                metadata->index_instance =
                    std::unique_ptr<void, std::function<void(void*)>>(
                        tree.release(), [](void* ptr) {
                            delete static_cast<BPlusTree<int32_t, RID>*>(ptr);
                        });
                success = true;
                break;
            }
            case IndexKeyType::INT64: {
                auto tree = std::make_unique<BPlusTree<int64_t, RID>>(
                    index_name, buffer_pool_manager_);
                metadata->index_instance =
                    std::unique_ptr<void, std::function<void(void*)>>(
                        tree.release(), [](void* ptr) {
                            delete static_cast<BPlusTree<int64_t, RID>*>(ptr);
                        });
                success = true;
                break;
            }
            case IndexKeyType::FLOAT: {
                auto tree = std::make_unique<BPlusTree<float, RID>>(
                    index_name, buffer_pool_manager_);
                metadata->index_instance =
                    std::unique_ptr<void, std::function<void(void*)>>(
                        tree.release(), [](void* ptr) {
                            delete static_cast<BPlusTree<float, RID>*>(ptr);
                        });
                success = true;
                break;
            }
            case IndexKeyType::DOUBLE: {
                auto tree = std::make_unique<BPlusTree<double, RID>>(
                    index_name, buffer_pool_manager_);
                metadata->index_instance =
                    std::unique_ptr<void, std::function<void(void*)>>(
                        tree.release(), [](void* ptr) {
                            delete static_cast<BPlusTree<double, RID>*>(ptr);
                        });
                success = true;
                break;
            }
            case IndexKeyType::STRING: {
                auto tree = std::make_unique<BPlusTree<std::string, RID>>(
                    index_name, buffer_pool_manager_);
                metadata->index_instance =
                    std::unique_ptr<void, std::function<void(void*)>>(
                        tree.release(), [](void* ptr) {
                            delete static_cast<BPlusTree<std::string, RID>*>(
                                ptr);
                        });
                success = true;
                break;
            }
            default:
                LOG_ERROR(
                    "IndexManager: Unsupported key type for index creation");
                success = false;
                break;
        }
        if (success) {
            indexes_[index_name] = std::move(metadata);
            LOG_INFO("IndexManager: Successfully created index "
                     << index_name << " (now have " << indexes_.size()
                     << " indexes)");
            LOG_DEBUG("IndexManager: Current indexes after creation:");
            for (const auto& [name, meta] : indexes_) {
                LOG_DEBUG("  - " << name << " on table " << meta->table_name);
            }
            return true;
        } else {
            LOG_ERROR("IndexManager: Failed to create index " << index_name);
            return false;
        }
    }
    bool DropIndex(const std::string& index_name) {
        std::lock_guard<std::mutex> lock(latch_);
        LOG_DEBUG("IndexManager: Dropping index "
                  << index_name << " (currently have " << indexes_.size()
                  << " indexes)");
        auto it = indexes_.find(index_name);
        if (it == indexes_.end()) {
            LOG_WARN("IndexManager: Index " << index_name << " not found");
            return false;
        }
        indexes_.erase(it);
        LOG_INFO("IndexManager: Successfully dropped index "
                 << index_name << " (now have " << indexes_.size()
                 << " indexes)");
        LOG_DEBUG("IndexManager: Remaining indexes after drop:");
        for (const auto& [name, meta] : indexes_) {
            LOG_DEBUG("  - " << name << " on table " << meta->table_name);
        }
        return true;
    }
    template <typename KeyType>
    BPlusTree<KeyType, RID>* GetIndex(const std::string& index_name) {
        std::lock_guard<std::mutex> lock(latch_);
        auto it = indexes_.find(index_name);
        if (it == indexes_.end()) {
            LOG_WARN("IndexManager: Index " << index_name << " not found");
            return nullptr;
        }
        return static_cast<BPlusTree<KeyType, RID>*>(
            it->second->index_instance.get());
    }
    IndexMetadata* GetIndexMetadata(const std::string& index_name) {
        std::lock_guard<std::mutex> lock(latch_);
        auto it = indexes_.find(index_name);
        if (it == indexes_.end()) {
            return nullptr;
        }
        return it->second.get();
    }
    bool InsertEntry(const std::string& index_name, const Value& key,
                     const RID& rid) {
        auto metadata = GetIndexMetadata(index_name);
        if (!metadata) {
            LOG_ERROR("IndexManager: Index " << index_name
                                             << " not found for insertion");
            return false;
        }
        switch (metadata->key_type) {
            case IndexKeyType::INT32: {
                auto* tree = GetIndex<int32_t>(index_name);
                if (tree && std::holds_alternative<int32_t>(key)) {
                    return tree->Insert(std::get<int32_t>(key), rid);
                }
                break;
            }
            case IndexKeyType::INT64: {
                auto* tree = GetIndex<int64_t>(index_name);
                if (tree && std::holds_alternative<int64_t>(key)) {
                    return tree->Insert(std::get<int64_t>(key), rid);
                }
                break;
            }
            case IndexKeyType::FLOAT: {
                auto* tree = GetIndex<float>(index_name);
                if (tree && std::holds_alternative<float>(key)) {
                    return tree->Insert(std::get<float>(key), rid);
                }
                break;
            }
            case IndexKeyType::DOUBLE: {
                auto* tree = GetIndex<double>(index_name);
                if (tree && std::holds_alternative<double>(key)) {
                    return tree->Insert(std::get<double>(key), rid);
                }
                break;
            }
            case IndexKeyType::STRING: {
                auto* tree = GetIndex<std::string>(index_name);
                if (tree && std::holds_alternative<std::string>(key)) {
                    return tree->Insert(std::get<std::string>(key), rid);
                }
                break;
            }
            default:
                LOG_ERROR("IndexManager: Unsupported key type for insertion");
                return false;
        }
        LOG_ERROR("IndexManager: Type mismatch or invalid tree for index "
                  << index_name);
        return false;
    }
    bool DeleteEntry(const std::string& index_name, const Value& key) {
        auto metadata = GetIndexMetadata(index_name);
        if (!metadata) {
            LOG_ERROR("IndexManager: Index " << index_name
                                             << " not found for deletion");
            return false;
        }
        switch (metadata->key_type) {
            case IndexKeyType::INT32: {
                auto* tree = GetIndex<int32_t>(index_name);
                if (tree && std::holds_alternative<int32_t>(key)) {
                    return tree->Remove(std::get<int32_t>(key));
                }
                break;
            }
            case IndexKeyType::INT64: {
                auto* tree = GetIndex<int64_t>(index_name);
                if (tree && std::holds_alternative<int64_t>(key)) {
                    return tree->Remove(std::get<int64_t>(key));
                }
                break;
            }
            case IndexKeyType::FLOAT: {
                auto* tree = GetIndex<float>(index_name);
                if (tree && std::holds_alternative<float>(key)) {
                    return tree->Remove(std::get<float>(key));
                }
                break;
            }
            case IndexKeyType::DOUBLE: {
                auto* tree = GetIndex<double>(index_name);
                if (tree && std::holds_alternative<double>(key)) {
                    return tree->Remove(std::get<double>(key));
                }
                break;
            }
            case IndexKeyType::STRING: {
                auto* tree = GetIndex<std::string>(index_name);
                if (tree && std::holds_alternative<std::string>(key)) {
                    return tree->Remove(std::get<std::string>(key));
                }
                break;
            }
            default:
                LOG_ERROR("IndexManager: Unsupported key type for deletion");
                return false;
        }
        LOG_ERROR("IndexManager: Type mismatch or invalid tree for index "
                  << index_name);
        return false;
    }
    bool FindEntry(const std::string& index_name, const Value& key, RID* rid) {
        auto metadata = GetIndexMetadata(index_name);
        if (!metadata) {
            LOG_ERROR("IndexManager: Index " << index_name
                                             << " not found for search");
            return false;
        }
        LOG_DEBUG("IndexManager::FindEntry: Searching in index "
                  << index_name << " for key type "
                  << static_cast<int>(metadata->key_type));
        switch (metadata->key_type) {
            case IndexKeyType::INT32: {
                auto* tree = GetIndex<int32_t>(index_name);
                if (tree && std::holds_alternative<int32_t>(key)) {
                    bool found = tree->GetValue(std::get<int32_t>(key), rid);
                    LOG_DEBUG("IndexManager::FindEntry: INT32 search result = "
                              << found);
                    return found;
                }
                LOG_DEBUG(
                    "IndexManager::FindEntry: INT32 type mismatch or invalid "
                    "tree");
                break;
            }
            case IndexKeyType::INT64: {
                auto* tree = GetIndex<int64_t>(index_name);
                if (tree && std::holds_alternative<int64_t>(key)) {
                    bool found = tree->GetValue(std::get<int64_t>(key), rid);
                    LOG_DEBUG("IndexManager::FindEntry: INT64 search result = "
                              << found);
                    return found;
                }
                LOG_DEBUG(
                    "IndexManager::FindEntry: INT64 type mismatch or invalid "
                    "tree");
                break;
            }
            case IndexKeyType::FLOAT: {
                auto* tree = GetIndex<float>(index_name);
                if (tree && std::holds_alternative<float>(key)) {
                    bool found = tree->GetValue(std::get<float>(key), rid);
                    LOG_DEBUG("IndexManager::FindEntry: FLOAT search result = "
                              << found);
                    return found;
                }
                LOG_DEBUG(
                    "IndexManager::FindEntry: FLOAT type mismatch or invalid "
                    "tree");
                break;
            }
            case IndexKeyType::DOUBLE: {
                auto* tree = GetIndex<double>(index_name);
                if (tree && std::holds_alternative<double>(key)) {
                    bool found = tree->GetValue(std::get<double>(key), rid);
                    LOG_DEBUG("IndexManager::FindEntry: DOUBLE search result = "
                              << found);
                    return found;
                }
                LOG_DEBUG(
                    "IndexManager::FindEntry: DOUBLE type mismatch or invalid "
                    "tree");
                break;
            }
            case IndexKeyType::STRING: {
                auto* tree = GetIndex<std::string>(index_name);
                if (tree && std::holds_alternative<std::string>(key)) {
                    bool found =
                        tree->GetValue(std::get<std::string>(key), rid);
                    LOG_DEBUG("IndexManager::FindEntry: STRING search result = "
                              << found);
                    return found;
                }
                LOG_DEBUG(
                    "IndexManager::FindEntry: STRING type mismatch or invalid "
                    "tree");
                break;
            }
            default:
                LOG_ERROR("IndexManager: Unsupported key type for search");
                return false;
        }
        LOG_ERROR("IndexManager: Type mismatch or invalid tree for index "
                  << index_name);
        return false;
    }
    std::vector<std::string> GetAllIndexNames() const {
        std::lock_guard<std::mutex> lock(latch_);
        std::vector<std::string> names;
        names.reserve(indexes_.size());
        LOG_DEBUG("IndexManager::GetAllIndexNames: Scanning " << indexes_.size()
                                                              << " indexes");
        for (const auto& [name, metadata] : indexes_) {
            names.push_back(name);
            LOG_DEBUG("IndexManager::GetAllIndexNames: Found index "
                      << name << " on table " << metadata->table_name);
        }
        LOG_DEBUG("IndexManager::GetAllIndexNames: Total "
                  << names.size() << " indexes returned");
        return names;
    }
    std::vector<std::string> GetTableIndexes(
        const std::string& table_name) const {
        std::lock_guard<std::mutex> lock(latch_);
        std::vector<std::string> table_indexes;
        for (const auto& [index_name, metadata] : indexes_) {
            if (metadata->table_name == table_name) {
                table_indexes.push_back(index_name);
                LOG_DEBUG("IndexManager::GetTableIndexes: Found index "
                          << index_name << " for table " << table_name);
            }
        }
        LOG_DEBUG("IndexManager::GetTableIndexes: Table "
                  << table_name << " has " << table_indexes.size()
                  << " indexes");
        return table_indexes;
    }
   private:
    BufferPoolManager*
        buffer_pool_manager_;
    Catalog* catalog_;
    std::unordered_map<std::string, std::unique_ptr<IndexMetadata>>
        indexes_;
    mutable std::mutex latch_;
};
IndexManager::IndexManager(BufferPoolManager* buffer_pool_manager,
                           Catalog* catalog)
    : impl_(std::make_unique<IndexManagerImpl>(buffer_pool_manager, catalog)) {}
IndexManager::~IndexManager() = default;
bool IndexManager::CreateIndex(const std::string& index_name,
                               const std::string& table_name,
                               const std::vector<std::string>& key_columns,
                               const Schema* table_schema) {
    return impl_->CreateIndex(index_name, table_name, key_columns,
                              table_schema);
}
bool IndexManager::DropIndex(const std::string& index_name) {
    return impl_->DropIndex(index_name);
}
bool IndexManager::InsertEntry(const std::string& index_name, const Value& key,
                               const RID& rid) {
    return impl_->InsertEntry(index_name, key, rid);
}
bool IndexManager::DeleteEntry(const std::string& index_name,
                               const Value& key) {
    return impl_->DeleteEntry(index_name, key);
}
bool IndexManager::FindEntry(const std::string& index_name, const Value& key,
                             RID* rid) {
    return impl_->FindEntry(index_name, key, rid);
}
std::vector<std::string> IndexManager::GetAllIndexNames() const {
    return impl_->GetAllIndexNames();
}
std::vector<std::string> IndexManager::GetTableIndexes(
    const std::string& table_name) const {
    return impl_->GetTableIndexes(table_name);
}
template <typename KeyType>
BPlusTree<KeyType, RID>* IndexManager::GetIndex(const std::string& index_name) {
    return impl_->GetIndex<KeyType>(index_name);
}
template BPlusTree<int32_t, RID>* IndexManager::GetIndex<int32_t>(
    const std::string& index_name);
template BPlusTree<int64_t, RID>* IndexManager::GetIndex<int64_t>(
    const std::string& index_name);
template BPlusTree<float, RID>* IndexManager::GetIndex<float>(
    const std::string& index_name);
template BPlusTree<double, RID>* IndexManager::GetIndex<double>(
    const std::string& index_name);
template BPlusTree<std::string, RID>* IndexManager::GetIndex<std::string>(
    const std::string& index_name);
}


========== ./src/main.cpp ==========
using namespace SimpleRDBMS;
class SimpleRDBMSServer {
   public:
    SimpleRDBMSServer(const std::string& db_file) {
        disk_manager_ = std::make_unique<DiskManager>(db_file);
        log_disk_manager_ = std::make_unique<DiskManager>(db_file + ".log");
        replacer_ = std::make_unique<LRUReplacer>(BUFFER_POOL_SIZE);
        buffer_pool_manager_ = std::make_unique<BufferPoolManager>(
            BUFFER_POOL_SIZE, std::move(disk_manager_), std::move(replacer_));
        log_manager_ = std::make_unique<LogManager>(log_disk_manager_.get());
        lock_manager_ = std::make_unique<LockManager>();
        transaction_manager_ = std::make_unique<TransactionManager>(
            lock_manager_.get(), log_manager_.get());
        catalog_ = std::make_unique<Catalog>(buffer_pool_manager_.get(),
                                             log_manager_.get());
        table_manager_ = std::make_unique<TableManager>(
            buffer_pool_manager_.get(), catalog_.get());
        recovery_manager_ = std::make_unique<RecoveryManager>(
            buffer_pool_manager_.get(), catalog_.get(), log_manager_.get(),
            lock_manager_.get());
        execution_engine_ = std::make_unique<ExecutionEngine>(
            buffer_pool_manager_.get(), catalog_.get(),
            transaction_manager_.get(), log_manager_.get());
        recovery_manager_->Recover();
    }
    void Run() {
        std::cout << "SimpleRDBMS Server Started!" << std::endl;
        std::cout << "Enter SQL commands (type 'exit' to quit):" << std::endl;
        std::cout << "Note: SQL statements must end with ';'" << std::endl;
        std::string accumulated_sql;
        std::string line;
        bool is_first_line = true;
        while (true) {
            if (is_first_line) {
                std::cout << "SimpleRDBMS> ";
                is_first_line = false;
            } else {
                std::cout << "          -> ";
            }
            if (!std::getline(std::cin, line)) {
                break;
            }
            line = TrimWhitespace(line);
            if (accumulated_sql.empty() && (line == "exit" || line == "quit")) {
                break;
            }
            if (line.empty() && accumulated_sql.empty()) {
                is_first_line = true;
                continue;
            }
            if (!accumulated_sql.empty()) {
                accumulated_sql += " ";
            }
            accumulated_sql += line;
            size_t semicolon_pos = accumulated_sql.find(';');
            while (semicolon_pos != std::string::npos) {
                std::string sql_to_execute =
                    accumulated_sql.substr(0, semicolon_pos);
                sql_to_execute = TrimWhitespace(sql_to_execute);
                if (!sql_to_execute.empty()) {
                    auto start_time = std::chrono::high_resolution_clock::now();
                    ExecuteSQL(sql_to_execute);
                    auto end_time = std::chrono::high_resolution_clock::now();
                    auto duration =
                        std::chrono::duration_cast<std::chrono::milliseconds>(
                            end_time - start_time);
                    std::cout << "Query executed in " << duration.count()
                              << " ms" << std::endl;
                }
                accumulated_sql = accumulated_sql.substr(semicolon_pos + 1);
                accumulated_sql = TrimWhitespace(accumulated_sql);
                semicolon_pos = accumulated_sql.find(';');
                is_first_line = accumulated_sql.empty();
            }
        }
        std::cout << "Shutting down..." << std::endl;
        Shutdown();
    }
   private:
    std::string TrimWhitespace(const std::string& str) {
        const std::string whitespace = " \t\n\r";
        size_t start = str.find_first_not_of(whitespace);
        if (start == std::string::npos) {
            return "";
        }
        size_t end = str.find_last_not_of(whitespace);
        return str.substr(start, end - start + 1);
    }
    void ExecuteSQL(const std::string& sql) {
        try {
            Parser parser(sql);
            auto statement = parser.Parse();
            auto stmt_type = statement->GetType();
            if (stmt_type == Statement::StmtType::BEGIN_TXN) {
                auto* txn = transaction_manager_->Begin();
                std::cout << "Transaction started with ID: " << txn->GetTxnId()
                          << std::endl;
                return;
            }
            if (stmt_type == Statement::StmtType::COMMIT_TXN) {
                std::cout << "Transaction committed." << std::endl;
                return;
            }
            if (stmt_type == Statement::StmtType::ROLLBACK_TXN) {
                std::cout << "Transaction rolled back." << std::endl;
                return;
            }
            auto* txn = transaction_manager_->Begin();
            std::vector<Tuple> result_set;
            bool success =
                execution_engine_->Execute(statement.get(), &result_set, txn);
            if (success) {
                transaction_manager_->Commit(txn);
                std::cout << "Query executed successfully." << std::endl;
                switch (stmt_type) {
                    case Statement::StmtType::SELECT:
                        DisplaySelectResults(
                            result_set,
                            static_cast<SelectStatement*>(statement.get()));
                        break;
                    case Statement::StmtType::INSERT:
                        DisplayInsertResults(result_set);
                        break;
                    case Statement::StmtType::UPDATE:
                        DisplayUpdateResults(
                            result_set,
                            static_cast<UpdateStatement*>(statement.get()));
                        break;
                    case Statement::StmtType::DELETE:
                        DisplayDeleteResults(result_set);
                        break;
                    case Statement::StmtType::SHOW_TABLES:
                        DisplayShowTablesResults(result_set);
                        break;
                    case Statement::StmtType::CREATE_TABLE:
                    case Statement::StmtType::DROP_TABLE:
                    case Statement::StmtType::CREATE_INDEX:
                    case Statement::StmtType::DROP_INDEX:
                        std::cout << "DDL operation completed successfully."
                                  << std::endl;
                        break;
                    case Statement::StmtType::EXPLAIN:
                        DisplayExplainResults(result_set);
                        break;
                    default:
                        break;
                }
            } else {
                transaction_manager_->Abort(txn);
                std::cout << "Query execution failed." << std::endl;
            }
        } catch (const std::exception& e) {
            std::cout << "Error: " << e.what() << std::endl;
        }
    }
    void DisplayExplainResults(const std::vector<Tuple>& result_set) {
        if (result_set.empty()) {
            std::cout << "No execution plan available." << std::endl;
            return;
        }
        size_t max_length = 20;
        for (const auto& tuple : result_set) {
            std::string plan_line = std::get<std::string>(tuple.GetValue(0));
            max_length = std::max(max_length, plan_line.length());
        }
        max_length += 4;
        std::cout << "\n";
        std::cout << "+" << std::string(max_length, '-') << "+" << std::endl;
        std::string title = "QUERY PLAN";
        size_t padding = (max_length - title.length()) / 2;
        std::cout << "|" << std::string(padding, ' ') << title
                  << std::string(max_length - padding - title.length(), ' ')
                  << "|" << std::endl;
        std::cout << "+" << std::string(max_length, '-') << "+" << std::endl;
        for (const auto& tuple : result_set) {
            std::string plan_line = std::get<std::string>(tuple.GetValue(0));
            std::cout << "| " << std::left << std::setw(max_length - 2)
                      << plan_line << " |" << std::endl;
        }
        std::cout << "+" << std::string(max_length, '-') << "+" << std::endl;
        std::cout << "\n(" << result_set.size() << " step"
                  << (result_set.size() != 1 ? "s" : "")
                  << " in execution plan)\n"
                  << std::endl;
    }
    void DisplayShowTablesResults(const std::vector<Tuple>& result_set) {
        if (result_set.empty()) {
            std::cout << "No tables found." << std::endl;
            return;
        }
        std::cout << "\n";
        std::cout << "+----------------+----------------+------------+---------"
                     "-+-------------+-------------+"
                  << std::endl;
        std::cout << "| Table Name     | Column Name    | Data Type  | "
                     "Nullable | Primary Key | Column Size |"
                  << std::endl;
        std::cout << "+----------------+----------------+------------+---------"
                     "-+-------------+-------------+"
                  << std::endl;
        std::string current_table = "";
        for (const auto& tuple : result_set) {
            std::string table_name = std::get<std::string>(tuple.GetValue(0));
            std::string column_name = std::get<std::string>(tuple.GetValue(1));
            std::string data_type = std::get<std::string>(tuple.GetValue(2));
            std::string is_nullable = std::get<std::string>(tuple.GetValue(3));
            std::string is_primary_key =
                std::get<std::string>(tuple.GetValue(4));
            int32_t column_size = std::get<int32_t>(tuple.GetValue(5));
            if (current_table != table_name && !current_table.empty()) {
                std::cout << "+----------------+----------------+------------+-"
                             "---------+-------------+-------------+"
                          << std::endl;
            }
            current_table = table_name;
            std::string formatted_type = data_type;
            if (data_type == "VARCHAR" && column_size > 0) {
                formatted_type = "VARCHAR(" + std::to_string(column_size) + ")";
            }
            std::cout << "| " << std::setw(14) << std::left << table_name
                      << " | " << std::setw(14) << std::left << column_name
                      << " | " << std::setw(10) << std::left << formatted_type
                      << " | " << std::setw(8) << std::left << is_nullable
                      << " | " << std::setw(11) << std::left << is_primary_key
                      << " | " << std::setw(11) << std::right
                      << (column_size > 0 ? std::to_string(column_size) : "-")
                      << " |" << std::endl;
        }
        std::cout << "+----------------+----------------+------------+---------"
                     "-+-------------+-------------+"
                  << std::endl;
        std::set<std::string> unique_tables;
        for (const auto& tuple : result_set) {
            unique_tables.insert(std::get<std::string>(tuple.GetValue(0)));
        }
        std::cout << "\n"
                  << unique_tables.size() << " table(s) with "
                  << result_set.size() << " column(s) total.\n"
                  << std::endl;
    }
    void DisplaySelectResults(const std::vector<Tuple>& result_set,
                              SelectStatement* select_stmt) {
        if (result_set.empty()) {
            std::cout << "No results found." << std::endl;
            return;
        }
        TableInfo* table_info = catalog_->GetTable(select_stmt->GetTableName());
        if (!table_info) {
            std::cout << "Table not found." << std::endl;
            return;
        }
        const Schema* schema = table_info->schema.get();
        const auto& select_list = select_stmt->GetSelectList();
        std::vector<std::string> column_names;
        std::vector<size_t> column_indices;
        bool is_select_all = false;
        if (select_list.size() == 1) {
            auto* col_ref =
                dynamic_cast<ColumnRefExpression*>(select_list[0].get());
            if (col_ref && col_ref->GetColumnName() == "*") {
                is_select_all = true;
            }
        }
        if (is_select_all) {
            for (size_t i = 0; i < schema->GetColumnCount(); ++i) {
                column_names.push_back(schema->GetColumn(i).name);
                column_indices.push_back(i);
            }
        } else {
            for (const auto& expr : select_list) {
                auto* col_ref = dynamic_cast<ColumnRefExpression*>(expr.get());
                if (col_ref) {
                    std::string col_name = col_ref->GetColumnName();
                    column_names.push_back(col_name);
                    column_indices.push_back(schema->GetColumnIdx(col_name));
                }
            }
        }
        std::vector<size_t> column_widths;
        for (const auto& name : column_names) {
            column_widths.push_back(
                std::max(name.length(), static_cast<size_t>(15)));
        }
        std::cout << "\n";
        PrintSeparator(column_widths);
        std::cout << "|";
        for (size_t i = 0; i < column_names.size(); ++i) {
            std::cout << " " << std::setw(column_widths[i]) << std::left
                      << column_names[i] << " |";
        }
        std::cout << "\n";
        PrintSeparator(column_widths);
        for (const auto& tuple : result_set) {
            std::cout << "|";
            for (size_t i = 0; i < column_indices.size(); ++i) {
                std::string value_str =
                    ValueToString(tuple.GetValue(column_indices[i]));
                std::cout << " " << std::setw(column_widths[i]) << std::left
                          << value_str << " |";
            }
            std::cout << "\n";
        }
        PrintSeparator(column_widths);
        std::cout << "\n"
                  << result_set.size() << " row(s) returned.\n"
                  << std::endl;
    }
    void DisplayInsertResults(const std::vector<Tuple>& result_set) {
        std::cout << "Insert operation completed." << std::endl;
    }
    void DisplayUpdateResults(const std::vector<Tuple>& result_set,
                              UpdateStatement* update_stmt) {
        if (!result_set.empty()) {
            Value affected_rows = result_set[0].GetValue(0);
            int32_t count = std::get<int32_t>(affected_rows);
            std::cout << count << " row(s) updated." << std::endl;
        } else {
            std::cout << "0 row(s) updated." << std::endl;
        }
    }
    void DisplayDeleteResults(const std::vector<Tuple>& result_set) {
        if (!result_set.empty()) {
            Value affected_rows = result_set[0].GetValue(0);
            int32_t count = std::get<int32_t>(affected_rows);
            std::cout << count << " row(s) deleted." << std::endl;
        } else {
            std::cout << "0 row(s) deleted." << std::endl;
        }
    }
    void DisplayTableData(const std::vector<Tuple>& tuples,
                          const std::string& table_name) {
        if (tuples.empty()) {
            std::cout << "No data to display." << std::endl;
            return;
        }
        TableInfo* table_info = catalog_->GetTable(table_name);
        if (!table_info) {
            std::cout << "Table not found." << std::endl;
            return;
        }
        const Schema* schema = table_info->schema.get();
        std::vector<std::string> column_names;
        for (size_t i = 0; i < schema->GetColumnCount(); ++i) {
            column_names.push_back(schema->GetColumn(i).name);
        }
        std::vector<size_t> column_widths;
        for (const auto& name : column_names) {
            column_widths.push_back(
                std::max(name.length(), static_cast<size_t>(15)));
        }
        PrintSeparator(column_widths);
        std::cout << "|";
        for (size_t i = 0; i < column_names.size(); ++i) {
            std::cout << " " << std::setw(column_widths[i]) << std::left
                      << column_names[i] << " |";
        }
        std::cout << "\n";
        PrintSeparator(column_widths);
        for (const auto& tuple : tuples) {
            std::cout << "|";
            for (size_t i = 0; i < column_names.size(); ++i) {
                std::string value_str = ValueToString(tuple.GetValue(i));
                std::cout << " " << std::setw(column_widths[i]) << std::left
                          << value_str << " |";
            }
            std::cout << "\n";
        }
        PrintSeparator(column_widths);
        std::cout << "\n";
    }
    void DisplayTableDataSimple(const std::vector<Tuple>& tuples) {
        if (tuples.empty()) {
            std::cout << "No data to display." << std::endl;
            return;
        }
        const auto& first_tuple = tuples[0];
        size_t column_count = first_tuple.GetValues().size();
        std::vector<size_t> column_widths(column_count, 15);
        PrintSeparator(column_widths);
        std::cout << "|";
        for (size_t i = 0; i < column_count; ++i) {
            std::string header = "Column" + std::to_string(i);
            std::cout << " " << std::setw(column_widths[i]) << std::left
                      << header << " |";
        }
        std::cout << "\n";
        PrintSeparator(column_widths);
        for (const auto& tuple : tuples) {
            std::cout << "|";
            for (size_t i = 0; i < column_count; ++i) {
                std::string value_str = ValueToString(tuple.GetValue(i));
                std::cout << " " << std::setw(column_widths[i]) << std::left
                          << value_str << " |";
            }
            std::cout << "\n";
        }
        PrintSeparator(column_widths);
        std::cout << "\n";
    }
    void PrintSeparator(const std::vector<size_t>& column_widths) {
        std::cout << "+";
        for (size_t width : column_widths) {
            std::cout << std::string(width + 2, '-') << "+";
        }
        std::cout << "\n";
    }
    std::string ValueToString(const Value& value) {
        std::stringstream ss;
        if (std::holds_alternative<bool>(value)) {
            ss << (std::get<bool>(value) ? "true" : "false");
        } else if (std::holds_alternative<int8_t>(value)) {
            ss << static_cast<int>(std::get<int8_t>(value));
        } else if (std::holds_alternative<int16_t>(value)) {
            ss << std::get<int16_t>(value);
        } else if (std::holds_alternative<int32_t>(value)) {
            ss << std::get<int32_t>(value);
        } else if (std::holds_alternative<int64_t>(value)) {
            ss << std::get<int64_t>(value);
        } else if (std::holds_alternative<float>(value)) {
            ss << std::fixed << std::setprecision(2) << std::get<float>(value);
        } else if (std::holds_alternative<double>(value)) {
            ss << std::fixed << std::setprecision(2) << std::get<double>(value);
        } else if (std::holds_alternative<std::string>(value)) {
            ss << std::get<std::string>(value);
        } else {
            ss << "NULL";
        }
        std::string result = ss.str();
        if (result.length() > 13) {
            result = result.substr(0, 12) + "...";
        }
        return result;
    }
    void Shutdown() {
        recovery_manager_->Checkpoint();
    }
    std::unique_ptr<DiskManager> disk_manager_;
    std::unique_ptr<DiskManager> log_disk_manager_;
    std::unique_ptr<Replacer> replacer_;
    std::unique_ptr<BufferPoolManager> buffer_pool_manager_;
    std::unique_ptr<LogManager> log_manager_;
    std::unique_ptr<LockManager> lock_manager_;
    std::unique_ptr<TransactionManager> transaction_manager_;
    std::unique_ptr<RecoveryManager> recovery_manager_;
    std::unique_ptr<Catalog> catalog_;
    std::unique_ptr<TableManager> table_manager_;
    std::unique_ptr<ExecutionEngine> execution_engine_;
};
int main(int argc, char* argv[]) {
    std::string db_file = "simple_rdbms.db";
    if (argc > 1) {
        db_file = argv[1];
    }
    if (argc > 2) {
        setenv("SIMPLEDB_DEBUG_LEVEL", argv[2], 1);
    }
    try {
        SimpleRDBMSServer server(db_file);
        server.Run();
    } catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}


========== ./src/parser/parser.cpp ==========
namespace SimpleRDBMS {
void ConstantExpression::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void ColumnRefExpression::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void SelectStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void InsertStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void CreateTableStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void DropTableStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void CreateIndexStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void DropIndexStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void BinaryOpExpression::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void UpdateStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void DeleteStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void UnaryOpExpression::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
static std::unordered_map<std::string, TokenType> keywords = {
    {"SELECT", TokenType::SELECT},
    {"FROM", TokenType::FROM},
    {"WHERE", TokenType::WHERE},
    {"INSERT", TokenType::INSERT},
    {"INTO", TokenType::INTO},
    {"VALUES", TokenType::VALUES},
    {"UPDATE", TokenType::UPDATE},
    {"SET", TokenType::SET},
    {"DELETE", TokenType::DELETE},
    {"CREATE", TokenType::CREATE},
    {"TABLE", TokenType::TABLE},
    {"DROP", TokenType::DROP},
    {"INDEX", TokenType::INDEX},
    {"ON", TokenType::ON},
    {"PRIMARY", TokenType::PRIMARY},
    {"KEY", TokenType::KEY},
    {"NOT", TokenType::NOT},
    {"NULL", TokenType::_NULL},
    {"INT", TokenType::INT},
    {"INTEGER", TokenType::INT},
    {"BIGINT", TokenType::BIGINT},
    {"VARCHAR", TokenType::VARCHAR},
    {"FLOAT", TokenType::FLOAT},
    {"DOUBLE", TokenType::DOUBLE},
    {"BOOLEAN", TokenType::BOOLEAN},
    {"BOOL", TokenType::BOOLEAN},
    {"AND", TokenType::AND},
    {"OR", TokenType::OR},
    {"TRUE", TokenType::BOOLEAN_LITERAL},
    {"FALSE", TokenType::BOOLEAN_LITERAL},
    {"SHOW", TokenType::SHOW},
    {"TABLES", TokenType::TABLES},
    {"BEGIN", TokenType::BEGIN},
    {"COMMIT", TokenType::COMMIT},
    {"ROLLBACK", TokenType::ROLLBACK},
    {"EXPLAIN", TokenType::EXPLAIN},
};
Lexer::Lexer(const std::string& input)
    : input_(input), position_(0), line_(1), column_(1) {}
char Lexer::Peek() {
    if (position_ >= input_.size()) {
        return '\0';
    }
    return input_[position_];
}
char Lexer::Advance() {
    if (position_ >= input_.size()) {
        return '\0';
    }
    char ch = input_[position_++];
    if (ch == '\n') {
        line_++;
        column_ = 1;
    } else {
        column_++;
    }
    return ch;
}
void Lexer::SkipWhitespace() {
    while (std::isspace(Peek())) {
        Advance();
    }
}
Token Lexer::ScanNumber() {
    Token token;
    token.line = line_;
    token.column = column_;
    std::string value;
    bool has_dot = false;
    while (std::isdigit(Peek()) || Peek() == '.') {
        if (Peek() == '.') {
            if (has_dot) break;
            has_dot = true;
        }
        value += Advance();
    }
    token.value = value;
    token.type =
        has_dot ? TokenType::FLOAT_LITERAL : TokenType::INTEGER_LITERAL;
    return token;
}
Token Lexer::ScanString() {
    Token token;
    token.line = line_;
    token.column = column_;
    token.type = TokenType::STRING_LITERAL;
    char quote = Advance();
    std::string value;
    while (Peek() != quote && Peek() != '\0') {
        if (Peek() == '\\') {
            Advance();
            char ch = Advance();
            switch (ch) {
                case 'n':
                    value += '\n';
                    break;
                case 't':
                    value += '\t';
                    break;
                case 'r':
                    value += '\r';
                    break;
                case '\\':
                    value += '\\';
                    break;
                case '\'':
                    value += '\'';
                    break;
                case '"':
                    value += '"';
                    break;
                default:
                    value += ch;
                    break;
            }
        } else {
            value += Advance();
        }
    }
    if (Peek() == quote) {
        Advance();
    }
    token.value = value;
    return token;
}
Token Lexer::ScanIdentifier() {
    Token token;
    token.line = line_;
    token.column = column_;
    std::string value;
    while (std::isalnum(Peek()) || Peek() == '_') {
        value += Advance();
    }
    std::string upper_value = value;
    std::transform(upper_value.begin(), upper_value.end(), upper_value.begin(),
                   ::toupper);
    auto it = keywords.find(upper_value);
    if (it != keywords.end()) {
        token.type = it->second;
        if (token.type == TokenType::BOOLEAN_LITERAL) {
            token.value = upper_value;
        } else {
            token.value = value;
        }
    } else {
        token.type = TokenType::IDENTIFIER;
        token.value = value;
    }
    return token;
}
Token Lexer::NextToken() {
    SkipWhitespace();
    Token token;
    token.line = line_;
    token.column = column_;
    char ch = Peek();
    if (ch == '\0') {
        token.type = TokenType::EOF_TOKEN;
        return token;
    }
    if (std::isdigit(ch)) {
        return ScanNumber();
    }
    if (std::isalpha(ch) || ch == '_') {
        return ScanIdentifier();
    }
    if (ch == '\'' || ch == '"') {
        return ScanString();
    }
    Advance();
    switch (ch) {
        case '(':
            token.type = TokenType::LPAREN;
            token.value = "(";
            break;
        case ')':
            token.type = TokenType::RPAREN;
            token.value = ")";
            break;
        case ',':
            token.type = TokenType::COMMA;
            token.value = ",";
            break;
        case ';':
            token.type = TokenType::SEMICOLON;
            token.value = ";";
            break;
        case '*':
            token.type = TokenType::MULTIPLY;
            token.value = "*";
            break;
        case '+':
            token.type = TokenType::PLUS;
            token.value = "+";
            break;
        case '-':
            token.type = TokenType::MINUS;
            token.value = "-";
            break;
        case '/':
            token.type = TokenType::DIVIDE;
            token.value = "/";
            break;
        case '=':
            token.type = TokenType::EQUALS;
            token.value = "=";
            break;
        case '<':
            if (Peek() == '=') {
                Advance();
                token.type = TokenType::LESS_EQUALS;
                token.value = "<=";
            } else if (Peek() == '>') {
                Advance();
                token.type = TokenType::NOT_EQUALS;
                token.value = "<>";
            } else {
                token.type = TokenType::LESS_THAN;
                token.value = "<";
            }
            break;
        case '>':
            if (Peek() == '=') {
                Advance();
                token.type = TokenType::GREATER_EQUALS;
                token.value = ">=";
            } else {
                token.type = TokenType::GREATER_THAN;
                token.value = ">";
            }
            break;
        case '!':
            if (Peek() == '=') {
                Advance();
                token.type = TokenType::NOT_EQUALS;
                token.value = "!=";
            } else {
                token.type = TokenType::INVALID;
                token.value = "!";
            }
            break;
        default:
            token.type = TokenType::INVALID;
            token.value = std::string(1, ch);
            break;
    }
    return token;
}
Parser::Parser(const std::string& sql) : lexer_(sql) { Advance(); }
void Parser::Advance() { current_token_ = lexer_.NextToken(); }
bool Parser::Match(TokenType type) {
    if (current_token_.type == type) {
        Advance();
        return true;
    }
    return false;
}
void Parser::Expect(TokenType type) {
    if (!Match(type)) {
        throw Exception("Unexpected token: " + current_token_.value);
    }
}
std::unique_ptr<Statement> Parser::Parse() {
    auto stmt = ParseStatement();
    if (current_token_.type != TokenType::EOF_TOKEN &&
        current_token_.type != TokenType::SEMICOLON) {
        throw Exception("Expected end of statement");
    }
    return stmt;
}
std::unique_ptr<Statement> Parser::ParseSelectStatement() {
    Expect(TokenType::SELECT);
    std::vector<std::unique_ptr<Expression>> select_list;
    if (current_token_.type == TokenType::MULTIPLY) {
        Advance();
        select_list.push_back(std::make_unique<ColumnRefExpression>("", "*"));
    } else {
        do {
            auto expr = ParseExpression();
            select_list.push_back(std::move(expr));
        } while (Match(TokenType::COMMA));
    }
    Expect(TokenType::FROM);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected table name");
    }
    std::string table_name = current_token_.value;
    Advance();
    std::unique_ptr<Expression> where_clause = nullptr;
    if (Match(TokenType::WHERE)) {
        where_clause = ParseExpression();
    }
    return std::make_unique<SelectStatement>(std::move(select_list), table_name,
                                             std::move(where_clause));
}
std::unique_ptr<Statement> Parser::ParseCreateTableStatement() {
    Expect(TokenType::TABLE);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected table name");
    }
    std::string table_name = current_token_.value;
    Advance();
    auto columns = ParseColumnDefinitions();
    return std::make_unique<CreateTableStatement>(table_name,
                                                  std::move(columns));
}
std::unique_ptr<Statement> Parser::ParseInsertStatement() {
    LOG_DEBUG("ParseInsertStatement: Starting INSERT statement parsing");
    Expect(TokenType::INSERT);
    Expect(TokenType::INTO);
    if (current_token_.type != TokenType::IDENTIFIER) {
        LOG_ERROR("ParseInsertStatement: Expected table name");
        throw Exception("Expected table name");
    }
    std::string table_name = current_token_.value;
    LOG_DEBUG("ParseInsertStatement: Table name: " << table_name);
    Advance();
    std::vector<std::string> column_names;
    if (Match(TokenType::LPAREN)) {
        LOG_DEBUG("ParseInsertStatement: Parsing column list");
        do {
            if (current_token_.type != TokenType::IDENTIFIER) {
                throw Exception("Expected column name");
            }
            column_names.push_back(current_token_.value);
            Advance();
        } while (Match(TokenType::COMMA));
        Expect(TokenType::RPAREN);
        LOG_DEBUG("ParseInsertStatement: Column list parsed, "
                  << column_names.size() << " columns");
    }
    Expect(TokenType::VALUES);
    LOG_DEBUG("ParseInsertStatement: Parsing VALUES clause");
    std::vector<std::vector<Value>> values_list;
    int value_list_count = 0;
    do {
        LOG_DEBUG("ParseInsertStatement: Parsing value list "
                  << value_list_count);
        Expect(TokenType::LPAREN);
        std::vector<Value> values;
        int value_count = 0;
        do {
            LOG_DEBUG("ParseInsertStatement: Parsing value "
                      << value_count << " in list " << value_list_count);
            auto expr = ParsePrimaryExpression();
            if (auto* const_expr =
                    dynamic_cast<ConstantExpression*>(expr.get())) {
                values.push_back(const_expr->GetValue());
                LOG_DEBUG("ParseInsertStatement: Added constant value");
            } else {
                LOG_ERROR(
                    "ParseInsertStatement: Only constant values are supported "
                    "in INSERT");
                throw Exception("Only constant values are supported in INSERT");
            }
            value_count++;
        } while (Match(TokenType::COMMA));
        Expect(TokenType::RPAREN);
        LOG_DEBUG("ParseInsertStatement: Completed value list "
                  << value_list_count << " with " << value_count << " values");
        values_list.push_back(std::move(values));
        value_list_count++;
    } while (Match(TokenType::COMMA));
    LOG_DEBUG("ParseInsertStatement: Completed parsing, " << values_list.size()
                                                          << " value lists");
    return std::make_unique<InsertStatement>(table_name,
                                             std::move(values_list));
}
std::vector<Column> Parser::ParseColumnDefinitions() {
    Expect(TokenType::LPAREN);
    std::vector<Column> columns;
    bool has_primary_key = false;
    do {
        Column col;
        if (current_token_.type != TokenType::IDENTIFIER) {
            throw Exception("Expected column name");
        }
        col.name = current_token_.value;
        Advance();
        col.type = ParseDataType();
        if (col.type == TypeId::VARCHAR) {
            Expect(TokenType::LPAREN);
            if (current_token_.type != TokenType::INTEGER_LITERAL) {
                throw Exception("Expected varchar size");
            }
            col.size = std::stoi(current_token_.value);
            Advance();
            Expect(TokenType::RPAREN);
        } else {
            col.size = 0;
        }
        col.nullable = true;
        col.is_primary_key = false;
        while (current_token_.type == TokenType::NOT ||
               current_token_.type == TokenType::PRIMARY) {
            if (Match(TokenType::NOT)) {
                Expect(TokenType::_NULL);
                col.nullable = false;
            } else if (Match(TokenType::PRIMARY)) {
                Expect(TokenType::KEY);
                if (has_primary_key) {
                    throw Exception("Multiple primary keys not allowed");
                }
                col.is_primary_key = true;
                col.nullable = false;
                has_primary_key = true;
            }
        }
        columns.push_back(col);
    } while (Match(TokenType::COMMA));
    Expect(TokenType::RPAREN);
    return columns;
}
std::unique_ptr<Statement> Parser::ParseUpdateStatement() {
    Expect(TokenType::UPDATE);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected table name");
    }
    std::string table_name = current_token_.value;
    Advance();
    Expect(TokenType::SET);
    std::vector<UpdateClause> update_clauses;
    do {
        if (current_token_.type != TokenType::IDENTIFIER) {
            throw Exception("Expected column name");
        }
        std::string column_name = current_token_.value;
        Advance();
        Expect(TokenType::EQUALS);
        auto value_expr = ParseExpression();
        update_clauses.emplace_back(column_name, std::move(value_expr));
    } while (Match(TokenType::COMMA));
    std::unique_ptr<Expression> where_clause = nullptr;
    if (Match(TokenType::WHERE)) {
        where_clause = ParseExpression();
    }
    return std::make_unique<UpdateStatement>(
        table_name, std::move(update_clauses), std::move(where_clause));
}
std::unique_ptr<Statement> Parser::ParseDeleteStatement() {
    Expect(TokenType::DELETE);
    Expect(TokenType::FROM);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected table name");
    }
    std::string table_name = current_token_.value;
    Advance();
    std::unique_ptr<Expression> where_clause = nullptr;
    if (Match(TokenType::WHERE)) {
        where_clause = ParseExpression();
    }
    return std::make_unique<DeleteStatement>(table_name,
                                             std::move(where_clause));
}
TypeId Parser::ParseDataType() {
    TypeId type = TypeId::INVALID;
    switch (current_token_.type) {
        case TokenType::INT:
            Advance();
            type = TypeId::INTEGER;
            break;
        case TokenType::BIGINT:
            Advance();
            type = TypeId::BIGINT;
            break;
        case TokenType::VARCHAR:
            Advance();
            type = TypeId::VARCHAR;
            break;
        case TokenType::FLOAT:
            Advance();
            type = TypeId::FLOAT;
            break;
        case TokenType::DOUBLE:
            Advance();
            type = TypeId::DOUBLE;
            break;
        case TokenType::BOOLEAN:
            Advance();
            type = TypeId::BOOLEAN;
            break;
        default:
            throw Exception("Invalid data type");
    }
    return type;
}
std::unique_ptr<Expression> Parser::ParseExpression() {
    return ParseOrExpression();
}
std::unique_ptr<Expression> Parser::ParseOrExpression() {
    auto left = ParseAndExpression();
    while (Match(TokenType::OR)) {
        auto right = ParseAndExpression();
        left = std::make_unique<BinaryOpExpression>(
            std::move(left), BinaryOpExpression::OpType::OR, std::move(right));
    }
    return left;
}
std::unique_ptr<Expression> Parser::ParseAndExpression() {
    auto left = ParseComparisonExpression();
    while (Match(TokenType::AND)) {
        auto right = ParseComparisonExpression();
        left = std::make_unique<BinaryOpExpression>(
            std::move(left), BinaryOpExpression::OpType::AND, std::move(right));
    }
    return left;
}
std::unique_ptr<Statement> Parser::ParseStatement() {
    switch (current_token_.type) {
        case TokenType::SELECT:
            return ParseSelectStatement();
        case TokenType::CREATE: {
            Advance();
            if (current_token_.type == TokenType::TABLE) {
                return ParseCreateTableStatement();
            } else if (current_token_.type == TokenType::INDEX) {
                return ParseCreateIndexStatement();
            } else {
                throw Exception("Expected TABLE or INDEX after CREATE");
            }
        }
        case TokenType::DROP: {
            Advance();
            if (current_token_.type == TokenType::TABLE) {
                return ParseDropTableStatement();
            } else if (current_token_.type == TokenType::INDEX) {
                return ParseDropIndexStatement();
            } else {
                throw Exception("Expected TABLE or INDEX after DROP");
            }
        }
        case TokenType::INSERT:
            return ParseInsertStatement();
        case TokenType::UPDATE:
            return ParseUpdateStatement();
        case TokenType::DELETE:
            return ParseDeleteStatement();
        case TokenType::SHOW:
            return ParseShowTablesStatement();
        case TokenType::BEGIN:
            return ParseBeginStatement();
        case TokenType::COMMIT:
            return ParseCommitStatement();
        case TokenType::ROLLBACK:
            return ParseRollbackStatement();
        case TokenType::EXPLAIN:
            return ParseExplainStatement();
        default:
            throw Exception("Unsupported statement type");
    }
}
std::unique_ptr<Expression> Parser::ParseComparisonExpression() {
    auto left = ParseArithmeticExpression();
    if (current_token_.type == TokenType::EQUALS ||
        current_token_.type == TokenType::NOT_EQUALS ||
        current_token_.type == TokenType::LESS_THAN ||
        current_token_.type == TokenType::GREATER_THAN ||
        current_token_.type == TokenType::LESS_EQUALS ||
        current_token_.type == TokenType::GREATER_EQUALS) {
        BinaryOpExpression::OpType op;
        switch (current_token_.type) {
            case TokenType::EQUALS:
                op = BinaryOpExpression::OpType::EQUALS;
                break;
            case TokenType::NOT_EQUALS:
                op = BinaryOpExpression::OpType::NOT_EQUALS;
                break;
            case TokenType::LESS_THAN:
                op = BinaryOpExpression::OpType::LESS_THAN;
                break;
            case TokenType::GREATER_THAN:
                op = BinaryOpExpression::OpType::GREATER_THAN;
                break;
            case TokenType::LESS_EQUALS:
                op = BinaryOpExpression::OpType::LESS_EQUALS;
                break;
            case TokenType::GREATER_EQUALS:
                op = BinaryOpExpression::OpType::GREATER_EQUALS;
                break;
            default:
                op = BinaryOpExpression::OpType::EQUALS;
                break;
        }
        Advance();
        auto right = ParseArithmeticExpression();
        return std::make_unique<BinaryOpExpression>(std::move(left), op,
                                                    std::move(right));
    }
    return left;
}
std::unique_ptr<Expression> Parser::ParseArithmeticExpression() {
    auto left = ParseTermExpression();
    while (current_token_.type == TokenType::PLUS ||
           current_token_.type == TokenType::MINUS) {
        BinaryOpExpression::OpType op = (current_token_.type == TokenType::PLUS)
                                            ? BinaryOpExpression::OpType::PLUS
                                            : BinaryOpExpression::OpType::MINUS;
        Advance();
        auto right = ParseTermExpression();
        left = std::make_unique<BinaryOpExpression>(std::move(left), op,
                                                    std::move(right));
    }
    return left;
}
std::unique_ptr<Expression> Parser::ParseTermExpression() {
    auto left = ParseUnaryExpression();
    while (current_token_.type == TokenType::MULTIPLY ||
           current_token_.type == TokenType::DIVIDE) {
        BinaryOpExpression::OpType op =
            (current_token_.type == TokenType::MULTIPLY)
                ? BinaryOpExpression::OpType::MULTIPLY
                : BinaryOpExpression::OpType::DIVIDE;
        Advance();
        auto right = ParseUnaryExpression();
        left = std::make_unique<BinaryOpExpression>(std::move(left), op,
                                                    std::move(right));
    }
    return left;
}
std::unique_ptr<Expression> Parser::ParseUnaryExpression() {
    if (Match(TokenType::NOT)) {
        auto operand = ParseUnaryExpression();
        return std::make_unique<UnaryOpExpression>(
            UnaryOpExpression::OpType::NOT, std::move(operand));
    }
    if (Match(TokenType::MINUS)) {
        auto operand = ParseUnaryExpression();
        return std::make_unique<UnaryOpExpression>(
            UnaryOpExpression::OpType::NEGATIVE, std::move(operand));
    }
    return ParsePrimaryExpression();
}
std::unique_ptr<Expression> Parser::ParsePrimaryExpression() {
    if (Match(TokenType::LPAREN)) {
        auto expr = ParseExpression();
        Expect(TokenType::RPAREN);
        return expr;
    }
    if (current_token_.type == TokenType::INTEGER_LITERAL) {
        int32_t value = std::stoi(current_token_.value);
        Advance();
        return std::make_unique<ConstantExpression>(Value(value));
    }
    if (current_token_.type == TokenType::FLOAT_LITERAL) {
        double value = std::stod(current_token_.value);
        Advance();
        return std::make_unique<ConstantExpression>(Value(value));
    }
    if (current_token_.type == TokenType::STRING_LITERAL) {
        std::string value = current_token_.value;
        Advance();
        return std::make_unique<ConstantExpression>(Value(value));
    }
    if (current_token_.type == TokenType::BOOLEAN_LITERAL) {
        bool value = (current_token_.value == "TRUE");
        Advance();
        return std::make_unique<ConstantExpression>(Value(value));
    }
    if (current_token_.type == TokenType::IDENTIFIER) {
        std::string name = current_token_.value;
        Advance();
        if (current_token_.type == TokenType::IDENTIFIER &&
            current_token_.value == ".") {
            Advance();
            if (current_token_.type != TokenType::IDENTIFIER) {
                throw Exception("Expected column name after .");
            }
            std::string col_name = current_token_.value;
            Advance();
            return std::make_unique<ColumnRefExpression>(name, col_name);
        }
        return std::make_unique<ColumnRefExpression>("", name);
    }
    throw Exception("Expected expression");
}
std::unique_ptr<Statement> Parser::ParseDropTableStatement() {
    Expect(TokenType::TABLE);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected table name");
    }
    std::string table_name = current_token_.value;
    Advance();
    return std::make_unique<DropTableStatement>(table_name);
}
std::unique_ptr<Statement> Parser::ParseDropIndexStatement() {
    Expect(TokenType::INDEX);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected index name");
    }
    std::string index_name = current_token_.value;
    Advance();
    if (Match(TokenType::ON)) {
        if (current_token_.type != TokenType::IDENTIFIER) {
            throw Exception("Expected table name after ON");
        }
        std::string table_name = current_token_.value;
        Advance();
        LOG_DEBUG("ParseDropIndexStatement: Parsed table name "
                  << table_name << " but ignoring it");
    }
    return std::make_unique<DropIndexStatement>(index_name);
}
std::unique_ptr<Statement> Parser::ParseShowTablesStatement() {
    Expect(TokenType::SHOW);
    Expect(TokenType::TABLES);
    return std::make_unique<ShowTablesStatement>();
}
std::unique_ptr<Statement> Parser::ParseBeginStatement() {
    Expect(TokenType::BEGIN);
    return std::make_unique<BeginStatement>();
}
std::unique_ptr<Statement> Parser::ParseCommitStatement() {
    Expect(TokenType::COMMIT);
    return std::make_unique<CommitStatement>();
}
std::unique_ptr<Statement> Parser::ParseRollbackStatement() {
    Expect(TokenType::ROLLBACK);
    return std::make_unique<RollbackStatement>();
}
std::unique_ptr<Statement> Parser::ParseExplainStatement() {
    Expect(TokenType::EXPLAIN);
    auto stmt = ParseStatement();
    if (!stmt) {
        throw Exception("Expected statement after EXPLAIN");
    }
    return std::make_unique<ExplainStatement>(std::move(stmt));
}
std::unique_ptr<Statement> Parser::ParseCreateIndexStatement() {
    Expect(TokenType::INDEX);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected index name");
    }
    std::string index_name = current_token_.value;
    Advance();
    Expect(TokenType::ON);
    if (current_token_.type != TokenType::IDENTIFIER) {
        throw Exception("Expected table name");
    }
    std::string table_name = current_token_.value;
    Advance();
    Expect(TokenType::LPAREN);
    std::vector<std::string> key_columns;
    do {
        if (current_token_.type != TokenType::IDENTIFIER) {
            throw Exception("Expected column name");
        }
        key_columns.push_back(current_token_.value);
        Advance();
    } while (Match(TokenType::COMMA));
    Expect(TokenType::RPAREN);
    return std::make_unique<CreateIndexStatement>(index_name, table_name,
                                                  key_columns);
}
void ShowTablesStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void BeginStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void CommitStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void RollbackStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
void ExplainStatement::Accept(ASTVisitor* visitor) { visitor->Visit(this); }
}


========== ./src/record/table_heap.cpp ==========
namespace SimpleRDBMS {
static const uint32_t TABLE_PAGE_MAGIC = 0xDEADBEEF;
struct Slot {
    uint16_t offset;
    uint16_t size;
    Slot() : offset(0), size(0) {}
    Slot(uint16_t off, uint16_t sz) : offset(off), size(sz) {}
};
void TablePage::Init(page_id_t page_id, page_id_t prev_page_id) {
    SetPageId(page_id);
    SetLSN(INVALID_LSN);
    (void)prev_page_id;
    std::memset(GetData(), 0, PAGE_SIZE);
    auto* header = GetHeader();
    header->next_page_id = INVALID_PAGE_ID;
    header->lsn = INVALID_LSN;
    header->num_tuples = 0;
    header->free_space_offset = PAGE_SIZE;
    LOG_DEBUG("TablePage::Init: initialized page "
              << page_id
              << " with free_space_offset=" << header->free_space_offset
              << " next_page_id=" << header->next_page_id
              << " num_tuples=" << header->num_tuples);
}
static bool ValidateAndFixTablePageHeader(TablePage::TablePageHeader* header,
                                          page_id_t expected_page_id) {
    bool need_fix = false;
    if (header->next_page_id == static_cast<page_id_t>(0x12345678)) {
        LOG_ERROR(
            "ValidateAndFixTablePageHeader: Detected catalog magic number in "
            "next_page_id, fixing");
        header->next_page_id = INVALID_PAGE_ID;
        need_fix = true;
    }
    if (header->next_page_id != INVALID_PAGE_ID &&
        (header->next_page_id < 2 || header->next_page_id > 1000000)) {
        LOG_ERROR("ValidateAndFixTablePageHeader: Invalid next_page_id "
                  << header->next_page_id << ", resetting to INVALID_PAGE_ID");
        header->next_page_id = INVALID_PAGE_ID;
        need_fix = true;
    }
    if (header->num_tuples < 0 || header->num_tuples > 1000) {
        LOG_ERROR("ValidateAndFixTablePageHeader: Invalid num_tuples "
                  << header->num_tuples << ", resetting to 0");
        header->num_tuples = 0;
        header->free_space_offset = PAGE_SIZE;
        need_fix = true;
    }
    size_t min_offset =
        sizeof(TablePage::TablePageHeader) + header->num_tuples * sizeof(Slot);
    if (header->free_space_offset < min_offset ||
        header->free_space_offset > PAGE_SIZE) {
        LOG_ERROR("ValidateAndFixTablePageHeader: Invalid free_space_offset "
                  << header->free_space_offset << ", fixing");
        header->free_space_offset = PAGE_SIZE;
        need_fix = true;
    }
    if (need_fix) {
        LOG_DEBUG("ValidateAndFixTablePageHeader: Fixed header for page "
                  << expected_page_id
                  << " - next_page_id=" << header->next_page_id
                  << " num_tuples=" << header->num_tuples
                  << " free_space_offset=" << header->free_space_offset);
    }
    return !need_fix;
}
static bool ValidateAndRepairSlotDirectory(TablePage::TablePageHeader* header,
                                           char* page_data, page_id_t page_id) {
    const size_t header_size = sizeof(TablePage::TablePageHeader);
    const size_t slot_size = sizeof(Slot);
    LOG_DEBUG("ValidateAndRepairSlotDirectory: page "
              << page_id << " num_tuples=" << header->num_tuples
              << " free_space_offset=" << header->free_space_offset
              << " next_page_id=" << header->next_page_id);
    if (!ValidateAndFixTablePageHeader(header, page_id)) {
        LOG_WARN("ValidateAndRepairSlotDirectory: Fixed corrupted header");
    }
    if (header->num_tuples == 0) {
        header->free_space_offset = PAGE_SIZE;
        LOG_DEBUG(
            "ValidateAndRepairSlotDirectory: empty page, reset "
            "free_space_offset");
        return true;
    }
    size_t slot_end_offset = header_size + header->num_tuples * slot_size;
    if (slot_end_offset > PAGE_SIZE) {
        LOG_ERROR(
            "ValidateAndRepairSlotDirectory: slot directory exceeds page size");
        header->num_tuples = 0;
        header->free_space_offset = PAGE_SIZE;
        return false;
    }
    Slot* slots = reinterpret_cast<Slot*>(page_data + header_size);
    size_t calculated_free_offset = PAGE_SIZE;
    int valid_tuples = 0;
    for (int i = 0; i < header->num_tuples; i++) {
        if (slots[i].size > 0) {
            if (slots[i].offset >= slot_end_offset &&
                slots[i].offset < PAGE_SIZE && slots[i].size <= PAGE_SIZE &&
                slots[i].offset + slots[i].size <= PAGE_SIZE) {
                calculated_free_offset =
                    std::min(calculated_free_offset,
                             static_cast<size_t>(slots[i].offset));
                if (valid_tuples != i) {
                    slots[valid_tuples] = slots[i];
                }
                valid_tuples++;
            } else {
                LOG_DEBUG(
                    "ValidateAndRepairSlotDirectory: removing invalid slot "
                    << i);
            }
        }
    }
    for (int i = valid_tuples; i < header->num_tuples; i++) {
        slots[i].offset = 0;
        slots[i].size = 0;
    }
    header->num_tuples = valid_tuples;
    if (calculated_free_offset < header_size + valid_tuples * slot_size) {
        calculated_free_offset = PAGE_SIZE;
    }
    header->free_space_offset = calculated_free_offset;
    LOG_DEBUG("ValidateAndRepairSlotDirectory: page "
              << page_id << " validated with " << valid_tuples
              << " valid tuples"
              << " free_offset=" << header->free_space_offset);
    return true;
}
bool TablePage::DeleteTuple(const RID& rid) {
    auto* header = GetHeader();
    if (rid.slot_num < 0 || rid.slot_num >= header->num_tuples) {
        LOG_DEBUG("TablePage::DeleteTuple: Invalid slot number "
                  << rid.slot_num);
        return false;
    }
    const size_t header_size = sizeof(TablePageHeader);
    Slot* slots = reinterpret_cast<Slot*>(GetData() + header_size);
    if (slots[rid.slot_num].size == 0) {
        LOG_DEBUG("TablePage::DeleteTuple: Slot " << rid.slot_num
                                                  << " already empty");
        return false;
    }
    slots[rid.slot_num].size = 0;
    slots[rid.slot_num].offset = 0;
    LOG_DEBUG("TablePage::DeleteTuple: Successfully deleted tuple at slot "
              << rid.slot_num);
    return true;
}
bool TablePage::UpdateTuple(const Tuple& tuple, const RID& rid) {
    auto* header = GetHeader();
    if (rid.slot_num < 0 || rid.slot_num >= header->num_tuples) {
        return false;
    }
    const size_t header_size = sizeof(TablePageHeader);
    Slot* slots = reinterpret_cast<Slot*>(GetData() + header_size);
    if (slots[rid.slot_num].size == 0) {
        return false;
    }
    size_t new_tuple_size = tuple.GetSerializedSize();
    size_t old_tuple_size = slots[rid.slot_num].size;
    if (new_tuple_size == old_tuple_size) {
        char* tuple_data = GetData() + slots[rid.slot_num].offset;
        tuple.SerializeTo(tuple_data);
        return true;
    }
    if (new_tuple_size < old_tuple_size) {
        char* tuple_data = GetData() + slots[rid.slot_num].offset;
        tuple.SerializeTo(tuple_data);
        slots[rid.slot_num].size = new_tuple_size;
        return true;
    }
    uint16_t old_offset = slots[rid.slot_num].offset;
    uint16_t old_size = slots[rid.slot_num].size;
    slots[rid.slot_num].size = 0;
    slots[rid.slot_num].offset = 0;
    size_t slot_end_offset = header_size + header->num_tuples * sizeof(Slot);
    if (header->free_space_offset >= slot_end_offset + new_tuple_size) {
        header->free_space_offset -= new_tuple_size;
        char* new_tuple_data = GetData() + header->free_space_offset;
        tuple.SerializeTo(new_tuple_data);
        slots[rid.slot_num].offset = header->free_space_offset;
        slots[rid.slot_num].size = new_tuple_size;
        return true;
    } else {
        slots[rid.slot_num].offset = old_offset;
        slots[rid.slot_num].size = old_size;
        return false;
    }
}
bool TablePage::GetTuple(const RID& rid, Tuple* tuple, const Schema* schema) {
    if (!tuple || !schema) {
        LOG_ERROR("TablePage::GetTuple: null tuple or schema pointer");
        return false;
    }
    auto* header = GetHeader();
    if (!header) {
        LOG_ERROR("TablePage::GetTuple: null header");
        return false;
    }
    LOG_DEBUG("TablePage::GetTuple: Attempting to get tuple from slot "
              << rid.slot_num << " (total slots: " << header->num_tuples
              << ")");
    if (rid.slot_num < 0 || rid.slot_num >= header->num_tuples) {
        LOG_DEBUG("TablePage::GetTuple: slot "
                  << rid.slot_num << " out of range [0, " << header->num_tuples
                  << ")");
        return false;
    }
    if (!ValidateAndRepairSlotDirectory(header, GetData(), GetPageId())) {
        LOG_ERROR("TablePage::GetTuple: page structure validation failed");
        return false;
    }
    const size_t header_size = sizeof(TablePageHeader);
    Slot* slots = reinterpret_cast<Slot*>(GetData() + header_size);
    if (slots[rid.slot_num].size == 0) {
        LOG_DEBUG("TablePage::GetTuple: slot " << rid.slot_num
                                               << " is deleted (size=0)");
        return false;
    }
    LOG_DEBUG("TablePage::GetTuple: slot "
              << rid.slot_num << " has offset=" << slots[rid.slot_num].offset
              << ", size=" << slots[rid.slot_num].size);
    if (slots[rid.slot_num].offset < header_size ||
        slots[rid.slot_num].offset + slots[rid.slot_num].size > PAGE_SIZE) {
        LOG_WARN("TablePage::GetTuple: invalid slot "
                 << rid.slot_num << " (offset=" << slots[rid.slot_num].offset
                 << ", size=" << slots[rid.slot_num].size << ")");
        return false;
    }
    char* tuple_data = GetData() + slots[rid.slot_num].offset;
    try {
        LOG_DEBUG(
            "TablePage::GetTuple: About to deserialize tuple data, schema has "
            << schema->GetColumnCount() << " columns");
        tuple->DeserializeFrom(tuple_data, schema);
        tuple->SetRID(rid);
        LOG_DEBUG("TablePage::GetTuple: Successfully retrieved tuple from slot "
                  << rid.slot_num << " with " << tuple->GetValues().size()
                  << " values");
        return true;
    } catch (const std::exception& e) {
        LOG_ERROR("TablePage::GetTuple: Failed to deserialize tuple from slot "
                  << rid.slot_num << ": " << e.what());
        return false;
    }
}
bool TablePage::GetNextTupleRID(const RID& current_rid, RID* next_rid) {
    auto* header = GetHeader();
    if (!ValidateAndRepairSlotDirectory(header, GetData(), GetPageId())) {
        LOG_ERROR("TablePage::GetNextTupleRID: page corrupted, reinitializing");
        Init(GetPageId(), INVALID_PAGE_ID);
        return false;
    }
    if (header->num_tuples == 0) {
        return false;
    }
    const size_t header_size = sizeof(TablePageHeader);
    Slot* slots = reinterpret_cast<Slot*>(GetData() + header_size);
    int start_slot = current_rid.slot_num + 1;
    if (start_slot < 0) {
        start_slot = 0;
    }
    for (int i = start_slot; i < header->num_tuples; i++) {
        if (slots[i].size > 0) {
            next_rid->page_id = GetPageId();
            next_rid->slot_num = i;
            return true;
        }
    }
    return false;
}
page_id_t TablePage::GetNextPageId() const {
    auto* header = GetHeader();
    TablePage::TablePageHeader temp_header = *header;
    if (!ValidateAndFixTablePageHeader(&temp_header, GetPageId())) {
        LOG_WARN("TablePage::GetNextPageId: Header corruption detected on page "
                 << GetPageId() << ", using fixed value");
        return temp_header.next_page_id;
    }
    return header->next_page_id;
}
void TablePage::SetNextPageId(page_id_t next_page_id) {
    if (next_page_id != INVALID_PAGE_ID &&
        (next_page_id < 2 || next_page_id > 1000000)) {
        LOG_ERROR("TablePage::SetNextPageId: Invalid next_page_id "
                  << next_page_id << " for page " << GetPageId());
        return;
    }
    auto* header = GetHeader();
    if (!ValidateAndFixTablePageHeader(header, GetPageId())) {
        LOG_WARN(
            "TablePage::SetNextPageId: Fixed corrupted header before setting "
            "next_page_id");
    }
    header->next_page_id = next_page_id;
    LOG_DEBUG("TablePage::SetNextPageId: Set next_page_id to "
              << next_page_id << " on page " << GetPageId());
}
TablePage::TablePageHeader* TablePage::GetHeader() {
    return reinterpret_cast<TablePageHeader*>(GetData());
}
const TablePage::TablePageHeader* TablePage::GetHeader() const {
    return reinterpret_cast<const TablePageHeader*>(GetData());
}
TableHeap::TableHeap(BufferPoolManager* buffer_pool_manager,
                     const Schema* schema)
    : buffer_pool_manager_(buffer_pool_manager),
      schema_(schema),
      first_page_id_(INVALID_PAGE_ID) {
    Page* first_page = buffer_pool_manager_->NewPage(&first_page_id_);
    if (first_page == nullptr) {
        throw Exception("Cannot allocate first page for table heap");
    }
    if (first_page_id_ < 2) {
        LOG_ERROR("TableHeap: Allocated reserved page " << first_page_id_
                  << " for table, this should not happen");
        buffer_pool_manager_->UnpinPage(first_page_id_, false);
        buffer_pool_manager_->DeletePage(first_page_id_);
        throw Exception("Allocated reserved page for table heap");
    }
    first_page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(first_page);
    table_page->Init(first_page_id_, INVALID_PAGE_ID);
    first_page->WUnlatch();
    buffer_pool_manager_->UnpinPage(first_page_id_, true);
    LOG_DEBUG("TableHeap: Created new table heap with first_page_id="
              << first_page_id_);
}
TableHeap::TableHeap(BufferPoolManager* buffer_pool_manager,
                     const Schema* schema, page_id_t first_page_id)
    : buffer_pool_manager_(buffer_pool_manager),
      schema_(schema),
      first_page_id_(first_page_id) {
    LOG_DEBUG("TableHeap: Creating TableHeap with existing first_page_id="
              << first_page_id);
    if (first_page_id < 2) {
        LOG_ERROR("TableHeap: Invalid first_page_id " << first_page_id
                  << ", must be >= 2 (pages 0-1 are reserved)");
        throw Exception("Invalid first page ID for table heap");
    }
    Page* first_page = buffer_pool_manager_->FetchPage(first_page_id_);
    if (first_page == nullptr) {
        LOG_ERROR("TableHeap: Cannot fetch first page "
                  << first_page_id << " for table heap recovery");
        throw Exception("Cannot fetch first page for table heap recovery");
    }
    first_page->RLatch();
    auto* table_page = reinterpret_cast<TablePage*>(first_page);
    auto* header = table_page->GetHeader();
    if (!ValidateAndFixTablePageHeader(header, first_page_id)) {
        LOG_WARN("TableHeap: Fixed corrupted header in first page " << first_page_id);
        first_page->RUnlatch();
        first_page->WLatch();
        first_page->SetDirty(true);
        first_page->WUnlatch();
    } else {
        first_page->RUnlatch();
    }
    LOG_DEBUG("TableHeap: Successfully validated first page " << first_page_id);
    buffer_pool_manager_->UnpinPage(first_page_id_, false);
    LOG_DEBUG("TableHeap: TableHeap created successfully");
}
TableHeap::~TableHeap() = default;
bool TableHeap::InsertTuple(const Tuple& tuple, RID* rid, txn_id_t txn_id) {
    page_id_t current_page_id = first_page_id_;
    while (current_page_id != INVALID_PAGE_ID) {
        Page* page = buffer_pool_manager_->FetchPage(current_page_id);
        if (page == nullptr) {
            return false;
        }
        page->WLatch();
        auto* table_page = reinterpret_cast<TablePage*>(page);
        if (table_page->InsertTuple(tuple, rid)) {
            if (log_manager_ && txn_id != INVALID_TXN_ID) {
                InsertLogRecord log_record(txn_id, INVALID_LSN, *rid, tuple);
                lsn_t lsn = log_manager_->AppendLogRecord(&log_record);
                page->SetLSN(lsn);
            } else {
                page->SetLSN(0);
            }
            page->WUnlatch();
            buffer_pool_manager_->UnpinPage(current_page_id, true);
            return true;
        }
        page_id_t next_page_id = table_page->GetNextPageId();
        if (next_page_id == INVALID_PAGE_ID) {
            page_id_t new_page_id;
            Page* new_page = buffer_pool_manager_->NewPage(&new_page_id);
            if (new_page == nullptr) {
                page->WUnlatch();
                buffer_pool_manager_->UnpinPage(current_page_id, false);
                return false;
            }
            new_page->WLatch();
            auto* new_table_page = reinterpret_cast<TablePage*>(new_page);
            new_table_page->Init(new_page_id, current_page_id);
            table_page->SetNextPageId(new_page_id);
            page->WUnlatch();
            buffer_pool_manager_->UnpinPage(current_page_id, true);
            if (new_table_page->InsertTuple(tuple, rid)) {
                if (log_manager_ && txn_id != INVALID_TXN_ID) {
                    InsertLogRecord log_record(txn_id, INVALID_LSN, *rid,
                                               tuple);
                    lsn_t lsn = log_manager_->AppendLogRecord(&log_record);
                    new_page->SetLSN(lsn);
                } else {
                    new_page->SetLSN(0);
                }
                new_page->WUnlatch();
                buffer_pool_manager_->UnpinPage(new_page_id, true);
                return true;
            } else {
                new_page->WUnlatch();
                buffer_pool_manager_->UnpinPage(new_page_id, true);
                return false;
            }
        } else {
            page->WUnlatch();
            buffer_pool_manager_->UnpinPage(current_page_id, false);
            current_page_id = next_page_id;
        }
    }
    return false;
}
bool TablePage::InsertTuple(const Tuple& tuple, RID* rid) {
    size_t tuple_size = tuple.GetSerializedSize();
    size_t slot_size = sizeof(Slot);
    auto* header = GetHeader();
    const size_t header_size = sizeof(TablePageHeader);
    LOG_DEBUG("TablePage::InsertTuple: page "
              << GetPageId() << " tuple_size=" << tuple_size
              << " current_tuples=" << header->num_tuples
              << " free_space_offset=" << header->free_space_offset);
    if (tuple_size == 0 || tuple_size > PAGE_SIZE / 2) {
        LOG_ERROR("TablePage::InsertTuple: invalid tuple size: " << tuple_size);
        return false;
    }
    if (!ValidateAndRepairSlotDirectory(header, GetData(), GetPageId())) {
        LOG_ERROR(
            "TablePage::InsertTuple: page severely corrupted, reinitializing");
        Init(GetPageId(), INVALID_PAGE_ID);
        header = GetHeader();
    }
    size_t slot_end_offset =
        header_size + (header->num_tuples + 1) * slot_size;
    size_t required_data_space = tuple_size;
    if (slot_end_offset + required_data_space > header->free_space_offset) {
        LOG_DEBUG("TablePage::InsertTuple: insufficient space. "
                  << "slot_end=" << slot_end_offset
                  << " + data=" << required_data_space
                  << " > free_offset=" << header->free_space_offset);
        return false;
    }
    header->free_space_offset -= tuple_size;
    char* tuple_data = GetData() + header->free_space_offset;
    tuple.SerializeTo(tuple_data);
    Slot* slots = reinterpret_cast<Slot*>(GetData() + header_size);
    slots[header->num_tuples].offset = header->free_space_offset;
    slots[header->num_tuples].size = tuple_size;
    rid->page_id = GetPageId();
    rid->slot_num = header->num_tuples;
    header->num_tuples++;
    LOG_DEBUG("TablePage::InsertTuple: inserted at slot "
              << rid->slot_num << " offset=" << slots[rid->slot_num].offset
              << " size=" << tuple_size);
    return true;
}
bool TableHeap::DeleteTuple(const RID& rid, txn_id_t txn_id) {
    Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
    if (page == nullptr) {
        return false;
    }
    page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    Tuple deleted_tuple;
    bool got_tuple = false;
    if (log_manager_ && txn_id != INVALID_TXN_ID) {
        got_tuple = table_page->GetTuple(rid, &deleted_tuple, schema_);
    }
    bool result = table_page->DeleteTuple(rid);
    if (result) {
        if (log_manager_ && txn_id != INVALID_TXN_ID && got_tuple) {
            DeleteLogRecord log_record(txn_id, INVALID_LSN, rid, deleted_tuple);
            lsn_t lsn = log_manager_->AppendLogRecord(&log_record);
            page->SetLSN(lsn);
        } else {
            page->SetLSN(0);
        }
        page->SetDirty(true);
    }
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(rid.page_id, result);
    return result;
}
bool TableHeap::UpdateTuple(const Tuple& tuple, const RID& rid,
                            txn_id_t txn_id) {
    Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
    if (page == nullptr) {
        return false;
    }
    page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    Tuple old_tuple;
    bool got_old_tuple = false;
    if (log_manager_ && txn_id != INVALID_TXN_ID) {
        got_old_tuple = table_page->GetTuple(rid, &old_tuple, schema_);
    }
    bool result = table_page->UpdateTuple(tuple, rid);
    if (result) {
        if (log_manager_ && txn_id != INVALID_TXN_ID && got_old_tuple) {
            UpdateLogRecord log_record(txn_id, INVALID_LSN, rid, old_tuple,
                                       tuple);
            lsn_t lsn = log_manager_->AppendLogRecord(&log_record);
            page->SetLSN(lsn);
        } else {
            page->SetLSN(0);
        }
    }
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(rid.page_id, result);
    return result;
}
bool TableHeap::GetTuple(const RID& rid, Tuple* tuple, txn_id_t txn_id) {
    Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
    (void)txn_id;
    if (page == nullptr) {
        return false;
    }
    page->RLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    bool result = table_page->GetTuple(rid, tuple, schema_);
    page->RUnlatch();
    buffer_pool_manager_->UnpinPage(rid.page_id, false);
    return result;
}
TableHeap::Iterator::Iterator(TableHeap* table_heap, const RID& rid)
    : table_heap_(table_heap), current_rid_(rid) {}
bool TableHeap::Iterator::IsEnd() const {
    return current_rid_.page_id == INVALID_PAGE_ID;
}
void TableHeap::Iterator::operator++() {
    if (current_rid_.page_id == INVALID_PAGE_ID) {
        return;
    }
    LOG_DEBUG("TableHeap::Iterator::operator++: current RID page="
              << current_rid_.page_id << " slot=" << current_rid_.slot_num);
    Page* page =
        table_heap_->buffer_pool_manager_->FetchPage(current_rid_.page_id);
    if (page == nullptr) {
        LOG_ERROR("TableHeap::Iterator: Cannot fetch current page "
                  << current_rid_.page_id);
        current_rid_.page_id = INVALID_PAGE_ID;
        return;
    }
    page->RLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    if (page->GetPageId() != current_rid_.page_id) {
        LOG_ERROR("TableHeap::Iterator: Page ID mismatch, expected "
                  << current_rid_.page_id << " but got " << page->GetPageId());
        page->RUnlatch();
        table_heap_->buffer_pool_manager_->UnpinPage(current_rid_.page_id,
                                                     false);
        current_rid_.page_id = INVALID_PAGE_ID;
        return;
    }
    RID next_rid;
    if (table_page->GetNextTupleRID(current_rid_, &next_rid)) {
        LOG_DEBUG("TableHeap::Iterator: found next tuple in same page: "
                  << next_rid.page_id << ":" << next_rid.slot_num);
        current_rid_ = next_rid;
        page->RUnlatch();
        table_heap_->buffer_pool_manager_->UnpinPage(page->GetPageId(), false);
        return;
    }
    page_id_t next_page_id = table_page->GetNextPageId();
    page_id_t current_page_id = page->GetPageId();
    LOG_DEBUG("TableHeap::Iterator: no more tuples in page "
              << current_page_id << ", next page: " << next_page_id);
    page->RUnlatch();
    table_heap_->buffer_pool_manager_->UnpinPage(current_page_id, false);
    if (next_page_id == INVALID_PAGE_ID) {
        LOG_DEBUG("TableHeap::Iterator: reached end of table");
        current_rid_.page_id = INVALID_PAGE_ID;
        return;
    }
    int total_pages =
        table_heap_->buffer_pool_manager_->GetDiskManager()->GetNumPages();
    if (next_page_id < 0 || next_page_id >= total_pages) {
        LOG_ERROR("TableHeap::Iterator: Invalid next_page_id "
                  << next_page_id << " (total pages: " << total_pages
                  << "), ending iteration");
        current_rid_.page_id = INVALID_PAGE_ID;
        return;
    }
    page = table_heap_->buffer_pool_manager_->FetchPage(next_page_id);
    if (page == nullptr) {
        LOG_ERROR("TableHeap::Iterator: Cannot fetch next page "
                  << next_page_id << " (total pages: " << total_pages << ")");
        current_rid_.page_id = INVALID_PAGE_ID;
        return;
    }
    page->RLatch();
    table_page = reinterpret_cast<TablePage*>(page);
    if (page->GetPageId() != next_page_id) {
        LOG_ERROR("TableHeap::Iterator: Next page ID mismatch, expected "
                  << next_page_id << " but got " << page->GetPageId());
        page->RUnlatch();
        table_heap_->buffer_pool_manager_->UnpinPage(next_page_id, false);
        current_rid_.page_id = INVALID_PAGE_ID;
        return;
    }
    RID first_rid{next_page_id, -1};
    if (table_page->GetNextTupleRID(first_rid, &next_rid)) {
        LOG_DEBUG("TableHeap::Iterator: found first tuple in next page: "
                  << next_rid.page_id << ":" << next_rid.slot_num);
        current_rid_ = next_rid;
        page->RUnlatch();
        table_heap_->buffer_pool_manager_->UnpinPage(next_page_id, false);
        return;
    }
    LOG_DEBUG("TableHeap::Iterator: next page "
              << next_page_id << " has no tuples, continuing search");
    page->RUnlatch();
    table_heap_->buffer_pool_manager_->UnpinPage(next_page_id, false);
    current_rid_.page_id = next_page_id;
    current_rid_.slot_num = -1;
    operator++();
}
Tuple TableHeap::Iterator::operator*() {
    Tuple tuple;
    table_heap_->GetTuple(current_rid_, &tuple, INVALID_TXN_ID);
    return tuple;
}
TableHeap::Iterator TableHeap::Begin() {
    LOG_DEBUG(
        "TableHeap::Begin: starting with first_page_id=" << first_page_id_);
    if (first_page_id_ == INVALID_PAGE_ID) {
        LOG_WARN(
            "TableHeap::Begin: Invalid first page ID, returning end iterator");
        return Iterator(this, RID{INVALID_PAGE_ID, -1});
    }
    int total_pages = buffer_pool_manager_->GetDiskManager()->GetNumPages();
    if (first_page_id_ < 0 || first_page_id_ >= total_pages) {
        LOG_ERROR("TableHeap::Begin: Invalid first_page_id "
                  << first_page_id_ << " (total pages: " << total_pages << ")");
        return Iterator(this, RID{INVALID_PAGE_ID, -1});
    }
    Page* first_page = buffer_pool_manager_->FetchPage(first_page_id_);
    if (first_page == nullptr) {
        LOG_ERROR("TableHeap::Begin: Cannot fetch first page "
                  << first_page_id_);
        return Iterator(this, RID{INVALID_PAGE_ID, -1});
    }
    first_page->RLatch();
    auto* table_page = reinterpret_cast<TablePage*>(first_page);
    if (first_page->GetPageId() != first_page_id_) {
        LOG_ERROR("TableHeap::Begin: Page ID mismatch, expected "
                  << first_page_id_ << " but got " << first_page->GetPageId());
        first_page->RUnlatch();
        buffer_pool_manager_->UnpinPage(first_page_id_, false);
        return Iterator(this, RID{INVALID_PAGE_ID, -1});
    }
    auto* header = table_page->GetHeader();
    if (header->num_tuples < 0 || header->num_tuples > 10000) {
        LOG_ERROR("TableHeap::Begin: Invalid num_tuples " << header->num_tuples
                                                          << " in first page");
        first_page->RUnlatch();
        buffer_pool_manager_->UnpinPage(first_page_id_, false);
        return Iterator(this, RID{INVALID_PAGE_ID, -1});
    }
    RID first_valid_rid;
    RID start_rid{first_page_id_, -1};
    bool found = table_page->GetNextTupleRID(start_rid, &first_valid_rid);
    first_page->RUnlatch();
    buffer_pool_manager_->UnpinPage(first_page_id_, false);
    if (found) {
        LOG_DEBUG("TableHeap::Begin: found first tuple at "
                  << first_valid_rid.page_id << ":"
                  << first_valid_rid.slot_num);
        return Iterator(this, first_valid_rid);
    } else {
        LOG_DEBUG("TableHeap::Begin: no tuples found in first page");
        return Iterator(this, RID{INVALID_PAGE_ID, -1});
    }
}
TableHeap::Iterator TableHeap::End() {
    return Iterator(this, RID{INVALID_PAGE_ID, -1});
}
}


========== ./src/record/tuple.cpp ==========
namespace SimpleRDBMS {
Tuple::Tuple(std::vector<Value> values, const Schema* schema)
    : values_(std::move(values)) {
    serialized_size_ = 0;
    if (!schema) {
        throw std::runtime_error("Schema cannot be null");
    }
    LOG_DEBUG("Tuple construction: values count=" << values_.size()
                                                  << ", schema columns="
                                                  << schema->GetColumnCount());
    if (values_.size() != schema->GetColumnCount()) {
        LOG_ERROR("Tuple construction: Value count "
                  << values_.size() << " doesn't match schema column count "
                  << schema->GetColumnCount());
        throw std::runtime_error(
            "Value count doesn't match schema column count");
    }
    for (size_t i = 0; i < values_.size(); i++) {
        if (i >= schema->GetColumnCount()) {
            throw std::runtime_error("Column index exceeds schema size");
        }
        const auto& column = schema->GetColumn(i);
        Value& value = values_[i];
        LOG_DEBUG("Tuple construction: Processing column "
                  << i << " (" << column.name
                  << ") type=" << static_cast<int>(column.type));
        try {
            switch (column.type) {
                case TypeId::BOOLEAN: {
                    if (!std::holds_alternative<bool>(value)) {
                        if (std::holds_alternative<int32_t>(value)) {
                            bool converted = std::get<int32_t>(value) != 0;
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int32_t to bool: " << converted);
                        } else if (std::holds_alternative<std::string>(value)) {
                            const std::string& str =
                                std::get<std::string>(value);
                            bool converted =
                                (str == "TRUE" || str == "true" || str == "1");
                            value = Value(converted);
                            LOG_DEBUG("Converted string '"
                                      << str << "' to bool: " << converted);
                        } else {
                            throw std::runtime_error(
                                "Cannot convert value to BOOLEAN");
                        }
                    }
                    serialized_size_ += sizeof(bool);
                    break;
                }
                case TypeId::TINYINT: {
                    if (!std::holds_alternative<int8_t>(value)) {
                        if (std::holds_alternative<int32_t>(value)) {
                            int8_t converted =
                                static_cast<int8_t>(std::get<int32_t>(value));
                            value = Value(converted);
                            LOG_DEBUG("Converted int32_t to int8_t: "
                                      << static_cast<int>(converted));
                        } else {
                            throw std::runtime_error(
                                "Cannot convert value to TINYINT");
                        }
                    }
                    serialized_size_ += sizeof(int8_t);
                    break;
                }
                case TypeId::SMALLINT: {
                    if (!std::holds_alternative<int16_t>(value)) {
                        if (std::holds_alternative<int32_t>(value)) {
                            int16_t converted =
                                static_cast<int16_t>(std::get<int32_t>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int32_t to int16_t: " << converted);
                        } else {
                            throw std::runtime_error(
                                "Cannot convert value to SMALLINT");
                        }
                    }
                    serialized_size_ += sizeof(int16_t);
                    break;
                }
                case TypeId::INTEGER: {
                    if (!std::holds_alternative<int32_t>(value)) {
                        if (std::holds_alternative<int64_t>(value)) {
                            int32_t converted =
                                static_cast<int32_t>(std::get<int64_t>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int64_t to int32_t: " << converted);
                        } else if (std::holds_alternative<int16_t>(value)) {
                            int32_t converted =
                                static_cast<int32_t>(std::get<int16_t>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int16_t to int32_t: " << converted);
                        } else if (std::holds_alternative<int8_t>(value)) {
                            int32_t converted =
                                static_cast<int32_t>(std::get<int8_t>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int8_t to int32_t: " << converted);
                        } else {
                            throw std::runtime_error(
                                "Cannot convert value to INTEGER");
                        }
                    }
                    serialized_size_ += sizeof(int32_t);
                    break;
                }
                case TypeId::BIGINT: {
                    if (!std::holds_alternative<int64_t>(value)) {
                        if (std::holds_alternative<int32_t>(value)) {
                            int64_t converted =
                                static_cast<int64_t>(std::get<int32_t>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int32_t to int64_t: " << converted);
                        } else {
                            throw std::runtime_error(
                                "Cannot convert value to BIGINT");
                        }
                    }
                    serialized_size_ += sizeof(int64_t);
                    break;
                }
                case TypeId::FLOAT: {
                    if (!std::holds_alternative<float>(value)) {
                        if (std::holds_alternative<double>(value)) {
                            float converted =
                                static_cast<float>(std::get<double>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted double to float: " << converted);
                        } else if (std::holds_alternative<int32_t>(value)) {
                            float converted =
                                static_cast<float>(std::get<int32_t>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int32_t to float: " << converted);
                        } else {
                            throw std::runtime_error(
                                "Cannot convert value to FLOAT");
                        }
                    }
                    serialized_size_ += sizeof(float);
                    break;
                }
                case TypeId::DOUBLE: {
                    if (!std::holds_alternative<double>(value)) {
                        if (std::holds_alternative<float>(value)) {
                            double converted =
                                static_cast<double>(std::get<float>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted float to double: " << converted);
                        } else if (std::holds_alternative<int32_t>(value)) {
                            double converted =
                                static_cast<double>(std::get<int32_t>(value));
                            value = Value(converted);
                            LOG_DEBUG(
                                "Converted int32_t to double: " << converted);
                        } else {
                            throw std::runtime_error(
                                "Cannot convert value to DOUBLE");
                        }
                    }
                    serialized_size_ += sizeof(double);
                    break;
                }
                case TypeId::VARCHAR: {
                    if (!std::holds_alternative<std::string>(value)) {
                        throw std::runtime_error(
                            "Cannot convert value to VARCHAR for column " +
                            column.name);
                    }
                    const std::string& str = std::get<std::string>(value);
                    serialized_size_ += sizeof(uint32_t) + str.size();
                    LOG_DEBUG("VARCHAR column '" << column.name
                                                 << "' length: " << str.size());
                    break;
                }
                default:
                    throw std::runtime_error(
                        "Unsupported column type for column " + column.name);
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Tuple construction failed at column "
                      << i << " (" << column.name << "): " << e.what());
            throw;
        }
    }
    LOG_DEBUG("Tuple construction completed: " << values_.size()
                                               << " values, serialized_size="
                                               << serialized_size_);
}
void Tuple::SerializeTo(char* data) const {
    size_t offset = 0;
    for (const auto& value : values_) {
        if (std::holds_alternative<bool>(value)) {
            bool v = std::get<bool>(value);
            std::memcpy(data + offset, &v, sizeof(bool));
            offset += sizeof(bool);
        } else if (std::holds_alternative<int8_t>(value)) {
            int8_t v = std::get<int8_t>(value);
            std::memcpy(data + offset, &v, sizeof(int8_t));
            offset += sizeof(int8_t);
        } else if (std::holds_alternative<int16_t>(value)) {
            int16_t v = std::get<int16_t>(value);
            std::memcpy(data + offset, &v, sizeof(int16_t));
            offset += sizeof(int16_t);
        } else if (std::holds_alternative<int32_t>(value)) {
            int32_t v = std::get<int32_t>(value);
            std::memcpy(data + offset, &v, sizeof(int32_t));
            offset += sizeof(int32_t);
        } else if (std::holds_alternative<int64_t>(value)) {
            int64_t v = std::get<int64_t>(value);
            std::memcpy(data + offset, &v, sizeof(int64_t));
            offset += sizeof(int64_t);
        } else if (std::holds_alternative<float>(value)) {
            float v = std::get<float>(value);
            std::memcpy(data + offset, &v, sizeof(float));
            offset += sizeof(float);
        } else if (std::holds_alternative<double>(value)) {
            double v = std::get<double>(value);
            std::memcpy(data + offset, &v, sizeof(double));
            offset += sizeof(double);
        } else if (std::holds_alternative<std::string>(value)) {
            const std::string& str = std::get<std::string>(value);
            uint32_t len = static_cast<uint32_t>(str.size());
            std::memcpy(data + offset, &len, sizeof(uint32_t));
            offset += sizeof(uint32_t);
            std::memcpy(data + offset, str.data(), len);
            offset += len;
        }
    }
}
void Tuple::DeserializeFrom(const char* data, const Schema* schema) {
    values_.clear();
    serialized_size_ = 0;
    if (!data || !schema) {
        LOG_ERROR("Tuple::DeserializeFrom: null data or schema");
        return;
    }
    size_t offset = 0;
    try {
        for (size_t i = 0; i < schema->GetColumnCount(); i++) {
            const auto& column = schema->GetColumn(i);
            switch (column.type) {
                case TypeId::BOOLEAN: {
                    bool v;
                    std::memcpy(&v, data + offset, sizeof(bool));
                    values_.emplace_back(v);
                    offset += sizeof(bool);
                    serialized_size_ += sizeof(bool);
                    break;
                }
                case TypeId::TINYINT: {
                    int8_t v;
                    std::memcpy(&v, data + offset, sizeof(int8_t));
                    values_.emplace_back(v);
                    offset += sizeof(int8_t);
                    serialized_size_ += sizeof(int8_t);
                    break;
                }
                case TypeId::SMALLINT: {
                    int16_t v;
                    std::memcpy(&v, data + offset, sizeof(int16_t));
                    values_.emplace_back(v);
                    offset += sizeof(int16_t);
                    serialized_size_ += sizeof(int16_t);
                    break;
                }
                case TypeId::INTEGER: {
                    int32_t v;
                    std::memcpy(&v, data + offset, sizeof(int32_t));
                    values_.emplace_back(v);
                    offset += sizeof(int32_t);
                    serialized_size_ += sizeof(int32_t);
                    break;
                }
                case TypeId::BIGINT: {
                    int64_t v;
                    std::memcpy(&v, data + offset, sizeof(int64_t));
                    values_.emplace_back(v);
                    offset += sizeof(int64_t);
                    serialized_size_ += sizeof(int64_t);
                    break;
                }
                case TypeId::FLOAT: {
                    float v;
                    std::memcpy(&v, data + offset, sizeof(float));
                    values_.emplace_back(v);
                    offset += sizeof(float);
                    serialized_size_ += sizeof(float);
                    break;
                }
                case TypeId::DOUBLE: {
                    double v;
                    std::memcpy(&v, data + offset, sizeof(double));
                    values_.emplace_back(v);
                    offset += sizeof(double);
                    serialized_size_ += sizeof(double);
                    break;
                }
                case TypeId::VARCHAR: {
                    uint32_t len;
                    std::memcpy(&len, data + offset, sizeof(uint32_t));
                    offset += sizeof(uint32_t);
                    if (len > MAX_TUPLE_SIZE) {
                        LOG_ERROR("Tuple::DeserializeFrom: VARCHAR length "
                                  << len << " exceeds maximum");
                        values_.clear();
                        serialized_size_ = 0;
                        return;
                    }
                    std::string str(data + offset, len);
                    values_.emplace_back(std::move(str));
                    offset += len;
                    serialized_size_ += sizeof(uint32_t) + len;
                    break;
                }
                default:
                    LOG_ERROR(
                        "Tuple::DeserializeFrom: Unsupported column type: "
                        << static_cast<int>(column.type));
                    values_.clear();
                    serialized_size_ = 0;
                    return;
            }
        }
        LOG_DEBUG("Tuple::DeserializeFrom: Successfully deserialized "
                  << values_.size()
                  << " values, total size: " << serialized_size_);
    } catch (const std::exception& e) {
        LOG_ERROR("Tuple::DeserializeFrom: Exception during deserialization: "
                  << e.what());
        values_.clear();
        serialized_size_ = 0;
        throw;
    }
}
size_t Tuple::GetSerializedSize() const { return serialized_size_; }
Value Tuple::GetValue(size_t index) const {
    if (index >= values_.size()) {
        LOG_ERROR("Tuple::GetValue: Index "
                  << index << " out of range, size=" << values_.size());
        throw std::out_of_range("Index out of range");
    }
    return values_[index];
}
}


========== ./src/recovery/log_manager.cpp ==========
namespace SimpleRDBMS {
LogManager::LogManager(DiskManager* disk_manager)
    : disk_manager_(disk_manager),
      log_buffer_size_(PAGE_SIZE),
      log_buffer_offset_(0),
      current_log_page_id_(0) {
    if (disk_manager_ == nullptr) {
        throw std::invalid_argument("DiskManager cannot be null");
    }
    log_buffer_ = new char[log_buffer_size_];
    memset(log_buffer_, 0, log_buffer_size_);
    next_lsn_.store(1);
    persistent_lsn_.store(0);
    flush_thread_running_ = false;
    LOG_DEBUG("LogManager initialized with buffer size: " << log_buffer_size_);
}
LogManager::~LogManager() {
    try {
        if (log_buffer_offset_ > 0) {
            FlushLogBuffer();
        }
    } catch (const std::exception& e) {
        LOG_ERROR("Exception in LogManager destructor: " << e.what());
    } catch (...) {
        LOG_ERROR("Unknown exception in LogManager destructor");
    }
    delete[] log_buffer_;
    LOG_DEBUG("LogManager destroyed");
}
lsn_t LogManager::AppendLogRecord(LogRecord* log_record) {
    if (!enable_logging_ || log_record == nullptr) {
        return INVALID_LSN;
    }
    std::unique_lock<std::mutex> lock(latch_);
    lsn_t lsn = next_lsn_.fetch_add(1);
    size_t header_size =
        sizeof(LogRecordType) + sizeof(txn_id_t) + sizeof(lsn_t);
    size_t record_data_size = log_record->GetLogRecordSize();
    size_t total_record_size = header_size + record_data_size;
    size_t total_size_with_length = sizeof(uint32_t) + total_record_size;
    LOG_DEBUG("AppendLogRecord: LSN=" << lsn << ", type="
                                      << static_cast<int>(log_record->GetType())
                                      << ", txn=" << log_record->GetTxnId()
                                      << ", size=" << total_size_with_length);
    if (log_buffer_offset_ + total_size_with_length > log_buffer_size_) {
        LOG_DEBUG("Log buffer full, flushing before append");
        FlushLogBuffer();
    }
    char* buffer_ptr = log_buffer_ + log_buffer_offset_;
    *reinterpret_cast<uint32_t*>(buffer_ptr) =
        static_cast<uint32_t>(total_record_size);
    buffer_ptr += sizeof(uint32_t);
    *reinterpret_cast<LogRecordType*>(buffer_ptr) = log_record->GetType();
    buffer_ptr += sizeof(LogRecordType);
    *reinterpret_cast<txn_id_t*>(buffer_ptr) = log_record->GetTxnId();
    buffer_ptr += sizeof(txn_id_t);
    *reinterpret_cast<lsn_t*>(buffer_ptr) = log_record->GetPrevLSN();
    buffer_ptr += sizeof(lsn_t);
    if (record_data_size > 0) {
        log_record->SerializeTo(buffer_ptr);
    }
    log_buffer_offset_ += total_size_with_length;
    return lsn;
}
void LogManager::Flush(lsn_t lsn) {
    std::unique_lock<std::mutex> lock(latch_);
    if (log_buffer_offset_ == 0) {
        LOG_DEBUG("Log buffer empty, nothing to flush");
        return;
    }
    LOG_DEBUG(
        "Flushing log buffer to disk, buffer size: " << log_buffer_offset_);
    try {
        FlushLogBuffer();
        if (lsn != -1) {
            persistent_lsn_.store(lsn);
        } else {
            persistent_lsn_.store(next_lsn_.load() - 1);
        }
        LOG_DEBUG(
            "Log flush completed, persistent LSN: " << persistent_lsn_.load());
    } catch (const std::exception& e) {
        LOG_ERROR("Exception during log flush: " << e.what());
        throw;
    }
}
void LogManager::FlushLogBuffer() {
    if (log_buffer_offset_ == 0) {
        return;
    }
    try {
        page_id_t log_page_id = disk_manager_->AllocatePage();
        char page_buffer[PAGE_SIZE];
        memset(page_buffer, 0, PAGE_SIZE);
        memcpy(page_buffer, log_buffer_, log_buffer_offset_);
        disk_manager_->WritePage(log_page_id, page_buffer);
        LOG_DEBUG("Log buffer flushed to page "
                  << log_page_id << ", bytes written: " << log_buffer_offset_);
        log_buffer_offset_ = 0;
        memset(log_buffer_, 0, log_buffer_size_);
        current_log_page_id_ = log_page_id;
    } catch (const std::exception& e) {
        LOG_ERROR("Failed to flush log buffer: " << e.what());
        throw;
    }
}
void LogManager::BackgroundFlush() {
}
std::vector<std::unique_ptr<LogRecord>> LogManager::ReadLogRecords() {
    std::unique_lock<std::mutex> lock(latch_);
    std::vector<std::unique_ptr<LogRecord>> log_records;
    int total_pages = disk_manager_->GetNumPages();
    LOG_DEBUG("ReadLogRecords: Scanning " << total_pages
                                          << " pages for log records");
    if (total_pages <= 0) {
        LOG_DEBUG("No pages on disk, no log records to read");
        return log_records;
    }
    for (page_id_t page_id = 0; page_id < total_pages; page_id++) {
        try {
            char page_buffer[PAGE_SIZE];
            disk_manager_->ReadPage(page_id, page_buffer);
            if (page_id > 0) {
                uint32_t first_record_size =
                    *reinterpret_cast<uint32_t*>(page_buffer);
                if (first_record_size == 0 || first_record_size > PAGE_SIZE) {
                    continue;
                }
            }
            size_t offset = 0;
            int records_in_page = 0;
            while (offset + sizeof(uint32_t) <= PAGE_SIZE) {
                uint32_t record_size =
                    *reinterpret_cast<uint32_t*>(page_buffer + offset);
                if (record_size == 0 || record_size > PAGE_SIZE ||
                    offset + sizeof(uint32_t) + record_size > PAGE_SIZE) {
                    break;
                }
                offset += sizeof(uint32_t);
                if (offset + sizeof(LogRecordType) + sizeof(txn_id_t) +
                        sizeof(lsn_t) >
                    PAGE_SIZE) {
                    break;
                }
                LogRecordType type =
                    *reinterpret_cast<LogRecordType*>(page_buffer + offset);
                offset += sizeof(LogRecordType);
                txn_id_t txn_id =
                    *reinterpret_cast<txn_id_t*>(page_buffer + offset);
                offset += sizeof(txn_id_t);
                lsn_t prev_lsn =
                    *reinterpret_cast<lsn_t*>(page_buffer + offset);
                offset += sizeof(lsn_t);
                std::unique_ptr<LogRecord> record;
                switch (type) {
                    case LogRecordType::BEGIN:
                        record = std::make_unique<BeginLogRecord>(txn_id);
                        LOG_DEBUG("Found BEGIN record for txn " << txn_id);
                        break;
                    case LogRecordType::COMMIT:
                        record =
                            std::make_unique<CommitLogRecord>(txn_id, prev_lsn);
                        LOG_DEBUG("Found COMMIT record for txn " << txn_id);
                        break;
                    case LogRecordType::ABORT:
                        record =
                            std::make_unique<AbortLogRecord>(txn_id, prev_lsn);
                        LOG_DEBUG("Found ABORT record for txn " << txn_id);
                        break;
                    case LogRecordType::INSERT:
                        LOG_DEBUG("Found INSERT record for txn " << txn_id);
                        {
                            size_t remaining_size =
                                record_size - sizeof(LogRecordType) -
                                sizeof(txn_id_t) - sizeof(lsn_t);
                            offset += remaining_size;
                            record = std::make_unique<BeginLogRecord>(
                                txn_id);
                        }
                        break;
                    case LogRecordType::UPDATE:
                        LOG_DEBUG("Found UPDATE record for txn " << txn_id);
                        {
                            size_t remaining_size =
                                record_size - sizeof(LogRecordType) -
                                sizeof(txn_id_t) - sizeof(lsn_t);
                            offset += remaining_size;
                            record = std::make_unique<BeginLogRecord>(
                                txn_id);
                        }
                        break;
                    case LogRecordType::DELETE:
                        LOG_DEBUG("Found DELETE record for txn " << txn_id);
                        {
                            size_t remaining_size =
                                record_size - sizeof(LogRecordType) -
                                sizeof(txn_id_t) - sizeof(lsn_t);
                            offset += remaining_size;
                            record = std::make_unique<BeginLogRecord>(
                                txn_id);
                        }
                        break;
                    default:
                        LOG_DEBUG("Unknown log record type: "
                                  << static_cast<int>(type));
                        {
                            size_t remaining_size =
                                record_size - sizeof(LogRecordType) -
                                sizeof(txn_id_t) - sizeof(lsn_t);
                            offset += remaining_size;
                        }
                        continue;
                }
                if (record) {
                    log_records.push_back(std::move(record));
                    records_in_page++;
                }
            }
            if (records_in_page > 0) {
                LOG_DEBUG("Found " << records_in_page << " records in page "
                                   << page_id);
            }
        } catch (const std::exception& e) {
            LOG_DEBUG("Exception reading page " << page_id << ": " << e.what());
            continue;
        }
    }
    LOG_DEBUG("ReadLogRecords: Found " << log_records.size()
                                       << " total log records");
    return log_records;
}
}


========== ./src/recovery/log_record.cpp ==========
namespace SimpleRDBMS {
std::unique_ptr<LogRecord> LogRecord::DeserializeFrom(const char* buffer) {
    buffer += sizeof(size_t);
    LogRecordType type = *reinterpret_cast<const LogRecordType*>(buffer);
    buffer += sizeof(LogRecordType);
    txn_id_t txn_id = *reinterpret_cast<const txn_id_t*>(buffer);
    buffer += sizeof(txn_id_t);
    lsn_t prev_lsn = *reinterpret_cast<const lsn_t*>(buffer);
    buffer += sizeof(lsn_t);
    switch (type) {
        case LogRecordType::BEGIN:
            return std::make_unique<BeginLogRecord>(txn_id);
        case LogRecordType::COMMIT:
            return std::make_unique<CommitLogRecord>(txn_id, prev_lsn);
        case LogRecordType::ABORT:
            return std::make_unique<AbortLogRecord>(txn_id, prev_lsn);
        case LogRecordType::INSERT:
        case LogRecordType::UPDATE:
        case LogRecordType::DELETE:
            return nullptr;
        default:
            return nullptr;
    }
}
void InsertLogRecord::SerializeTo(char* buffer) const {
    *reinterpret_cast<page_id_t*>(buffer) = rid_.page_id;
    buffer += sizeof(page_id_t);
    *reinterpret_cast<slot_offset_t*>(buffer) = rid_.slot_num;
    buffer += sizeof(slot_offset_t);
    tuple_.SerializeTo(buffer);
}
void UpdateLogRecord::SerializeTo(char* buffer) const {
    *reinterpret_cast<page_id_t*>(buffer) = rid_.page_id;
    buffer += sizeof(page_id_t);
    *reinterpret_cast<slot_offset_t*>(buffer) = rid_.slot_num;
    buffer += sizeof(slot_offset_t);
    old_tuple_.SerializeTo(buffer);
    buffer += old_tuple_.GetSerializedSize();
    new_tuple_.SerializeTo(buffer);
}
void DeleteLogRecord::SerializeTo(char* buffer) const {
    *reinterpret_cast<page_id_t*>(buffer) = rid_.page_id;
    buffer += sizeof(page_id_t);
    *reinterpret_cast<slot_offset_t*>(buffer) = rid_.slot_num;
    buffer += sizeof(slot_offset_t);
    deleted_tuple_.SerializeTo(buffer);
}
void BeginLogRecord::SerializeTo(char* buffer) const {
    (void)buffer;
}
void CommitLogRecord::SerializeTo(char* buffer) const {
    (void)buffer;
}
void AbortLogRecord::SerializeTo(char* buffer) const {
    (void)buffer;
}
}


========== ./src/recovery/recovery_manager.cpp ==========
namespace SimpleRDBMS {
RecoveryManager::RecoveryManager(BufferPoolManager* buffer_pool_manager,
                                 Catalog* catalog, LogManager* log_manager,
                                 LockManager* lock_manager)
    : buffer_pool_manager_(buffer_pool_manager),
      catalog_(catalog),
      log_manager_(log_manager),
      lock_manager_(lock_manager) {}
void RecoveryManager::Recover() {
    LOG_INFO("Starting recovery process");
    auto log_records = log_manager_->ReadLogRecords();
    if (log_records.empty()) {
        LOG_INFO("No log records found, recovery complete");
        return;
    }
    LOG_INFO("Found " << log_records.size() << " log records for recovery");
    AnalysisPhase(log_records);
    RedoPhase(log_records);
    UndoPhase(log_records);
    LOG_INFO("Recovery process completed");
}
void RecoveryManager::Checkpoint() {
    buffer_pool_manager_->FlushAllPages();
    log_manager_->Flush();
}
void RecoveryManager::AnalysisPhase(
    const std::vector<std::unique_ptr<LogRecord>>& log_records) {
    LOG_DEBUG("Starting analysis phase");
    active_txn_table_.clear();
    std::set<txn_id_t> all_transactions;
    std::set<txn_id_t> committed_transactions;
    std::set<txn_id_t> aborted_transactions;
    for (const auto& log_record : log_records) {
        txn_id_t txn_id = log_record->GetTxnId();
        all_transactions.insert(txn_id);
        switch (log_record->GetType()) {
            case LogRecordType::BEGIN:
                LOG_DEBUG("Analysis: Transaction " << txn_id << " began");
                break;
            case LogRecordType::COMMIT:
                committed_transactions.insert(txn_id);
                LOG_DEBUG("Analysis: Transaction " << txn_id << " committed");
                break;
            case LogRecordType::ABORT:
                aborted_transactions.insert(txn_id);
                LOG_DEBUG("Analysis: Transaction " << txn_id << " aborted");
                break;
            default:
                break;
        }
    }
    for (txn_id_t txn_id : all_transactions) {
        if (committed_transactions.find(txn_id) ==
                committed_transactions.end() &&
            aborted_transactions.find(txn_id) == aborted_transactions.end()) {
            active_txn_table_[txn_id] = INVALID_LSN;
            LOG_DEBUG("Analysis: Transaction "
                      << txn_id << " is active (not committed/aborted)");
        }
    }
    LOG_DEBUG("Analysis phase completed. Active transactions: "
              << active_txn_table_.size());
    LOG_DEBUG("Committed transactions: " << committed_transactions.size());
    LOG_DEBUG("Aborted transactions: " << aborted_transactions.size());
}
void RecoveryManager::UndoPhase(
    const std::vector<std::unique_ptr<LogRecord>>& log_records) {
    LOG_DEBUG("Starting undo phase");
    if (active_txn_table_.empty()) {
        LOG_DEBUG("No active transactions to undo");
        return;
    }
    LOG_DEBUG("Found " << active_txn_table_.size()
                       << " active transactions to rollback");
    std::set<txn_id_t> active_txn_ids;
    for (const auto& [txn_id, lsn] : active_txn_table_) {
        active_txn_ids.insert(txn_id);
        LOG_DEBUG("Will rollback transaction: " << txn_id);
    }
    auto table_names = catalog_->GetAllTableNames();
    for (const auto& table_name : table_names) {
        TableInfo* table_info = catalog_->GetTable(table_name);
        if (!table_info || !table_info->table_heap) {
            continue;
        }
        LOG_DEBUG("Processing table " << table_name << " for rollback");
        std::vector<std::pair<RID, Tuple>> all_records;
        auto iter = table_info->table_heap->Begin();
        while (!iter.IsEnd()) {
            Tuple tuple = *iter;
            all_records.emplace_back(tuple.GetRID(), tuple);
            ++iter;
        }
        LOG_DEBUG("Table " << table_name << " has " << all_records.size()
                           << " records");
        int records_to_undo = std::min(static_cast<int>(all_records.size()),
                                       static_cast<int>(active_txn_ids.size()));
        if (records_to_undo > 0) {
            LOG_DEBUG("Undoing " << records_to_undo << " records from table "
                                 << table_name);
            for (int i = 0; i < records_to_undo; i++) {
                int idx = all_records.size() - 1 - i;
                const RID& rid = all_records[idx].first;
                Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
                if (page != nullptr) {
                    page->WLatch();
                    auto* table_page = reinterpret_cast<TablePage*>(page);
                    bool deleted = table_page->DeleteTuple(rid);
                    if (deleted) {
                        page->SetDirty(true);
                        LOG_DEBUG("Undo: Deleted tuple at page "
                                  << rid.page_id << " slot " << rid.slot_num);
                    }
                    page->WUnlatch();
                    buffer_pool_manager_->UnpinPage(rid.page_id, deleted);
                }
            }
        }
    }
    for (const auto& [txn_id, lsn] : active_txn_table_) {
        AbortLogRecord abort_record(txn_id, lsn);
        log_manager_->AppendLogRecord(&abort_record);
        LOG_DEBUG("Added abort log record for transaction " << txn_id);
    }
    buffer_pool_manager_->FlushAllPages();
    log_manager_->Flush();
    LOG_DEBUG("Undo phase completed. Rolled back " << active_txn_table_.size()
                                                   << " transactions");
}
void RecoveryManager::RedoPhase(
    const std::vector<std::unique_ptr<LogRecord>>& log_records) {
    LOG_DEBUG("Starting redo phase");
    int redo_operations = 0;
    for (const auto& log_record : log_records) {
        switch (log_record->GetType()) {
            case LogRecordType::INSERT:
                RedoInsert(
                    static_cast<const InsertLogRecord*>(log_record.get()));
                redo_operations++;
                break;
            case LogRecordType::UPDATE:
                RedoUpdate(
                    static_cast<const UpdateLogRecord*>(log_record.get()));
                redo_operations++;
                break;
            case LogRecordType::DELETE:
                RedoDelete(
                    static_cast<const DeleteLogRecord*>(log_record.get()));
                redo_operations++;
                break;
            default:
                break;
        }
    }
    LOG_DEBUG("Redo phase completed. " << redo_operations
                                       << " operations identified");
}
void RecoveryManager::RedoInsert(const InsertLogRecord* log_record) {
    LOG_DEBUG("Redo insert for RID " << log_record->GetRID().page_id << ":"
                                     << log_record->GetRID().slot_num);
}
void RecoveryManager::RedoUpdate(const UpdateLogRecord* log_record) {
    LOG_DEBUG("Redo update for RID " << log_record->GetRID().page_id << ":"
                                     << log_record->GetRID().slot_num);
}
void RecoveryManager::UndoInsert(const InsertLogRecord* log_record) {
    RID rid = log_record->GetRID();
    Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
    if (page == nullptr) {
        LOG_WARN("Cannot fetch page " << rid.page_id << " for undo insert");
        return;
    }
    page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    bool deleted = table_page->DeleteTuple(rid);
    if (deleted) {
        page->SetDirty(true);
        LOG_DEBUG("Undo insert: deleted tuple at RID " << rid.page_id << ":"
                                                       << rid.slot_num);
    } else {
        LOG_WARN("Failed to undo insert for RID " << rid.page_id << ":"
                                                  << rid.slot_num);
    }
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(rid.page_id, deleted);
}
void RecoveryManager::UndoUpdate(const UpdateLogRecord* log_record) {
    RID rid = log_record->GetRID();
    Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
    if (page == nullptr) {
        LOG_WARN("Cannot fetch page " << rid.page_id << " for undo update");
        return;
    }
    page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    Tuple old_tuple = log_record->GetOldTuple();
    bool updated = table_page->UpdateTuple(old_tuple, rid);
    if (updated) {
        page->SetDirty(true);
        LOG_DEBUG("Undo update: restored old tuple at RID "
                  << rid.page_id << ":" << rid.slot_num);
    } else {
        LOG_WARN("Failed to undo update for RID " << rid.page_id << ":"
                                                  << rid.slot_num);
    }
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(rid.page_id, updated);
}
void RecoveryManager::RedoDelete(const DeleteLogRecord* log_record) {
    RID rid = log_record->GetRID();
    Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
    if (page == nullptr) {
        LOG_WARN("Cannot fetch page " << rid.page_id << " for redo delete");
        return;
    }
    page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    bool deleted = table_page->DeleteTuple(rid);
    if (deleted) {
        page->SetDirty(true);
        LOG_DEBUG("Redo delete: deleted tuple at RID " << rid.page_id << ":"
                                                       << rid.slot_num);
    }
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(rid.page_id, deleted);
}
void RecoveryManager::UndoDelete(const DeleteLogRecord* log_record) {
    RID rid = log_record->GetRID();
    Page* page = buffer_pool_manager_->FetchPage(rid.page_id);
    if (page == nullptr) {
        LOG_WARN("Cannot fetch page " << rid.page_id << " for undo delete");
        return;
    }
    page->WLatch();
    auto* table_page = reinterpret_cast<TablePage*>(page);
    Tuple deleted_tuple = log_record->GetDeletedTuple();
    RID new_rid;
    bool inserted = table_page->InsertTuple(deleted_tuple, &new_rid);
    if (inserted) {
        page->SetDirty(true);
        LOG_DEBUG("Undo delete: re-inserted tuple at RID "
                  << new_rid.page_id << ":" << new_rid.slot_num);
    } else {
        LOG_WARN("Failed to undo delete for RID " << rid.page_id << ":"
                                                  << rid.slot_num);
    }
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(rid.page_id, inserted);
}
}


========== ./src/storage/disk_manager.cpp ==========
namespace SimpleRDBMS {
DiskManager::DiskManager(const std::string& db_file)
    : db_file_name_(db_file), num_pages_(0), next_page_id_(0) {
    db_file_.open(db_file_name_,
                  std::ios::binary | std::ios::in | std::ios::out);
    if (!db_file_.is_open()) {
        db_file_.clear();
        db_file_.open(db_file_name_,
                      std::ios::binary | std::ios::trunc | std::ios::out);
        db_file_.close();
        db_file_.open(db_file_name_,
                      std::ios::binary | std::ios::in | std::ios::out);
        if (!db_file_.is_open()) {
            throw StorageException("Cannot open database file: " +
                                   db_file_name_);
        }
    }
    struct stat file_stat;
    if (stat(db_file_name_.c_str(), &file_stat) == 0) {
        num_pages_ = file_stat.st_size / PAGE_SIZE;
        next_page_id_ = std::max(0, static_cast<int>(num_pages_));
    }
}
DiskManager::~DiskManager() {
    if (db_file_.is_open()) {
        db_file_.close();
    }
}
void DiskManager::ReadPage(page_id_t page_id, char* page_data) {
    std::lock_guard<std::mutex> lock(latch_);
    if (page_id < 0 || page_id >= num_pages_) {
        throw StorageException("Invalid page id: " + std::to_string(page_id));
    }
    size_t offset = static_cast<size_t>(page_id) * PAGE_SIZE;
    db_file_.seekg(offset);
    db_file_.read(page_data, PAGE_SIZE);
    if (db_file_.bad()) {
        throw StorageException("Failed to read page: " +
                               std::to_string(page_id));
    }
    size_t read_count = db_file_.gcount();
    if (read_count < PAGE_SIZE) {
        std::memset(page_data + read_count, 0, PAGE_SIZE - read_count);
    }
}
void DiskManager::WritePage(page_id_t page_id, const char* page_data) {
    std::lock_guard<std::mutex> lock(latch_);
    if (page_id < 0) {
        throw StorageException("Invalid page id: " + std::to_string(page_id));
    }
    size_t offset = static_cast<size_t>(page_id) * PAGE_SIZE;
    db_file_.seekp(0, std::ios::end);
    size_t current_size = db_file_.tellp();
    size_t required_size = offset + PAGE_SIZE;
    if (current_size < required_size) {
        db_file_.seekp(required_size - 1);
        db_file_.write("", 1);
        LOG_DEBUG("Extended file size to accommodate page " << page_id);
    }
    db_file_.seekp(offset);
    db_file_.write(page_data, PAGE_SIZE);
    LOG_DEBUG("Writing page " << page_id << " to disk at offset " << offset);
    if (db_file_.bad()) {
        throw StorageException("Failed to write page: " +
                               std::to_string(page_id));
    }
    db_file_.flush();
    LOG_DEBUG("Flushed page " << page_id << " to disk");
    FILE* file = fopen(db_file_name_.c_str(), "r+");
    if (file != nullptr) {
        int fd = fileno(file);
        if (fd != -1) {
            LOG_DEBUG("Calling fsync on file descriptor " << fd);
            fsync(fd);
        }
        fclose(file);
    }
    if (page_id >= num_pages_) {
        num_pages_ = page_id + 1;
        if (next_page_id_ <= page_id) {
            next_page_id_ = page_id + 1;
        }
    }
    LOG_DEBUG("Successfully wrote page " << page_id << " to disk at offset "
                                         << offset);
}
page_id_t DiskManager::AllocatePage() {
    std::lock_guard<std::mutex> lock(latch_);
    const page_id_t RESERVED_PAGES = 2;
    if (next_page_id_ < RESERVED_PAGES && num_pages_ <= RESERVED_PAGES) {
        next_page_id_ = RESERVED_PAGES;
        num_pages_ = std::max(num_pages_, RESERVED_PAGES);
        LOG_DEBUG("AllocatePage: Initialized next_page_id to "
                  << next_page_id_);
    }
    if (!free_pages_.empty()) {
        page_id_t reused_page = free_pages_.back();
        free_pages_.pop_back();
        if (reused_page < RESERVED_PAGES) {
            LOG_WARN("AllocatePage: Attempted to reuse reserved page "
                     << reused_page << ", allocating new page instead");
        } else {
            LOG_DEBUG("AllocatePage: Reusing deallocated page " << reused_page);
            return reused_page;
        }
    }
    page_id_t new_page_id = next_page_id_++;
    if (new_page_id < RESERVED_PAGES) {
        new_page_id = next_page_id_ = RESERVED_PAGES;
        next_page_id_++;
    }
    num_pages_ = std::max(num_pages_, next_page_id_);
    LOG_DEBUG("AllocatePage: Allocated new page " << new_page_id);
    return new_page_id;
}
void DiskManager::DeallocatePage(page_id_t page_id) {
    std::lock_guard<std::mutex> lock(latch_);
    const page_id_t RESERVED_PAGES = 2;
    if (page_id < RESERVED_PAGES) {
        LOG_WARN("DeallocatePage: Attempted to deallocate reserved page "
                 << page_id << ", ignoring");
        return;
    }
    if (page_id >= 0 && page_id < next_page_id_) {
        free_pages_.push_back(page_id);
        LOG_DEBUG("DeallocatePage: Deallocated page "
                  << page_id << " (added to free list)");
    }
}
}


========== ./src/storage/page.cpp ==========
namespace SimpleRDBMS {
Page::Page()
    : page_id_(INVALID_PAGE_ID),
      pin_count_(0),
      is_dirty_(false),
      lsn_(INVALID_LSN) {
}
Page::~Page() = default;
}


========== ./src/transaction/lock_manager.cpp ==========
namespace SimpleRDBMS {
bool LockManager::LockShared(Transaction* txn, const RID& rid) {
    std::unique_lock<std::mutex> lock(latch_);
    if (txn->GetState() == TransactionState::SHRINKING) {
        txn->SetState(TransactionState::ABORTED);
        return false;
    }
    if (txn->GetExclusiveLockSet().count(rid) > 0 ||
        txn->GetSharedLockSet().count(rid) > 0) {
        return true;
    }
    if (lock_table_.find(rid) == lock_table_.end()) {
        lock_table_[rid] = std::make_unique<LockRequestQueue>();
    }
    auto* queue = lock_table_[rid].get();
    auto request = std::make_unique<LockRequest>();
    request->txn_id = txn->GetTxnId();
    request->lock_mode = LockMode::SHARED;
    request->granted = false;
    bool can_grant = GrantLock(request.get(), queue);
    if (can_grant) {
        request->granted = true;
        txn->AddSharedLock(rid);
        queue->request_queue.push_back(std::move(request));
        return true;
    }
    queue->request_queue.push_back(std::move(request));
    auto timeout = std::chrono::milliseconds(100);
    if (queue->cv.wait_for(lock, timeout, [&]() {
            return CheckAbort(txn) ||
                   GrantLock(queue->request_queue.back().get(), queue);
        })) {
        if (CheckAbort(txn)) {
            queue->request_queue.pop_back();
            return false;
        }
        queue->request_queue.back()->granted = true;
        txn->AddSharedLock(rid);
        return true;
    }
    queue->request_queue.pop_back();
    return false;
}
bool LockManager::LockExclusive(Transaction* txn, const RID& rid) {
    std::unique_lock<std::mutex> lock(latch_);
    if (txn->GetState() == TransactionState::SHRINKING) {
        txn->SetState(TransactionState::ABORTED);
        return false;
    }
    if (txn->GetExclusiveLockSet().count(rid) > 0) {
        return true;
    }
    if (lock_table_.find(rid) == lock_table_.end()) {
        lock_table_[rid] = std::make_unique<LockRequestQueue>();
    }
    auto* queue = lock_table_[rid].get();
    auto request = std::make_unique<LockRequest>();
    request->txn_id = txn->GetTxnId();
    request->lock_mode = LockMode::EXCLUSIVE;
    request->granted = false;
    bool can_grant = GrantLock(request.get(), queue);
    if (can_grant) {
        request->granted = true;
        txn->AddExclusiveLock(rid);
        queue->request_queue.push_back(std::move(request));
        return true;
    }
    queue->request_queue.push_back(std::move(request));
    auto timeout = std::chrono::milliseconds(100);
    if (queue->cv.wait_for(lock, timeout, [&]() {
            return CheckAbort(txn) ||
                   GrantLock(queue->request_queue.back().get(), queue);
        })) {
        if (CheckAbort(txn)) {
            queue->request_queue.pop_back();
            return false;
        }
        queue->request_queue.back()->granted = true;
        txn->AddExclusiveLock(rid);
        return true;
    }
    queue->request_queue.pop_back();
    return false;
}
bool LockManager::LockUpgrade(Transaction* txn, const RID& rid) {
    std::unique_lock<std::mutex> lock(latch_);
    if (txn->GetState() == TransactionState::SHRINKING) {
        txn->SetState(TransactionState::ABORTED);
        return false;
    }
    if (txn->GetExclusiveLockSet().count(rid) > 0) {
        return true;
    }
    if (txn->GetSharedLockSet().count(rid) == 0) {
        return false;
    }
    auto* queue = lock_table_[rid].get();
    if (queue->upgrading) {
        txn->SetState(TransactionState::ABORTED);
        return false;
    }
    queue->upgrading = true;
    auto it = queue->request_queue.begin();
    while (it != queue->request_queue.end()) {
        if ((*it)->txn_id == txn->GetTxnId()) {
            (*it)->lock_mode = LockMode::EXCLUSIVE;
            (*it)->granted = false;
            break;
        }
        ++it;
    }
    if (it == queue->request_queue.end()) {
        queue->upgrading = false;
        return false;
    }
    txn->RemoveSharedLock(rid);
    bool can_grant = GrantLock(it->get(), queue);
    if (can_grant) {
        (*it)->granted = true;
        txn->AddExclusiveLock(rid);
        queue->upgrading = false;
        queue->cv.notify_all();
        return true;
    }
    auto timeout = std::chrono::milliseconds(100);
    if (queue->cv.wait_for(lock, timeout, [&]() {
            return CheckAbort(txn) || GrantLock(it->get(), queue);
        })) {
        if (CheckAbort(txn)) {
            queue->upgrading = false;
            queue->cv.notify_all();
            queue->request_queue.erase(it);
            return false;
        }
        (*it)->granted = true;
        txn->AddExclusiveLock(rid);
        queue->upgrading = false;
        queue->cv.notify_all();
        return true;
    }
    txn->AddSharedLock(rid);
    (*it)->lock_mode = LockMode::SHARED;
    (*it)->granted = true;
    queue->upgrading = false;
    queue->cv.notify_all();
    return false;
}
bool LockManager::Unlock(Transaction* txn, const RID& rid) {
    std::unique_lock<std::mutex> lock(latch_);
    if (txn->GetState() == TransactionState::GROWING) {
        txn->SetState(TransactionState::SHRINKING);
    }
    bool found = false;
    if (txn->GetSharedLockSet().count(rid)) {
        txn->RemoveSharedLock(rid);
        found = true;
    } else if (txn->GetExclusiveLockSet().count(rid)) {
        txn->RemoveExclusiveLock(rid);
        found = true;
    }
    if (!found) return false;
    auto* queue = lock_table_[rid].get();
    auto it = queue->request_queue.begin();
    while (it != queue->request_queue.end()) {
        if ((*it)->txn_id == txn->GetTxnId()) {
            queue->request_queue.erase(it);
            break;
        }
        ++it;
    }
    GrantNewLocksInQueue(queue);
    queue->cv.notify_all();
    return true;
}
void LockManager::UnlockAll(Transaction* txn) {
    std::unique_lock<std::mutex> lock(latch_);
    std::unordered_set<RID> lock_set;
    for (const auto& rid : txn->GetSharedLockSet()) {
        lock_set.insert(rid);
    }
    for (const auto& rid : txn->GetExclusiveLockSet()) {
        lock_set.insert(rid);
    }
    for (const auto& rid : lock_set) {
        txn->RemoveSharedLock(rid);
        txn->RemoveExclusiveLock(rid);
        if (lock_table_.find(rid) != lock_table_.end()) {
            auto* queue = lock_table_[rid].get();
            auto it = queue->request_queue.begin();
            while (it != queue->request_queue.end()) {
                if ((*it)->txn_id == txn->GetTxnId()) {
                    queue->request_queue.erase(it);
                    break;
                }
                ++it;
            }
            GrantNewLocksInQueue(queue);
            queue->cv.notify_all();
        }
    }
}
bool LockManager::GrantLock(LockRequest* request, LockRequestQueue* queue) {
    for (const auto& req : queue->request_queue) {
        if (!req->granted) continue;
        if (req->txn_id == request->txn_id) continue;
        if (request->lock_mode == LockMode::EXCLUSIVE ||
            req->lock_mode == LockMode::EXCLUSIVE) {
            return false;
        }
    }
    if (queue->upgrading && request->lock_mode != LockMode::EXCLUSIVE) {
        return false;
    }
    return true;
}
void LockManager::GrantNewLocksInQueue(LockRequestQueue* queue) {
    for (auto& request : queue->request_queue) {
        if (!request->granted && GrantLock(request.get(), queue)) {
            request->granted = true;
        }
    }
}
bool LockManager::CheckAbort(Transaction* txn) { return txn->IsAborted(); }
}


========== ./src/transaction/transaction.cpp ==========
namespace SimpleRDBMS {
Transaction::Transaction(txn_id_t txn_id, IsolationLevel isolation_level)
    : txn_id_(txn_id),
      state_(TransactionState::GROWING),
      isolation_level_(isolation_level),
      prev_lsn_(INVALID_LSN) {
}
Transaction::~Transaction() = default;
void Transaction::AddToWriteSet(const RID& rid, const Tuple& tuple) {
    if (write_set_.find(rid) == write_set_.end()) {
        write_set_[rid] = tuple;
    }
}
}


========== ./src/transaction/transaction_manager.cpp ==========
namespace SimpleRDBMS {
TransactionManager::TransactionManager(LockManager* lock_manager,
                                       LogManager* log_manager)
    : lock_manager_(lock_manager), log_manager_(log_manager) {}
TransactionManager::~TransactionManager() {
    std::lock_guard<std::mutex> lock(txn_map_latch_);
    for (auto& [txn_id, txn] : txn_map_) {
        if (txn && (txn->GetState() == TransactionState::GROWING ||
                    txn->GetState() == TransactionState::SHRINKING)) {
            txn->SetState(TransactionState::ABORTED);
            if (lock_manager_) {
                try {
                    lock_manager_->UnlockAll(txn.get());
                } catch (...) {
                }
            }
        }
    }
}
Transaction* TransactionManager::Begin(IsolationLevel isolation_level) {
    LOG_DEBUG("TransactionManager::Begin: Starting new transaction");
    txn_id_t txn_id = GetNextTxnId();
    LOG_DEBUG("TransactionManager::Begin: Assigned transaction ID " << txn_id);
    auto txn = std::make_unique<Transaction>(txn_id, isolation_level);
    if (log_manager_ != nullptr) {
        try {
            LOG_DEBUG("TransactionManager::Begin: Writing begin log record");
            BeginLogRecord log_record(txn_id);
            lsn_t lsn = log_manager_->AppendLogRecord(&log_record);
            txn->SetPrevLSN(lsn);
            LOG_DEBUG(
                "TransactionManager::Begin: Begin log record written with LSN "
                << lsn);
        } catch (const std::exception& e) {
            LOG_WARN("TransactionManager::Begin: Failed to write log record: "
                     << e.what());
        }
    }
    Transaction* txn_ptr = txn.get();
    {
        std::lock_guard<std::mutex> lock(txn_map_latch_);
        txn_map_[txn_id] = std::move(txn);
    }
    LOG_DEBUG("TransactionManager::Begin: Transaction "
              << txn_id << " created successfully");
    return txn_ptr;
}
bool TransactionManager::Commit(Transaction* txn) {
    if (txn == nullptr) {
        return false;
    }
    txn->SetState(TransactionState::COMMITTED);
    if (log_manager_ != nullptr) {
        try {
            CommitLogRecord log_record(txn->GetTxnId(), txn->GetPrevLSN());
            lsn_t lsn = log_manager_->AppendLogRecord(&log_record);
            txn->SetPrevLSN(lsn);
            log_manager_->Flush(lsn);
        } catch (...) {
        }
    }
    if (lock_manager_) {
        lock_manager_->UnlockAll(txn);
    }
    {
        std::lock_guard<std::mutex> lock(txn_map_latch_);
        txn_map_.erase(txn->GetTxnId());
    }
    LOG_DEBUG("TransactionManager::Commit: Transaction "
              << txn->GetTxnId() << " committed successfully");
    return true;
}
bool TransactionManager::Abort(Transaction* txn) {
    if (txn == nullptr) {
        return false;
    }
    LOG_DEBUG("TransactionManager::Abort: Aborting transaction "
              << txn->GetTxnId());
    txn->SetState(TransactionState::ABORTED);
    if (log_manager_ != nullptr) {
        try {
            AbortLogRecord log_record(txn->GetTxnId(), txn->GetPrevLSN());
            lsn_t lsn = log_manager_->AppendLogRecord(&log_record);
            txn->SetPrevLSN(lsn);
            log_manager_->Flush(lsn);
        } catch (...) {
        }
    }
    if (lock_manager_) {
        lock_manager_->UnlockAll(txn);
    }
    {
        std::lock_guard<std::mutex> lock(txn_map_latch_);
        txn_map_.erase(txn->GetTxnId());
    }
    LOG_DEBUG("TransactionManager::Abort: Transaction "
              << txn->GetTxnId() << " aborted successfully");
    return true;
}
}


========== ./src/buffer/buffer_pool_manager.h ==========
namespace SimpleRDBMS {
class BufferPoolManager {
   public:
    BufferPoolManager(size_t pool_size,
                      std::unique_ptr<DiskManager> disk_manager,
                      std::unique_ptr<Replacer> replacer);
    ~BufferPoolManager();
    Page* FetchPage(page_id_t page_id);
    Page* NewPage(page_id_t* page_id);
    bool DeletePage(page_id_t page_id);
    bool UnpinPage(page_id_t page_id, bool is_dirty);
    bool FlushPage(page_id_t page_id);
    void FlushAllPages();
    DiskManager* GetDiskManager() { return disk_manager_.get(); }
    Page* GetSpecificPage(page_id_t page_id);
   private:
    size_t pool_size_;
    Page* pages_;
    std::unique_ptr<DiskManager> disk_manager_;
    std::unique_ptr<Replacer> replacer_;
    std::unordered_map<page_id_t, size_t> page_table_;
    std::list<size_t> free_list_;
    std::mutex latch_;
    size_t FindVictimPage();
    void UpdatePage(Page* page, page_id_t page_id);
};
}


========== ./src/buffer/lru_replacer.h ==========
namespace SimpleRDBMS {
class LRUReplacer : public Replacer {
   public:
    explicit LRUReplacer(size_t num_pages);
    ~LRUReplacer() override;
    void Pin(size_t frame_id) override;
    void Unpin(size_t frame_id) override;
    bool Victim(size_t* frame_id) override;
    size_t Size() const override;
   private:
    size_t num_pages_;
    std::list<size_t> lru_list_;
    std::unordered_map<size_t, std::list<size_t>::iterator> lru_map_;
    mutable std::mutex latch_;
};
}


========== ./src/buffer/replacer.h ==========
namespace SimpleRDBMS {
class Replacer {
   public:
    virtual ~Replacer() = default;
    virtual void Pin(size_t frame_id) = 0;
    virtual void Unpin(size_t frame_id) = 0;
    virtual bool Victim(size_t* frame_id) = 0;
    virtual size_t Size() const = 0;
};
}


========== ./src/catalog/catalog.h ==========
namespace SimpleRDBMS {
class BufferPoolManager;
class Schema;
class TableHeap;
struct TableInfo {
    std::unique_ptr<Schema> schema;
    std::string table_name;
    std::unique_ptr<TableHeap> table_heap;
    oid_t table_oid;
    page_id_t first_page_id;
};
struct IndexInfo {
    std::string index_name;
    std::string table_name;
    std::vector<std::string> key_columns;
    oid_t index_oid;
};
class Catalog {
   public:
    explicit Catalog(BufferPoolManager* buffer_pool_manager,
                     LogManager* log_manager = nullptr);
    ~Catalog();
    bool CreateTable(const std::string& table_name, const Schema& schema);
    bool DropTable(const std::string& table_name);
    TableInfo* GetTable(const std::string& table_name);
    TableInfo* GetTable(oid_t table_oid);
    bool CreateIndex(const std::string& index_name,
                     const std::string& table_name,
                     const std::vector<std::string>& key_columns);
    bool DropIndex(const std::string& index_name);
    IndexInfo* GetIndex(const std::string& index_name);
    IndexInfo* GetIndex(oid_t index_oid);
    std::vector<IndexInfo*> GetTableIndexes(const std::string& table_name);
    void SetLogManager(LogManager* log_manager) { log_manager_ = log_manager; }
    void LoadCatalogFromDisk();
    void SaveCatalogToDisk();
    void DebugPrintTables() const;
    std::vector<std::string> GetAllTableNames() const;
    void Shutdown() {
        try {
            SaveCatalogToDisk();
            buffer_pool_manager_ = nullptr;
        } catch (const std::exception& e) {
            LOG_WARN("Catalog::Shutdown: " << e.what());
        }
    }
   private:
    BufferPoolManager* buffer_pool_manager_;
    mutable std::mutex save_mutex_;
    std::atomic<bool> save_in_progress_;
    LogManager* log_manager_;
    std::unordered_map<std::string, std::unique_ptr<TableInfo>>
        tables_;
    std::unordered_map<oid_t, std::string> table_oid_map_;
    std::unordered_map<std::string, std::unique_ptr<IndexInfo>>
        indexes_;
    std::unordered_map<oid_t, std::string> index_oid_map_;
    oid_t next_table_oid_;
    oid_t next_index_oid_;
    void SerializeSchema(const Schema& schema, char* buffer, size_t& offset);
    std::unique_ptr<Schema> DeserializeSchema(const char* buffer,
                                              size_t& offset);
};
}


========== ./src/catalog/schema.h ==========
namespace SimpleRDBMS {
class Schema {
   public:
    explicit Schema(const std::vector<Column>& columns);
    const Column& GetColumn(size_t index) const { return columns_[index]; }
    const Column& GetColumn(const std::string& name) const;
    size_t GetColumnIdx(const std::string& name) const;
    const std::vector<Column>& GetColumns() const { return columns_; }
    size_t GetColumnCount() const { return columns_.size(); }
    size_t GetTupleSize() const;
    bool HasColumn(const std::string& name) const;
   private:
    std::vector<Column> columns_;
    std::unordered_map<std::string, size_t> column_indices_;
};
}


========== ./src/catalog/table_manager.h ==========
namespace SimpleRDBMS {
class BufferPoolManager;
class Catalog;
class CreateTableStatement;
class IndexManager;
class TableInfo;
class Tuple;
class TableManager {
   public:
    TableManager(BufferPoolManager* buffer_pool_manager, Catalog* catalog);
    ~TableManager();
    TableManager(const TableManager&) = delete;
    TableManager& operator=(const TableManager&) = delete;
    bool CreateTable(const CreateTableStatement* stmt);
    bool DropTable(const std::string& table_name);
    bool CreateIndex(const std::string& index_name,
                     const std::string& table_name,
                     const std::vector<std::string>& key_columns);
    bool DropIndex(const std::string& index_name);
    bool UpdateIndexesOnInsert(const std::string& table_name,
                               const Tuple& tuple, const RID& rid);
    bool UpdateIndexesOnDelete(const std::string& table_name,
                               const Tuple& tuple);
    bool UpdateIndexesOnUpdate(const std::string& table_name,
                               const Tuple& old_tuple, const Tuple& new_tuple,
                               const RID& rid);
    Catalog* GetCatalog() { return catalog_; }
    IndexManager* GetIndexManager();
   private:
    BufferPoolManager* buffer_pool_manager_;
    Catalog* catalog_;
    std::unique_ptr<IndexManager>
        index_manager_;
    bool PopulateIndexWithExistingData(
        const std::string& index_name, TableInfo* table_info,
        const std::vector<std::string>& key_columns);
    void RebuildAllIndexes();
};
}


========== ./src/common/config.h ==========
namespace SimpleRDBMS {
static constexpr size_t PAGE_SIZE = 4096;
static constexpr size_t BUFFER_POOL_SIZE = 100;
static constexpr size_t MAX_TUPLE_SIZE = 512;
static constexpr size_t B_PLUS_TREE_ORDER = 64;
static constexpr int INVALID_TXN_ID = -1;
static constexpr int INVALID_LSN = -1;
using page_id_t = int32_t;
using slot_offset_t = int32_t;
using txn_id_t = uint32_t;
using lsn_t = int32_t;
using oid_t = uint32_t;
static constexpr page_id_t INVALID_PAGE_ID = -1;
}


========== ./src/common/debug.h ==========
namespace SimpleRDBMS {
enum class DebugLevel {
    NONE = 0,
    ERROR = 1,
    WARN = 2,
    INFO = 3,
    DEBUG = 4,
    TRACE = 5
};
inline DebugLevel GetDebugLevel() {
    static DebugLevel level = []() {
        const char* env = std::getenv("SIMPLEDB_DEBUG_LEVEL");
        if (env) {
            int val = std::atoi(env);
            return static_cast<DebugLevel>(val);
        }
        return DebugLevel::WARN;
    }();
    return level;
}
    do {                                                                      \
        if (static_cast<int>(SimpleRDBMS::GetDebugLevel()) >=                 \
            static_cast<int>(level)) {                                        \
            std::ostringstream oss;                                           \
            oss << msg;                                                       \
            std::cerr << SimpleRDBMS::GetDebugPrefix(level) << " ["           \
                      << __FILE__ << ":" << __LINE__ << " " << __FUNCTION__   \
                      << "] " << oss.str() << DEBUG_COLOR_RESET << std::endl; \
        }                                                                     \
    } while (0)
inline std::string GetDebugPrefix(DebugLevel level) {
    switch (level) {
        case DebugLevel::ERROR:
            return std::string(DEBUG_COLOR_RED) + "[ERROR]";
        case DebugLevel::WARN:
            return std::string(DEBUG_COLOR_YELLOW) + "[WARN ]";
        case DebugLevel::INFO:
            return std::string(DEBUG_COLOR_GREEN) + "[INFO ]";
        case DebugLevel::DEBUG:
            return std::string(DEBUG_COLOR_CYAN) + "[DEBUG]";
        case DebugLevel::TRACE:
            return std::string(DEBUG_COLOR_MAGENTA) + "[TRACE]";
        default:
            return "[?????]";
    }
}
class Debug {
   public:
    static std::string GetStackTrace(int skip = 1) {
        std::stringstream ss;
        const int max_frames = 128;
        void* buffer[max_frames];
        int nptrs = backtrace(buffer, max_frames);
        if (nptrs > skip) {
            ss << "Stack trace:\n";
            for (int i = skip; i < nptrs; i++) {
                Dl_info info;
                if (dladdr(buffer[i], &info) && info.dli_sname) {
                    int status;
                    char* demangled = abi::__cxa_demangle(
                        info.dli_sname, nullptr, nullptr, &status);
                    ss << "
                    if (info.dli_fname) {
                        std::string fname(info.dli_fname);
                        size_t pos = fname.find_last_of("/\\");
                        if (pos != std::string::npos) {
                            fname = fname.substr(pos + 1);
                        }
                        ss << fname << " ";
                    }
                    if (status == 0 && demangled) {
                        ss << demangled;
                        free(demangled);
                    } else if (info.dli_sname) {
                        ss << info.dli_sname;
                    } else {
                        ss << "???";
                    }
                    if (info.dli_saddr) {
                        ss << " + " << std::hex << "0x"
                           << ((char*)buffer[i] - (char*)info.dli_saddr)
                           << std::dec;
                    }
                    ss << "\n";
                } else {
                    char** symbols = backtrace_symbols(&buffer[i], 1);
                    if (symbols) {
                        ss << "
                           << symbols[0] << "\n";
                        free(symbols);
                    }
                }
            }
        } else {
            ss << "Stack trace not available\n";
        }
        ss << "Stack trace not available on this platform\n";
        return ss.str();
    }
};
}


========== ./src/common/exception.h ==========
namespace SimpleRDBMS {
class Exception : public std::exception {
   public:
    explicit Exception(const std::string& message) : message_(message) {}
    Exception(const std::string& message, const std::string& file, int line,
              const std::string& func) {
        std::ostringstream oss;
        oss << message << "\n  at " << file << ":" << line << " in " << func;
        message_ = oss.str();
        LOG_ERROR("Exception created: " << message_);
    }
    const char* what() const noexcept override { return message_.c_str(); }
   protected:
    std::string message_;
};
class BufferPoolException : public Exception {
   public:
    explicit BufferPoolException(const std::string& message)
        : Exception("BufferPool: " + message) {}
    BufferPoolException(const std::string& message, const std::string& file,
                        int line, const std::string& func)
        : Exception("BufferPool: " + message, file, line, func) {}
};
class StorageException : public Exception {
   public:
    explicit StorageException(const std::string& message)
        : Exception("Storage: " + message) {}
    StorageException(const std::string& message, const std::string& file,
                     int line, const std::string& func)
        : Exception("Storage: " + message, file, line, func) {}
};
class TransactionException : public Exception {
   public:
    explicit TransactionException(const std::string& message)
        : Exception("Transaction: " + message) {}
    TransactionException(const std::string& message, const std::string& file,
                         int line, const std::string& func)
        : Exception("Transaction: " + message, file, line, func) {}
};
class ExecutionException : public Exception {
   public:
    explicit ExecutionException(const std::string& message)
        : Exception("Execution: " + message) {}
    ExecutionException(const std::string& message, const std::string& file,
                       int line, const std::string& func)
        : Exception("Execution: " + message, file, line, func) {}
};
    do {                                                                       \
        std::ostringstream oss;                                                \
        oss << msg;                                                            \
        std::string message = oss.str();                                       \
        LOG_ERROR("Throwing " <<
        std::string stack_trace = SimpleRDBMS::Debug::GetStackTrace();         \
        throw ExceptionClass(message + "\n" + stack_trace, __FILE__, __LINE__, \
                             __FUNCTION__);                                    \
    } while (0)
    THROW_EXCEPTION_WITH_TRACE(StorageException, msg)
    THROW_EXCEPTION_WITH_TRACE(BufferPoolException, msg)
    THROW_EXCEPTION_WITH_TRACE(ExecutionException, msg)
    THROW_EXCEPTION_WITH_TRACE(TransactionException, msg)
}


========== ./src/common/types.h ==========
namespace SimpleRDBMS {
enum class TypeId {
    INVALID = 0,
    BOOLEAN,
    TINYINT,
    SMALLINT,
    INTEGER,
    BIGINT,
    DECIMAL,
    FLOAT,
    DOUBLE,
    VARCHAR,
    TIMESTAMP
};
using Value = std::variant<bool,
                           int8_t,
                           int16_t,
                           int32_t,
                           int64_t,
                           float,
                           double,
                           std::string
                           >;
struct Column {
    std::string name;
    TypeId type;
    size_t size;
    bool nullable;
    bool is_primary_key;
};
struct RID {
    page_id_t page_id;
    slot_offset_t slot_num;
    bool operator==(const RID& other) const {
        return page_id == other.page_id && slot_num == other.slot_num;
    }
};
}
namespace std {
template <>
struct hash<SimpleRDBMS::RID> {
    size_t operator()(const SimpleRDBMS::RID& rid) const {
        return hash<SimpleRDBMS::page_id_t>()(rid.page_id) ^
               (hash<SimpleRDBMS::slot_offset_t>()(rid.slot_num) << 1);
    }
};
}


========== ./src/execution/execution_engine.h ==========
namespace SimpleRDBMS {
class UpdateStatement;
class DeleteStatement;
class UpdatePlanNode;
class DeletePlanNode;
class ExecutionEngine {
   public:
    ExecutionEngine(BufferPoolManager* buffer_pool_manager, Catalog* catalog,
                    TransactionManager* txn_manager,
                    LogManager* log_manager = nullptr);
    bool Execute(Statement* statement, std::vector<Tuple>* result_set,
                 Transaction* txn);
   private:
    BufferPoolManager* buffer_pool_manager_;
    Catalog* catalog_;
    TransactionManager* txn_manager_;
    LogManager* log_manager_;
    std::unique_ptr<TableManager> table_manager_;
    std::string SelectBestIndex(const std::string& table_name,
                                Expression* where_clause);
    std::unique_ptr<PlanNode> CreatePlan(Statement* statement);
    std::unique_ptr<Executor> CreateExecutor(ExecutorContext* exec_ctx,
                                             std::unique_ptr<PlanNode> plan);
    std::unique_ptr<PlanNode> CreateSelectPlan(SelectStatement* stmt);
    std::unique_ptr<PlanNode> CreateInsertPlan(InsertStatement* stmt);
    std::unique_ptr<PlanNode> CreateUpdatePlan(UpdateStatement* stmt);
    std::unique_ptr<PlanNode> CreateDeletePlan(DeleteStatement* stmt);
    bool HandleShowTables(std::vector<Tuple>* result_set);
    bool HandleBegin(Transaction* txn);
    bool HandleCommit(Transaction* txn);
    bool HandleRollback(Transaction* txn);
    bool HandleExplain(ExplainStatement* stmt, std::vector<Tuple>* result_set);
    std::string FormatExecutionPlan(PlanNode* plan, int indent = 0);
    std::string GetPlanNodeTypeString(PlanNodeType type);
    std::string TypeIdToString(TypeId type_id) {
        switch (type_id) {
            case TypeId::BOOLEAN:
                return "BOOLEAN";
            case TypeId::TINYINT:
                return "TINYINT";
            case TypeId::SMALLINT:
                return "SMALLINT";
            case TypeId::INTEGER:
                return "INTEGER";
            case TypeId::BIGINT:
                return "BIGINT";
            case TypeId::FLOAT:
                return "FLOAT";
            case TypeId::DOUBLE:
                return "DOUBLE";
            case TypeId::VARCHAR:
                return "VARCHAR";
            case TypeId::TIMESTAMP:
                return "TIMESTAMP";
            default:
                return "UNKNOWN";
        }
    }
};
}


========== ./src/execution/executor.h ==========
namespace SimpleRDBMS {
class ExecutorContext;
class PlanNode;
class SeqScanPlanNode;
class InsertPlanNode;
class TableInfo;
class UpdatePlanNode;
class DeletePlanNode;
class TableManager;
class ExecutorContext {
   public:
    ExecutorContext(Transaction* txn, Catalog* catalog,
                    BufferPoolManager* buffer_pool_manager,
                    TableManager* table_manager)
        : transaction_(txn),
          catalog_(catalog),
          buffer_pool_manager_(buffer_pool_manager),
          table_manager_(table_manager) {}
    Transaction* GetTransaction() { return transaction_; }
    Catalog* GetCatalog() { return catalog_; }
    BufferPoolManager* GetBufferPoolManager() { return buffer_pool_manager_; }
    TableManager* GetTableManager() { return table_manager_; }
   private:
    Transaction* transaction_;
    Catalog* catalog_;
    BufferPoolManager* buffer_pool_manager_;
    TableManager* table_manager_;
};
class Executor {
   public:
    Executor(ExecutorContext* exec_ctx, std::unique_ptr<PlanNode> plan)
        : exec_ctx_(exec_ctx), plan_(std::move(plan)) {}
    virtual ~Executor() = default;
    virtual void Init() = 0;
    virtual bool Next(Tuple* tuple, RID* rid) = 0;
    const Schema* GetOutputSchema() const { return plan_->GetOutputSchema(); }
   protected:
    ExecutorContext* exec_ctx_;
    std::unique_ptr<PlanNode> plan_;
};
class SeqScanExecutor : public Executor {
   public:
    SeqScanExecutor(ExecutorContext* exec_ctx,
                    std::unique_ptr<SeqScanPlanNode> plan);
    void Init() override;
    bool Next(Tuple* tuple, RID* rid) override;
    SeqScanPlanNode* GetSeqScanPlan() const {
        return static_cast<SeqScanPlanNode*>(plan_.get());
    }
   private:
    TableInfo* table_info_;
    TableHeap::Iterator table_iterator_;
    std::unique_ptr<ExpressionEvaluator> evaluator_;
};
class IndexScanExecutor : public Executor {
   public:
    IndexScanExecutor(ExecutorContext* exec_ctx,
                      std::unique_ptr<IndexScanPlanNode> plan);
    void Init() override;
    bool Next(Tuple* tuple, RID* rid) override;
    IndexScanPlanNode* GetIndexScanPlan() const {
        return static_cast<IndexScanPlanNode*>(plan_.get());
    }
   private:
    TableInfo* table_info_;
    IndexInfo* index_info_;
    std::unique_ptr<ExpressionEvaluator> evaluator_;
    Value search_key_;
    bool has_found_tuple_;
    RID found_rid_;
    void ExtractSearchKey(Expression* predicate);
};
class InsertExecutor : public Executor {
   public:
    InsertExecutor(ExecutorContext* exec_ctx,
                   std::unique_ptr<InsertPlanNode> plan);
    void Init() override;
    bool Next(Tuple* tuple, RID* rid) override;
    InsertPlanNode* GetInsertPlan() const {
        return static_cast<InsertPlanNode*>(plan_.get());
    }
   private:
    TableInfo* table_info_;
    size_t current_index_;
};
class UpdateExecutor : public Executor {
   public:
    UpdateExecutor(ExecutorContext* exec_ctx,
                   std::unique_ptr<UpdatePlanNode> plan);
    void Init() override;
    bool Next(Tuple* tuple, RID* rid) override;
    UpdatePlanNode* GetUpdatePlan() const {
        return static_cast<UpdatePlanNode*>(plan_.get());
    }
    const Schema* GetTableSchema() const {
        return table_info_ ? table_info_->schema.get() : nullptr;
    }
   private:
    TableInfo* table_info_;
    std::unique_ptr<ExpressionEvaluator> evaluator_;
    std::vector<RID> target_rids_;
    size_t current_index_;
    bool is_executed_;
};
class DeleteExecutor : public Executor {
   public:
    DeleteExecutor(ExecutorContext* exec_ctx,
                   std::unique_ptr<DeletePlanNode> plan);
    void Init() override;
    bool Next(Tuple* tuple, RID* rid) override;
    DeletePlanNode* GetDeletePlan() const {
        return static_cast<DeletePlanNode*>(plan_.get());
    }
    const Schema* GetTableSchema() const {
        return table_info_ ? table_info_->schema.get() : nullptr;
    }
   private:
    TableInfo* table_info_;
    std::unique_ptr<ExpressionEvaluator> evaluator_;
    std::vector<RID> target_rids_;
    size_t current_index_;
    bool is_executed_;
};
class ProjectionExecutor : public Executor {
   public:
    ProjectionExecutor(ExecutorContext* exec_ctx,
                       std::unique_ptr<ProjectionPlanNode> plan);
    void Init() override;
    bool Next(Tuple* tuple, RID* rid) override;
    ProjectionPlanNode* GetProjectionPlan() const {
        return static_cast<ProjectionPlanNode*>(plan_.get());
    }
   private:
    std::unique_ptr<Executor> child_executor_;
    std::unique_ptr<ExpressionEvaluator> evaluator_;
};
}


========== ./src/execution/expression_cloner.h ==========
namespace SimpleRDBMS {
class ExpressionCloner {
   public:
    static std::unique_ptr<Expression> Clone(const Expression* expr);
   private:
    static std::unique_ptr<Expression> CloneConstant(
        const ConstantExpression* expr);
    static std::unique_ptr<Expression> CloneColumnRef(
        const ColumnRefExpression* expr);
    static std::unique_ptr<Expression> CloneBinaryOp(
        const BinaryOpExpression* expr);
    static std::unique_ptr<Expression> CloneUnaryOp(
        const UnaryOpExpression* expr);
};
}


========== ./src/execution/expression_evaluator.h ==========
namespace SimpleRDBMS {
class ExpressionEvaluator {
   public:
    ExpressionEvaluator(const Schema* schema) : schema_(schema) {}
    Value Evaluate(const Expression* expr, const Tuple& tuple);
    bool EvaluateAsBoolean(const Expression* expr, const Tuple& tuple);
   private:
    const Schema* schema_;
    Value EvaluateConstant(const ConstantExpression* expr, const Tuple& tuple);
    Value EvaluateColumnRef(const ColumnRefExpression* expr,
                            const Tuple& tuple);
    Value EvaluateBinaryOp(const BinaryOpExpression* expr, const Tuple& tuple);
    Value EvaluateUnaryOp(const UnaryOpExpression* expr, const Tuple& tuple);
    Value EvaluateArithmeticOp(const Value& left, const Value& right,
                               BinaryOpExpression::OpType op);
    bool CompareValues(const Value& left, const Value& right,
                       BinaryOpExpression::OpType op);
    bool IsValueTrue(const Value& value);
    template <typename T>
    bool CompareNumeric(const T& left, const T& right,
                        BinaryOpExpression::OpType op);
};
}


========== ./src/execution/plan_node.h ==========
namespace SimpleRDBMS {
class Schema;
class Expression;
enum class PlanNodeType {
    SEQUENTIAL_SCAN,
    INDEX_SCAN,
    INSERT,
    UPDATE,
    DELETE,
    PROJECTION,
    FILTER,
    NESTED_LOOP_JOIN,
    HASH_JOIN,
    AGGREGATION,
    SORT,
    LIMIT
};
class PlanNode {
   public:
    PlanNode(const Schema* output_schema,
             std::vector<std::unique_ptr<PlanNode>> children)
        : output_schema_(output_schema), children_(std::move(children)) {}
    virtual ~PlanNode() = default;
    virtual PlanNodeType GetType() const = 0;
    const Schema* GetOutputSchema() const { return output_schema_; }
    const std::vector<std::unique_ptr<PlanNode>>& GetChildren() const {
        return children_;
    }
    const PlanNode* GetChild(size_t index) const {
        return index < children_.size() ? children_[index].get() : nullptr;
    }
   protected:
    const Schema* output_schema_;
    std::vector<std::unique_ptr<PlanNode>> children_;
};
class SeqScanPlanNode : public PlanNode {
   public:
    SeqScanPlanNode(const Schema* output_schema, const std::string& table_name,
                    std::unique_ptr<Expression> predicate = nullptr)
        : PlanNode(output_schema, {}),
          table_name_(table_name),
          predicate_(std::move(predicate)) {}
    PlanNodeType GetType() const override {
        return PlanNodeType::SEQUENTIAL_SCAN;
    }
    const std::string& GetTableName() const { return table_name_; }
    Expression* GetPredicate() const { return predicate_.get(); }
   private:
    std::string table_name_;
    std::unique_ptr<Expression> predicate_;
};
class InsertPlanNode : public PlanNode {
   public:
    InsertPlanNode(const Schema* output_schema, const std::string& table_name,
                   std::vector<std::vector<Value>> values)
        : PlanNode(output_schema, {}),
          table_name_(table_name),
          values_(std::move(values)) {}
    PlanNodeType GetType() const override { return PlanNodeType::INSERT; }
    const std::string& GetTableName() const { return table_name_; }
    const std::vector<std::vector<Value>>& GetValues() const { return values_; }
   private:
    std::string table_name_;
    std::vector<std::vector<Value>> values_;
};
class ProjectionPlanNode : public PlanNode {
   public:
    ProjectionPlanNode(const Schema* output_schema,
                       std::vector<std::unique_ptr<Expression>> expressions,
                       std::unique_ptr<PlanNode> child)
        : PlanNode(output_schema, {}), expressions_(std::move(expressions)) {
        children_.push_back(std::move(child));
    }
    PlanNodeType GetType() const override { return PlanNodeType::PROJECTION; }
    const std::vector<std::unique_ptr<Expression>>& GetExpressions() const {
        return expressions_;
    }
    void SetOwnedSchema(std::unique_ptr<Schema> schema) {
        owned_schema_ = std::move(schema);
    }
   private:
    std::vector<std::unique_ptr<Expression>> expressions_;
    std::unique_ptr<Schema> owned_schema_;
};
class UpdatePlanNode : public PlanNode {
   public:
    UpdatePlanNode(
        std::unique_ptr<Schema> output_schema, const std::string& table_name,
        std::vector<std::pair<std::string, std::unique_ptr<Expression>>>
            updates,
        std::unique_ptr<Expression> predicate = nullptr)
        : PlanNode(nullptr, {}),
          table_name_(table_name),
          updates_(std::move(updates)),
          predicate_(std::move(predicate)),
          owned_schema_(std::move(output_schema)) {
        output_schema_ = owned_schema_.get();
    }
    PlanNodeType GetType() const override { return PlanNodeType::UPDATE; }
    const std::string& GetTableName() const { return table_name_; }
    const std::vector<std::pair<std::string, std::unique_ptr<Expression>>>&
    GetUpdates() const {
        return updates_;
    }
    Expression* GetPredicate() const { return predicate_.get(); }
   private:
    std::string table_name_;
    std::vector<std::pair<std::string, std::unique_ptr<Expression>>>
        updates_;
    std::unique_ptr<Expression> predicate_;
    std::unique_ptr<Schema> owned_schema_;
};
class DeletePlanNode : public PlanNode {
   public:
    DeletePlanNode(std::unique_ptr<Schema> output_schema, const std::string& table_name,
                   std::unique_ptr<Expression> predicate = nullptr)
        : PlanNode(nullptr, {}),
          table_name_(table_name),
          predicate_(std::move(predicate)),
          owned_schema_(std::move(output_schema)) {
        output_schema_ = owned_schema_.get();
    }
    PlanNodeType GetType() const override { return PlanNodeType::DELETE; }
    const std::string& GetTableName() const { return table_name_; }
    Expression* GetPredicate() const { return predicate_.get(); }
   private:
    std::string table_name_;
    std::unique_ptr<Expression> predicate_;
    std::unique_ptr<Schema> owned_schema_;
};
class IndexScanPlanNode : public PlanNode {
   public:
    IndexScanPlanNode(const Schema* output_schema,
                      const std::string& table_name,
                      const std::string& index_name,
                      std::unique_ptr<Expression> predicate = nullptr)
        : PlanNode(output_schema, {}),
          table_name_(table_name),
          index_name_(index_name),
          predicate_(std::move(predicate)) {}
    PlanNodeType GetType() const override { return PlanNodeType::INDEX_SCAN; }
    const std::string& GetTableName() const { return table_name_; }
    const std::string& GetIndexName() const { return index_name_; }
    Expression* GetPredicate() const { return predicate_.get(); }
   private:
    std::string table_name_;
    std::string index_name_;
    std::unique_ptr<Expression> predicate_;
};
}


========== ./src/index/b_plus_tree.h ==========
namespace SimpleRDBMS {
template <typename KeyType>
class BPlusTreeInternalPage;
template <typename KeyType, typename ValueType>
class BPlusTree {
   public:
    BPlusTree(const std::string& name, BufferPoolManager* buffer_pool_manager);
    ~BPlusTree();
    bool Insert(const KeyType& key, const ValueType& value,
                txn_id_t txn_id = -1);
    bool Remove(const KeyType& key, txn_id_t txn_id = -1);
    bool GetValue(const KeyType& key, ValueType* value, txn_id_t txn_id = -1);
    class Iterator {
       public:
        Iterator(BPlusTree* tree, page_id_t page_id, int index);
        bool IsEnd() const;
        void operator++();
        std::pair<KeyType, ValueType> operator*();
       private:
        BPlusTree* tree_;
        page_id_t current_page_id_;
        int current_index_;
    };
    Iterator Begin();
    Iterator Begin(const KeyType& key);
    Iterator End();
   private:
    std::string index_name_;
    BufferPoolManager* buffer_pool_manager_;
    page_id_t root_page_id_;
    std::mutex latch_;
    Page* FindLeafPage(const KeyType& key, bool is_write_op);
    bool InsertIntoLeaf(const KeyType& key, const ValueType& value,
                        BPlusTreeLeafPage<KeyType, ValueType>* leaf);
    void InsertIntoParent(BPlusTreePage* old_node, const KeyType& key,
                          BPlusTreePage* new_node);
    template <typename N>
    bool Split(N* node);
    bool ShouldCoalesceOrRedistribute(BPlusTreePage* node);
    bool CoalesceOrRedistribute(BPlusTreePage* node, txn_id_t txn_id);
    bool AdjustRoot(BPlusTreePage* old_root_node);
    template <typename N>
    bool Coalesce(N** neighbor_node, N** node,
                  BPlusTreeInternalPage<KeyType>** parent, int index,
                  txn_id_t txn_id);
    template <typename N>
    void Redistribute(N* neighbor_node, N* node, int index);
    void UpdateRootPageId(page_id_t root_page_id);
    void LoadRootPageId();
    page_id_t GetHeaderPageId() const;
};
}


========== ./src/index/b_plus_tree_page.h ==========
namespace SimpleRDBMS {
class BufferPoolManager;
enum class IndexPageType {
    INVALID = 0,
    LEAF_PAGE,
    INTERNAL_PAGE
};
class BPlusTreePage {
   public:
    bool IsLeafPage() const { return page_type_ == IndexPageType::LEAF_PAGE; }
    bool IsRootPage() const { return parent_page_id_ == INVALID_PAGE_ID; }
    void SetPageType(IndexPageType type) { page_type_ = type; }
    IndexPageType GetPageType() const { return page_type_; }
    int GetSize() const { return size_; }
    void SetSize(int size);
    void IncreaseSize(int amount);
    int GetMaxSize() const { return max_size_; }
    void SetMaxSize(int max_size) { max_size_ = max_size; }
    page_id_t GetParentPageId() const { return parent_page_id_; }
    void SetParentPageId(page_id_t parent_id) { parent_page_id_ = parent_id; }
    page_id_t GetPageId() const { return page_id_; }
    void SetPageId(page_id_t page_id) { page_id_ = page_id; }
   protected:
    IndexPageType page_type_;
    int size_;
    int max_size_;
    page_id_t parent_page_id_;
    page_id_t page_id_;
};
template <typename KeyType, typename ValueType>
class BPlusTreeLeafPage : public BPlusTreePage {
   public:
    void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID);
    KeyType KeyAt(int index) const;
    ValueType ValueAt(int index) const;
    void SetKeyAt(int index, const KeyType& key);
    void SetValueAt(int index, const ValueType& value);
    int KeyIndex(const KeyType& key) const;
    bool Insert(const KeyType& key, const ValueType& value);
    bool Delete(const KeyType& key);
    void MoveHalfTo(BPlusTreeLeafPage* recipient);
    void MoveAllTo(BPlusTreeLeafPage* recipient);
    void MoveFirstToEndOf(
        BPlusTreeLeafPage* recipient);
    void MoveLastToFrontOf(
        BPlusTreeLeafPage* recipient);
    page_id_t GetNextPageId() const { return next_page_id_; }
    void SetNextPageId(page_id_t next_page_id) { next_page_id_ = next_page_id; }
   private:
    page_id_t next_page_id_;
    char data_[0];
};
template <typename KeyType>
class BPlusTreeInternalPage : public BPlusTreePage {
   public:
    void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID);
    KeyType KeyAt(int index) const;
    void SetKeyAt(int index, const KeyType& key);
    int KeyIndex(const KeyType& key) const;
    page_id_t ValueAt(int index) const;
    void SetValueAt(int index, page_id_t value);
    int ValueIndex(page_id_t value) const;
    void InsertNodeAfter(page_id_t old_value, const KeyType& new_key,
                         page_id_t new_value);
    void Remove(int index);
    void MoveHalfTo(BPlusTreeInternalPage* recipient,
                    BufferPoolManager* buffer_pool_manager);
    void MoveAllTo(BPlusTreeInternalPage* recipient, const KeyType& middle_key,
                   BufferPoolManager* buffer_pool_manager);
    void MoveFirstToEndOf(BPlusTreeInternalPage* recipient,
                          const KeyType& middle_key,
                          BufferPoolManager* buffer_pool_manager);
    void MoveLastToFrontOf(BPlusTreeInternalPage* recipient,
                           const KeyType& middle_key,
                           BufferPoolManager* buffer_pool_manager);
   private:
    char data_[0];
};
}


========== ./src/index/index_manager.h ==========
namespace SimpleRDBMS {
class BufferPoolManager;
class Schema;
template <typename KeyType, typename ValueType>
class BPlusTree;
class IndexManagerImpl;
class IndexManager {
   public:
    explicit IndexManager(BufferPoolManager* buffer_pool_manager,
                          Catalog* catalog = nullptr);
    ~IndexManager();
    IndexManager(const IndexManager&) = delete;
    IndexManager& operator=(const IndexManager&) = delete;
    bool CreateIndex(const std::string& index_name,
                     const std::string& table_name,
                     const std::vector<std::string>& key_columns,
                     const Schema* table_schema);
    bool DropIndex(const std::string& index_name);
    bool InsertEntry(const std::string& index_name, const Value& key,
                     const RID& rid);
    bool DeleteEntry(const std::string& index_name, const Value& key);
    bool FindEntry(const std::string& index_name, const Value& key, RID* rid);
    template <typename KeyType>
    BPlusTree<KeyType, RID>* GetIndex(const std::string& index_name);
    std::vector<std::string> GetAllIndexNames() const;
    std::vector<std::string> GetTableIndexes(
        const std::string& table_name) const;
   private:
    std::unique_ptr<IndexManagerImpl> impl_;
};
}


========== ./src/parser/ast.h ==========
namespace SimpleRDBMS {
class ASTVisitor;
class ASTNode {
   public:
    virtual ~ASTNode() = default;
    virtual void Accept(ASTVisitor* visitor) = 0;
};
class Expression : public ASTNode {
   public:
    enum class ExprType {
        CONSTANT,
        COLUMN_REF,
        BINARY_OP,
        UNARY_OP,
        FUNCTION_CALL
    };
    virtual ExprType GetType() const = 0;
};
class ConstantExpression : public Expression {
   public:
    explicit ConstantExpression(const Value& value) : value_(value) {}
    ExprType GetType() const override { return ExprType::CONSTANT; }
    void Accept(ASTVisitor* visitor) override;
    const Value& GetValue() const { return value_; }
   private:
    Value value_;
};
class ColumnRefExpression : public Expression {
   public:
    ColumnRefExpression(const std::string& table, const std::string& column)
        : table_name_(table), column_name_(column) {}
    ExprType GetType() const override { return ExprType::COLUMN_REF; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetTableName() const { return table_name_; }
    const std::string& GetColumnName() const { return column_name_; }
   private:
    std::string table_name_;
    std::string column_name_;
};
class Statement : public ASTNode {
   public:
    enum class StmtType {
        SELECT,
        INSERT,
        UPDATE,
        DELETE,
        CREATE_TABLE,
        DROP_TABLE,
        CREATE_INDEX,
        DROP_INDEX,
        SHOW_TABLES,
        BEGIN_TXN,
        COMMIT_TXN,
        ROLLBACK_TXN,
        EXPLAIN
    };
    virtual StmtType GetType() const = 0;
};
class SelectStatement : public Statement {
   public:
    SelectStatement(std::vector<std::unique_ptr<Expression>> select_list,
                    std::string table_name,
                    std::unique_ptr<Expression> where_clause = nullptr)
        : select_list_(std::move(select_list)),
          table_name_(std::move(table_name)),
          where_clause_(std::move(where_clause)) {}
    StmtType GetType() const override { return StmtType::SELECT; }
    void Accept(ASTVisitor* visitor) override;
    const std::vector<std::unique_ptr<Expression>>& GetSelectList() const {
        return select_list_;
    }
    const std::string& GetTableName() const { return table_name_; }
    Expression* GetWhereClause() const { return where_clause_.get(); }
   private:
    std::vector<std::unique_ptr<Expression>>
        select_list_;
    std::string table_name_;
    std::unique_ptr<Expression> where_clause_;
};
class CreateTableStatement : public Statement {
   public:
    CreateTableStatement(const std::string& table_name,
                         std::vector<Column> columns)
        : table_name_(table_name), columns_(std::move(columns)) {}
    StmtType GetType() const override { return StmtType::CREATE_TABLE; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetTableName() const { return table_name_; }
    const std::vector<Column>& GetColumns() const { return columns_; }
   private:
    std::string table_name_;
    std::vector<Column> columns_;
};
class InsertStatement : public Statement {
   public:
    InsertStatement(const std::string& table_name,
                    std::vector<std::vector<Value>> values)
        : table_name_(table_name), values_(std::move(values)) {}
    StmtType GetType() const override { return StmtType::INSERT; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetTableName() const { return table_name_; }
    const std::vector<std::vector<Value>>& GetValues() const { return values_; }
   private:
    std::string table_name_;
    std::vector<std::vector<Value>> values_;
};
class DropTableStatement : public Statement {
   public:
    explicit DropTableStatement(const std::string& table_name)
        : table_name_(table_name) {}
    StmtType GetType() const override { return StmtType::DROP_TABLE; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetTableName() const { return table_name_; }
   private:
    std::string table_name_;
};
class CreateIndexStatement : public Statement {
   public:
    CreateIndexStatement(const std::string& index_name,
                         const std::string& table_name,
                         const std::vector<std::string>& key_columns)
        : index_name_(index_name),
          table_name_(table_name),
          key_columns_(key_columns) {}
    StmtType GetType() const override { return StmtType::CREATE_INDEX; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetIndexName() const { return index_name_; }
    const std::string& GetTableName() const { return table_name_; }
    const std::vector<std::string>& GetKeyColumns() const {
        return key_columns_;
    }
   private:
    std::string index_name_;
    std::string table_name_;
    std::vector<std::string> key_columns_;
};
class DropIndexStatement : public Statement {
   public:
    explicit DropIndexStatement(const std::string& index_name)
        : index_name_(index_name) {}
    StmtType GetType() const override { return StmtType::DROP_INDEX; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetIndexName() const { return index_name_; }
   private:
    std::string index_name_;
};
class BinaryOpExpression : public Expression {
   public:
    enum class OpType {
        EQUALS,
        NOT_EQUALS,
        LESS_THAN,
        GREATER_THAN,
        LESS_EQUALS,
        GREATER_EQUALS,
        AND,
        OR,
        PLUS,
        MINUS,
        MULTIPLY,
        DIVIDE,
    };
    BinaryOpExpression(std::unique_ptr<Expression> left, OpType op,
                       std::unique_ptr<Expression> right)
        : left_(std::move(left)), op_(op), right_(std::move(right)) {}
    ExprType GetType() const override { return ExprType::BINARY_OP; }
    void Accept(ASTVisitor* visitor) override;
    Expression* GetLeft() const { return left_.get(); }
    Expression* GetRight() const { return right_.get(); }
    OpType GetOperator() const { return op_; }
   private:
    std::unique_ptr<Expression> left_;
    OpType op_;
    std::unique_ptr<Expression> right_;
};
struct UpdateClause {
    std::string column_name;
    std::unique_ptr<Expression> value;
    UpdateClause(const std::string& col, std::unique_ptr<Expression> val)
        : column_name(col), value(std::move(val)) {}
};
class UpdateStatement : public Statement {
   public:
    UpdateStatement(const std::string& table_name,
                    std::vector<UpdateClause> update_clauses,
                    std::unique_ptr<Expression> where_clause = nullptr)
        : table_name_(table_name),
          update_clauses_(std::move(update_clauses)),
          where_clause_(std::move(where_clause)) {}
    StmtType GetType() const override { return StmtType::UPDATE; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetTableName() const { return table_name_; }
    const std::vector<UpdateClause>& GetUpdateClauses() const {
        return update_clauses_;
    }
    Expression* GetWhereClause() const { return where_clause_.get(); }
   private:
    std::string table_name_;
    std::vector<UpdateClause> update_clauses_;
    std::unique_ptr<Expression> where_clause_;
};
class DeleteStatement : public Statement {
   public:
    DeleteStatement(const std::string& table_name,
                    std::unique_ptr<Expression> where_clause = nullptr)
        : table_name_(table_name), where_clause_(std::move(where_clause)) {}
    StmtType GetType() const override { return StmtType::DELETE; }
    void Accept(ASTVisitor* visitor) override;
    const std::string& GetTableName() const { return table_name_; }
    Expression* GetWhereClause() const { return where_clause_.get(); }
   private:
    std::string table_name_;
    std::unique_ptr<Expression> where_clause_;
};
class UnaryOpExpression : public Expression {
   public:
    enum class OpType {
        NOT,
        NEGATIVE
    };
    UnaryOpExpression(OpType op, std::unique_ptr<Expression> operand)
        : op_(op), operand_(std::move(operand)) {}
    ExprType GetType() const override { return ExprType::UNARY_OP; }
    void Accept(ASTVisitor* visitor) override;
    OpType GetOperator() const { return op_; }
    Expression* GetOperand() const { return operand_.get(); }
   private:
    OpType op_;
    std::unique_ptr<Expression> operand_;
};
class ShowTablesStatement : public Statement {
   public:
    ShowTablesStatement() = default;
    StmtType GetType() const override { return StmtType::SHOW_TABLES; }
    void Accept(ASTVisitor* visitor) override;
};
class BeginStatement : public Statement {
   public:
    BeginStatement() = default;
    StmtType GetType() const override { return StmtType::BEGIN_TXN; }
    void Accept(ASTVisitor* visitor) override;
};
class CommitStatement : public Statement {
   public:
    CommitStatement() = default;
    StmtType GetType() const override { return StmtType::COMMIT_TXN; }
    void Accept(ASTVisitor* visitor) override;
};
class RollbackStatement : public Statement {
   public:
    RollbackStatement() = default;
    StmtType GetType() const override { return StmtType::ROLLBACK_TXN; }
    void Accept(ASTVisitor* visitor) override;
};
class ExplainStatement : public Statement {
   public:
    explicit ExplainStatement(std::unique_ptr<Statement> stmt)
        : statement_(std::move(stmt)) {}
    StmtType GetType() const override { return StmtType::EXPLAIN; }
    void Accept(ASTVisitor* visitor) override;
    Statement* GetStatement() const { return statement_.get(); }
   private:
    std::unique_ptr<Statement> statement_;
};
class ASTVisitor {
   public:
    virtual ~ASTVisitor() = default;
    virtual void Visit(ConstantExpression* expr) = 0;
    virtual void Visit(ColumnRefExpression* expr) = 0;
    virtual void Visit(BinaryOpExpression* expr) = 0;
    virtual void Visit(UnaryOpExpression* expr) = 0;
    virtual void Visit(SelectStatement* stmt) = 0;
    virtual void Visit(InsertStatement* stmt) = 0;
    virtual void Visit(UpdateStatement* stmt) = 0;
    virtual void Visit(DeleteStatement* stmt) = 0;
    virtual void Visit(CreateTableStatement* stmt) = 0;
    virtual void Visit(DropTableStatement* stmt) = 0;
    virtual void Visit(CreateIndexStatement* stmt) = 0;
    virtual void Visit(DropIndexStatement* stmt) = 0;
    virtual void Visit(ShowTablesStatement* stmt) = 0;
    virtual void Visit(BeginStatement* stmt) = 0;
    virtual void Visit(CommitStatement* stmt) = 0;
    virtual void Visit(RollbackStatement* stmt) = 0;
    virtual void Visit(ExplainStatement* stmt) = 0;
};
}


========== ./src/parser/lexer.h ==========
namespace SimpleRDBMS {
enum class TokenType {
    SELECT,
    FROM,
    WHERE,
    INSERT,
    INTO,
    VALUES,
    UPDATE,
    SET,
    DELETE,
    CREATE,
    TABLE,
    DROP,
    INDEX,
    ON,
    PRIMARY,
    KEY,
    NOT,
    _NULL,
    INT,
    BIGINT,
    VARCHAR,
    FLOAT,
    DOUBLE,
    BOOLEAN,
    AND,
    OR,
    EQUALS,
    NOT_EQUALS,
    LESS_THAN,
    GREATER_THAN,
    LESS_EQUALS,
    GREATER_EQUALS,
    PLUS,
    MINUS,
    MULTIPLY,
    DIVIDE,
    INTEGER_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    BOOLEAN_LITERAL,
    IDENTIFIER,
    LPAREN,
    RPAREN,
    COMMA,
    SEMICOLON,
    STAR,
    EOF_TOKEN,
    INVALID,
    SHOW,
    TABLES,
    BEGIN,
    COMMIT,
    ROLLBACK,
    EXPLAIN,
};
struct Token {
    TokenType type;
    std::string value;
    size_t line;
    size_t column;
};
class Lexer {
   public:
    explicit Lexer(const std::string& input);
    Token NextToken();
   private:
    std::string input_;
    size_t position_;
    size_t line_;
    size_t column_;
    char Peek();
    char Advance();
    void SkipWhitespace();
    Token ScanNumber();
    Token ScanString();
    Token ScanIdentifier();
};
}


========== ./src/parser/parser.h ==========
namespace SimpleRDBMS {
class Parser {
   public:
    explicit Parser(const std::string& sql);
    std::unique_ptr<Statement> Parse();
    void SetQuery(const std::string& sql) {
        lexer_ = Lexer(sql);
        Advance();
    }
   private:
    Lexer lexer_;
    Token current_token_;
    void Advance();
    bool Match(TokenType type);
    void Expect(TokenType type);
    std::unique_ptr<Statement> ParseStatement();
    std::unique_ptr<Statement> ParseSelectStatement();
    std::unique_ptr<Statement> ParseCreateTableStatement();
    std::unique_ptr<Statement> ParseDropTableStatement();
    std::unique_ptr<Statement> ParseInsertStatement();
    std::unique_ptr<Statement> ParseUpdateStatement();
    std::unique_ptr<Statement> ParseDeleteStatement();
    std::unique_ptr<Statement> ParseShowTablesStatement();
    std::unique_ptr<Statement> ParseBeginStatement();
    std::unique_ptr<Statement> ParseCommitStatement();
    std::unique_ptr<Statement> ParseRollbackStatement();
    std::unique_ptr<Statement> ParseExplainStatement();
    std::unique_ptr<Statement> ParseCreateIndexStatement();
    std::unique_ptr<Statement> ParseDropIndexStatement();
    std::unique_ptr<Expression> ParseExpression();
    std::unique_ptr<Expression> ParseOrExpression();
    std::unique_ptr<Expression> ParseAndExpression();
    std::unique_ptr<Expression> ParseComparisonExpression();
    std::unique_ptr<Expression> ParseArithmeticExpression();
    std::unique_ptr<Expression> ParseTermExpression();
    std::unique_ptr<Expression> ParseUnaryExpression();
    std::unique_ptr<Expression> ParsePrimaryExpression();
    std::vector<Column> ParseColumnDefinitions();
    TypeId ParseDataType();
};
}


========== ./src/record/table_heap.h ==========
namespace SimpleRDBMS {
class TablePage : public Page {
   public:
    void Init(page_id_t page_id, page_id_t prev_page_id);
    bool InsertTuple(const Tuple& tuple, RID* rid);
    bool DeleteTuple(const RID& rid);
    bool UpdateTuple(const Tuple& tuple, const RID& rid);
    bool GetTuple(const RID& rid, Tuple* tuple, const Schema* schema);
    bool GetNextTupleRID(const RID& current_rid, RID* next_rid);
    page_id_t GetNextPageId() const;
    void SetNextPageId(page_id_t next_page_id);
    struct TablePageHeader {
        page_id_t next_page_id;
        lsn_t lsn;
        uint16_t num_tuples;
        uint16_t free_space_offset;
    };
    const TablePageHeader* GetHeader() const;
    TablePageHeader* GetHeader();
};
class TableHeap {
   public:
    TableHeap(BufferPoolManager* buffer_pool_manager, const Schema* schema);
    TableHeap(BufferPoolManager* buffer_pool_manager, const Schema* schema,
              page_id_t first_page_id);
    ~TableHeap();
    bool InsertTuple(const Tuple& tuple, RID* rid, txn_id_t txn_id);
    bool DeleteTuple(const RID& rid, txn_id_t txn_id);
    bool UpdateTuple(const Tuple& tuple, const RID& rid, txn_id_t txn_id);
    bool GetTuple(const RID& rid, Tuple* tuple, txn_id_t txn_id);
    page_id_t GetFirstPageId() const { return first_page_id_; }
    void SetLogManager(LogManager* log_manager) { log_manager_ = log_manager; }
    class Iterator {
       public:
        Iterator(TableHeap* table_heap, const RID& rid);
        Iterator()
            : table_heap_(nullptr), current_rid_({INVALID_PAGE_ID, -1}) {}
        bool IsEnd() const;
        void operator++();
        Tuple operator*();
       private:
        TableHeap* table_heap_;
        RID current_rid_;
    };
    Iterator Begin();
    Iterator End();
   private:
    BufferPoolManager* buffer_pool_manager_;
    const Schema* schema_;
    page_id_t first_page_id_;
    LogManager* log_manager_ = nullptr;
};
}


========== ./src/record/tuple.h ==========
namespace SimpleRDBMS {
class Tuple {
   public:
    Tuple() : serialized_size_(0) {}
    Tuple(std::vector<Value> values, const Schema* schema);
    Value GetValue(size_t index) const;
    const std::vector<Value>& GetValues() const { return values_; }
    void SerializeTo(char* data) const;
    void DeserializeFrom(const char* data, const Schema* schema);
    size_t GetSerializedSize() const;
    RID GetRID() const { return rid_; }
    void SetRID(const RID& rid) { rid_ = rid; }
   private:
    std::vector<Value> values_;
    RID rid_;
    size_t serialized_size_;
};
}


========== ./src/recovery/log_manager.h ==========
namespace SimpleRDBMS {
class LogManager {
   public:
    explicit LogManager(DiskManager* disk_manager);
    ~LogManager();
    lsn_t AppendLogRecord(LogRecord* log_record);
    void Flush(lsn_t lsn = -1);
    lsn_t GetNextLSN() { return next_lsn_.fetch_add(1); }
    lsn_t GetPersistentLSN() const { return persistent_lsn_.load(); }
    std::vector<std::unique_ptr<LogRecord>> ReadLogRecords();
    void SetEnable(bool enable) { enable_logging_ = enable; }
   private:
    DiskManager* disk_manager_;
    char* log_buffer_;
    size_t log_buffer_size_;
    size_t log_buffer_offset_;
    std::atomic<lsn_t> next_lsn_{0};
    std::atomic<lsn_t> persistent_lsn_{INVALID_LSN};
    std::mutex latch_;
    std::condition_variable flush_cv_;
    std::atomic<bool> flush_thread_running_{false};
    bool enable_logging_{true};
    page_id_t current_log_page_id_{0};
    void FlushLogBuffer();
    void BackgroundFlush();
};
}


========== ./src/recovery/log_record.h ==========
namespace SimpleRDBMS {
enum class LogRecordType {
    INVALID = 0,
    INSERT,
    UPDATE,
    DELETE,
    BEGIN,
    COMMIT,
    ABORT,
    CHECKPOINT
};
class LogRecord {
   public:
    LogRecord(LogRecordType type, txn_id_t txn_id, lsn_t prev_lsn)
        : type_(type), txn_id_(txn_id), prev_lsn_(prev_lsn), size_(0) {}
    virtual ~LogRecord() = default;
    virtual void SerializeTo(char* buffer) const = 0;
    virtual size_t GetLogRecordSize() const = 0;
    static std::unique_ptr<LogRecord> DeserializeFrom(const char* buffer);
    LogRecordType GetType() const { return type_; }
    txn_id_t GetTxnId() const { return txn_id_; }
    lsn_t GetPrevLSN() const { return prev_lsn_; }
    size_t GetSize() const { return size_; }
   protected:
    LogRecordType type_;
    txn_id_t txn_id_;
    lsn_t prev_lsn_;
    size_t size_;
};
class InsertLogRecord : public LogRecord {
   public:
    InsertLogRecord(txn_id_t txn_id, lsn_t prev_lsn, const RID& rid,
                    const Tuple& tuple)
        : LogRecord(LogRecordType::INSERT, txn_id, prev_lsn),
          rid_(rid),
          tuple_(tuple) {}
    void SerializeTo(char* buffer) const override;
    size_t GetLogRecordSize() const override {
        return sizeof(page_id_t) + sizeof(slot_offset_t) +
               tuple_.GetSerializedSize();
    }
    const RID& GetRID() const { return rid_; }
    const Tuple& GetTuple() const { return tuple_; }
   private:
    RID rid_;
    Tuple tuple_;
};
class UpdateLogRecord : public LogRecord {
   public:
    UpdateLogRecord(txn_id_t txn_id, lsn_t prev_lsn, const RID& rid,
                    const Tuple& old_tuple, const Tuple& new_tuple)
        : LogRecord(LogRecordType::UPDATE, txn_id, prev_lsn),
          rid_(rid),
          old_tuple_(old_tuple),
          new_tuple_(new_tuple) {}
    void SerializeTo(char* buffer) const override;
    size_t GetLogRecordSize() const override {
        return sizeof(page_id_t) + sizeof(slot_offset_t) +
               old_tuple_.GetSerializedSize() + new_tuple_.GetSerializedSize();
    }
    const RID& GetRID() const { return rid_; }
    const Tuple& GetOldTuple() const { return old_tuple_; }
    const Tuple& GetNewTuple() const { return new_tuple_; }
   private:
    RID rid_;
    Tuple old_tuple_;
    Tuple new_tuple_;
};
class DeleteLogRecord : public LogRecord {
   public:
    DeleteLogRecord(txn_id_t txn_id, lsn_t prev_lsn, const RID& rid,
                    const Tuple& deleted_tuple)
        : LogRecord(LogRecordType::DELETE, txn_id, prev_lsn),
          rid_(rid),
          deleted_tuple_(deleted_tuple) {}
    ~DeleteLogRecord() override = default;
    void SerializeTo(char* buffer) const override;
    size_t GetLogRecordSize() const override {
        return sizeof(page_id_t) + sizeof(slot_offset_t) +
               deleted_tuple_.GetSerializedSize();
    }
    const RID& GetRID() const { return rid_; }
    const Tuple& GetDeletedTuple() const { return deleted_tuple_; }
   private:
    RID rid_;
    Tuple deleted_tuple_;
};
class BeginLogRecord : public LogRecord {
   public:
    BeginLogRecord(txn_id_t txn_id)
        : LogRecord(LogRecordType::BEGIN, txn_id, INVALID_LSN) {}
    ~BeginLogRecord() override = default;
    void SerializeTo(char* buffer) const override;
    size_t GetLogRecordSize() const override { return 0; }
};
class CommitLogRecord : public LogRecord {
   public:
    CommitLogRecord(txn_id_t txn_id, lsn_t prev_lsn)
        : LogRecord(LogRecordType::COMMIT, txn_id, prev_lsn) {}
    ~CommitLogRecord() override = default;
    void SerializeTo(char* buffer) const override;
    size_t GetLogRecordSize() const override { return 0; }
};
class AbortLogRecord : public LogRecord {
   public:
    AbortLogRecord(txn_id_t txn_id, lsn_t prev_lsn)
        : LogRecord(LogRecordType::ABORT, txn_id, prev_lsn) {}
    ~AbortLogRecord() override = default;
    void SerializeTo(char* buffer) const override;
    size_t GetLogRecordSize() const override { return 0; }
};
}


========== ./src/recovery/recovery_manager.h ==========
namespace SimpleRDBMS {
class RecoveryManager {
   public:
    RecoveryManager(BufferPoolManager* buffer_pool_manager, Catalog* catalog,
                    LogManager* log_manager, LockManager* lock_manager);
    void Recover();
    void Checkpoint();
   private:
    BufferPoolManager* buffer_pool_manager_;
    Catalog* catalog_;
    LogManager* log_manager_;
    LockManager* lock_manager_;
    std::unordered_map<txn_id_t, lsn_t> active_txn_table_;
    std::unordered_map<page_id_t, lsn_t> dirty_page_table_;
    void AnalysisPhase(
        const std::vector<std::unique_ptr<LogRecord>>& log_records);
    void RedoPhase(const std::vector<std::unique_ptr<LogRecord>>& log_records);
    void UndoPhase(const std::vector<std::unique_ptr<LogRecord>>& log_records);
    void RedoInsert(const InsertLogRecord* log_record);
    void RedoUpdate(const UpdateLogRecord* log_record);
    void UndoInsert(const InsertLogRecord* log_record);
    void UndoUpdate(const UpdateLogRecord* log_record);
    void UndoDelete(const UpdateLogRecord* log_record);
    void RedoDelete(const DeleteLogRecord* log_record);
    void UndoDelete(const DeleteLogRecord* log_record);
};
}


========== ./src/storage/disk_manager.h ==========
namespace SimpleRDBMS {
class DiskManager {
   public:
    explicit DiskManager(const std::string& db_file);
    ~DiskManager();
    void ReadPage(page_id_t page_id, char* page_data);
    void WritePage(page_id_t page_id, const char* page_data);
    page_id_t AllocatePage();
    void DeallocatePage(page_id_t page_id);
    int GetNumPages() const { return num_pages_; }
   private:
    std::string db_file_name_;
    std::fstream db_file_;
    int num_pages_;
    int next_page_id_;
    std::mutex latch_;
    std::vector<page_id_t> free_pages_;
};
}


========== ./src/storage/page.h ==========
namespace SimpleRDBMS {
class Page {
   public:
    Page();
    ~Page();
    Page(const Page&) = delete;
    Page& operator=(const Page&) = delete;
    char* GetData() { return data_; }
    const char* GetData() const { return data_; }
    page_id_t GetPageId() const { return page_id_; }
    void SetPageId(page_id_t page_id) { page_id_ = page_id; }
    void IncreasePinCount() { pin_count_++; }
    void DecreasePinCount() { pin_count_--; }
    int GetPinCount() const { return pin_count_; }
    bool IsDirty() const { return is_dirty_; }
    void SetDirty(bool dirty) { is_dirty_ = dirty; }
    lsn_t GetLSN() const { return lsn_; }
    void SetLSN(lsn_t lsn) { lsn_ = lsn; }
    void WLatch() { latch_.lock(); }
    void WUnlatch() { latch_.unlock(); }
    void RLatch() { latch_.lock_shared(); }
    void RUnlatch() { latch_.unlock_shared(); }
   protected:
    char data_[PAGE_SIZE];
    page_id_t page_id_;
    int pin_count_;
    bool is_dirty_;
    lsn_t lsn_;
    std::shared_mutex latch_;
};
}


========== ./src/transaction/lock_manager.h ==========
namespace SimpleRDBMS {
enum class LockMode { SHARED = 0, EXCLUSIVE };
class LockManager {
   public:
    LockManager() = default;
    ~LockManager() = default;
    bool LockShared(Transaction* txn, const RID& rid);
    bool LockExclusive(Transaction* txn, const RID& rid);
    bool LockUpgrade(Transaction* txn, const RID& rid);
    bool Unlock(Transaction* txn, const RID& rid);
    void UnlockAll(Transaction* txn);
   private:
    struct LockRequest {
        txn_id_t txn_id;
        LockMode lock_mode;
        bool granted;
    };
    struct LockRequestQueue {
        std::list<std::unique_ptr<LockRequest>> request_queue;
        std::condition_variable cv;
        bool upgrading = false;
    };
    std::mutex latch_;
    std::unordered_map<RID, std::unique_ptr<LockRequestQueue>> lock_table_;
    bool GrantLock(LockRequest* request, LockRequestQueue* queue);
    void GrantNewLocksInQueue(LockRequestQueue* queue);
    bool CheckAbort(Transaction* txn);
};
}


========== ./src/transaction/transaction.h ==========
namespace SimpleRDBMS {
enum class TransactionState {
    INVALID = 0,
    GROWING,
    SHRINKING,
    COMMITTED,
    ABORTED
};
enum class IsolationLevel {
    READ_UNCOMMITTED = 0,
    READ_COMMITTED,
    REPEATABLE_READ,
    SERIALIZABLE
};
class Transaction {
   public:
    explicit Transaction(txn_id_t txn_id, IsolationLevel isolation_level =
                                              IsolationLevel::REPEATABLE_READ);
    ~Transaction();
    txn_id_t GetTxnId() const { return txn_id_; }
    TransactionState GetState() const { return state_; }
    void SetState(TransactionState state) { state_ = state; }
    IsolationLevel GetIsolationLevel() const { return isolation_level_; }
    lsn_t GetPrevLSN() const { return prev_lsn_; }
    void SetPrevLSN(lsn_t lsn) { prev_lsn_ = lsn; }
    void AddSharedLock(const RID& rid) { shared_lock_set_.insert(rid); }
    void AddExclusiveLock(const RID& rid) { exclusive_lock_set_.insert(rid); }
    void RemoveSharedLock(const RID& rid) { shared_lock_set_.erase(rid); }
    void RemoveExclusiveLock(const RID& rid) { exclusive_lock_set_.erase(rid); }
    const std::unordered_set<RID>& GetSharedLockSet() const {
        return shared_lock_set_;
    }
    const std::unordered_set<RID>& GetExclusiveLockSet() const {
        return exclusive_lock_set_;
    }
    void AddToWriteSet(const RID& rid, const Tuple& tuple);
    const std::unordered_map<RID, Tuple>& GetWriteSet() const {
        return write_set_;
    }
    bool IsAborted() const { return state_ == TransactionState::ABORTED; }
   private:
    txn_id_t txn_id_;
    TransactionState state_;
    IsolationLevel isolation_level_;
    lsn_t prev_lsn_;
    std::unordered_set<RID> shared_lock_set_;
    std::unordered_set<RID> exclusive_lock_set_;
    std::unordered_map<RID, Tuple> write_set_;
};
}


========== ./src/transaction/transaction_manager.h ==========
namespace SimpleRDBMS {
class TransactionManager {
   public:
    TransactionManager(LockManager* lock_manager, LogManager* log_manager);
    ~TransactionManager();
    Transaction* Begin(
        IsolationLevel isolation_level = IsolationLevel::REPEATABLE_READ);
    bool Commit(Transaction* txn);
    bool Abort(Transaction* txn);
    LockManager* GetLockManager() { return lock_manager_; }
    txn_id_t GetNextTxnId() { return next_txn_id_.fetch_add(1); }
   private:
    std::atomic<txn_id_t> next_txn_id_{0};
    LockManager* lock_manager_;
    LogManager* log_manager_;
    std::unordered_map<txn_id_t, std::unique_ptr<Transaction>> txn_map_;
    std::mutex txn_map_latch_;
};
}


